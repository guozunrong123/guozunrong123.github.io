<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="代码随想录_贪心算法, ZRong&#39;s Blog">
    <meta name="description" content="贪心算法专项练习">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>代码随想录_贪心算法 | ZRong&#39;s Blog</title>
    <link rel="icon" type="image/png" href="/16favicon.png">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="ZRong's Blog" type="application/atom+xml">
</head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/16favicon.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">ZRong&#39;s Blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/16favicon.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">ZRong&#39;s Blog</div>
        <div class="logo-desc">
            
            There is no royal road to learning.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/19.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">代码随想录_贪心算法</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Code/">
                                <span class="chip bg-color">Code</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Learn/" class="post-category">
                                Learn
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2023-03-27
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    4.7k
                </div>
                

                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.min.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <meta name="referrer" content="no-referrer" />

<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h2 id="分发饼干"><a href="#分发饼干" class="headerlink" title="分发饼干"></a>分发饼干</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230326105229879.png"></p>
<h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p><strong>大饼干喂给大胃口</strong></p>
<p>使用贪心策略，先将饼干数组和小孩数组排序。然后从后向前遍历小孩数组，用大饼干优先满足胃口大的，并统计满足小孩数量。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
public:
    int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123;
        sort(g.begin(),g.end());
        sort(s.begin(),s.end());
        int index &#x3D; s.size()-1;
        int result &#x3D; 0;
        for(int i&#x3D;g.size()-1;i&gt;&#x3D;0;i--)&#123;
            if(index&gt;&#x3D;0 &amp;&amp; g[i]&lt;&#x3D;s[index])&#123;
                index--;
                result++;
            &#125;
        &#125;
        return result;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p><strong>小饼干喂给小胃口</strong></p>
<p>饼干从小变大，满足胃口小的小孩，从前向后遍历，并统计。</p>
<h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
public:
    int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123;
        sort(g.begin(),g.end());
        sort(s.begin(),s.end());
        int index &#x3D; 0;
        for(int i&#x3D;0;i&lt;s.size();i++)&#123;
            if(index&lt;g.size() &amp;&amp; s[i]&gt;&#x3D;g[index])&#123;
                index++;
            &#125;
        &#125;
        return index;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="摆动序列"><a href="#摆动序列" class="headerlink" title="摆动序列"></a>摆动序列</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230326120120304.png"></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>判断有多少个局部峰值</p>
<h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
public:
    int wiggleMaxLength(vector&lt;int&gt;&amp; nums) &#123;
        if(nums.size()&#x3D;&#x3D;1)return 1;
        int pre &#x3D; 0;
        int cur &#x3D; 0;
        int result &#x3D; 1;
        for(int i&#x3D;1;i&lt;nums.size();i++)&#123;
            cur&#x3D;nums[i]-nums[i-1];
            if((cur&gt;0 &amp;&amp; pre&lt;&#x3D;0) || (cur&lt;0 &amp;&amp; pre&gt;&#x3D;0))&#123;
                result++;
                pre&#x3D;cur;
            &#125;
        &#125;
        return result;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230326130302014.png"></p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>用maxSum记录最大的子序列和，用count记录全部和。如果count&lt;0了，会使之后的和变小，所有把他清零，从下一个开始算。</p>
<h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
public:
    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;
        int maxSum&#x3D;INT_MIN;
        int count&#x3D;0;
        for(int i&#x3D;0;i&lt;nums.size();i++)&#123;
            count +&#x3D; nums[i];
            maxSum &#x3D; count&gt;maxSum?count:maxSum;
            if(count&lt;0)&#123;
                count &#x3D; 0;
            &#125;
        &#125;
        return maxSum;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="买卖股票的最佳时机II"><a href="#买卖股票的最佳时机II" class="headerlink" title="买卖股票的最佳时机II"></a>买卖股票的最佳时机II</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>我们需要收集每天的正利润就可以，收集正利润的区间，就是股票买卖的区间，而我们只需要关注最终利润，不需要记录区间。</p>
<h3 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;
        int pre &#x3D; prices[0];
        int cur &#x3D; 0;
        int profit &#x3D; 0;
        for(int i&#x3D;0;i&lt;prices.size();i++)&#123;
            cur&#x3D;prices[i];
            if(cur&gt;&#x3D;pre)&#123;
                profit +&#x3D; cur-pre;
            &#125;
            pre&#x3D;cur;
        &#125;
        return profit;
    &#125;
&#125;; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>简化后</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;
        int result &#x3D; 0;
        for (int i &#x3D; 1; i &lt; prices.size(); i++) &#123;
            result +&#x3D; max(prices[i] - prices[i - 1], 0);
        &#125;
        return result;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230326145741030.png"></p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>局部最优：每次取最大跳跃步数（取最大覆盖范围）</p>
<p>整体最优：最后得到整体最大覆盖范围，看是否能到终点。</p>
<h3 id="Code-5"><a href="#Code-5" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
public:
    bool canJump(vector&lt;int&gt;&amp; nums) &#123;
        int maxCount&#x3D;0;
        for(int i&#x3D;0;i&lt;nums.size();i++)&#123;
            if(maxCount&lt;i)return false;
            maxCount&#x3D;max(maxCount,i+nums[i]);
            cout&lt;&lt;maxCount;
        &#125;
        return true;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="跳跃游戏II"><a href="#跳跃游戏II" class="headerlink" title="跳跃游戏II"></a>跳跃游戏II</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230326145752701.png"></p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>移动下标达到了当前覆盖的最远距离下标时，步数就要加一，来增加覆盖距离。最后的步数就是最少步数。</p>
<p>这里还是有个特殊情况需要考虑，当移动下标达到了当前覆盖的最远距离下标时</p>
<ul>
<li>如果当前覆盖最远距离下标不是是集合终点，步数就加一，还需要继续走。</li>
<li>如果当前覆盖最远距离下标就是是集合终点，步数不用加一，因为不能再往后走了。</li>
</ul>
<h3 id="Code-6"><a href="#Code-6" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
public:
    int jump(vector&lt;int&gt;&amp; nums) &#123;
        if (nums.size() &#x3D;&#x3D; 1) return 0;
        int curDistance &#x3D; 0;    &#x2F;&#x2F; 当前覆盖最远距离下标
        int ans &#x3D; 0;            &#x2F;&#x2F; 记录走的最大步数
        int nextDistance &#x3D; 0;   &#x2F;&#x2F; 下一步覆盖最远距离下标
        for (int i &#x3D; 0; i &lt; nums.size(); i++) &#123;
            nextDistance &#x3D; max(nums[i] + i, nextDistance);  &#x2F;&#x2F; 更新下一步覆盖最远距离下标
            if (i &#x3D;&#x3D; curDistance) &#123;                         &#x2F;&#x2F; 遇到当前覆盖最远距离下标
                if (curDistance &lt; nums.size() - 1) &#123;       &#x2F;&#x2F; 如果当前覆盖最远距离下标不是终点
                    ans++;                                  &#x2F;&#x2F; 需要走下一步
                    curDistance &#x3D; nextDistance;             &#x2F;&#x2F; 更新当前覆盖最远距离下标（相当于加油了）
                    if (nextDistance &gt;&#x3D; nums.size() - 1) break; &#x2F;&#x2F; 下一步的覆盖范围已经可以达到终点，结束循环
                &#125; else break;                               &#x2F;&#x2F; 当前覆盖最远距到达集合终点，不用做ans++操作了，直接结束
            &#125;
        &#125;
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="K次取反后最大化的数组和"><a href="#K次取反后最大化的数组和" class="headerlink" title="K次取反后最大化的数组和"></a>K次取反后最大化的数组和</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230326162653733.png"></p>
<h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>1、给数组取绝对值后排序。</p>
<p>2、从绝对值最大开始遍历，如果为负数就翻转。</p>
<p>3、到最后没翻转完，k有剩余的话就让最后一个绝对值最小的数自个翻转。</p>
<h3 id="Code-7"><a href="#Code-7" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
static bool cmp(int a, int b) &#123;
    return abs(a) &gt; abs(b);
&#125;
public:
    int largestSumAfterKNegations(vector&lt;int&gt;&amp; A, int K) &#123;
        sort(A.begin(), A.end(), cmp);       &#x2F;&#x2F; 第一步
        for (int i &#x3D; 0; i &lt; A.size(); i++) &#123; &#x2F;&#x2F; 第二步
            if (A[i] &lt; 0 &amp;&amp; K &gt; 0) &#123;
                A[i] *&#x3D; -1;
                K--;
            &#125;
        &#125;
        if (K % 2 &#x3D;&#x3D; 1) A[A.size() - 1] *&#x3D; -1; &#x2F;&#x2F; 第三步
        int result &#x3D; 0;
        for (int a : A) result +&#x3D; a;        &#x2F;&#x2F; 第四步
        return result;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="加油站"><a href="#加油站" class="headerlink" title="加油站"></a>加油站</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230326163618504.png"></p>
<h3 id="思路1-1"><a href="#思路1-1" class="headerlink" title="思路1"></a>思路1</h3><p>暴力搜索，遍历每一个加油站为起点的情况，模拟一圈。</p>
<p>如果跑了一圈，中途没有断油，而且最后油量大于等于0，说明这个起点是ok的。</p>
<p>暴力的方法思路比较简单，但代码写起来也不是很容易，关键是要模拟跑一圈的过程。</p>
<p><strong>for循环适合模拟从头到尾的遍历，而while循环适合模拟环形遍历，要善于使用while！</strong></p>
<h3 id="Code-8"><a href="#Code-8" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
public:
    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123;
        for (int i &#x3D; 0; i &lt; cost.size(); i++) &#123;
            int rest &#x3D; gas[i] - cost[i]; &#x2F;&#x2F; 记录剩余油量
            int index &#x3D; (i + 1) % cost.size();
            while (rest &gt; 0 &amp;&amp; index !&#x3D; i) &#123; &#x2F;&#x2F; 模拟以i为起点行驶一圈（如果有rest&#x3D;&#x3D;0，那么答案就不唯一了）
                rest +&#x3D; gas[index] - cost[index];
                index &#x3D; (index + 1) % cost.size();
            &#125;
            &#x2F;&#x2F; 如果以i为起点跑一圈，剩余油量&gt;&#x3D;0，返回该起始位置
            if (rest &gt;&#x3D; 0 &amp;&amp; index &#x3D;&#x3D; i) return i;
        &#125;
        return -1;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="思路2-1"><a href="#思路2-1" class="headerlink" title="思路2"></a>思路2</h3><p>直接从全局进行贪心选择，情况如下：</p>
<ul>
<li>情况一：如果gas的总和小于cost总和，那么无论从哪里出发，一定是跑不了一圈的</li>
<li>情况二：rest[i] &#x3D; gas[i]-cost[i]为一天剩下的油，i从0开始计算累加到最后一站，如果累加没有出现负数，说明从0出发，油就没有断过，那么0就是起点。</li>
<li>情况三：如果累加的最小值是负数，汽车就要从非0节点出发，从后向前，看哪个节点能把这个负数填平，能把这个负数填平的节点就是出发节点。</li>
</ul>
<p>为什么呢？我们先算出了从前到最后油箱的最小值，有可能是负多少。那么我们从后面开始补，看从哪开始油箱值能大于这个值的绝对值。</p>
<h3 id="Code-9"><a href="#Code-9" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
public:
    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123;
        int curSum &#x3D; 0;
        int min &#x3D; INT_MAX; &#x2F;&#x2F; 从起点出发，油箱里的油量最小值
        for (int i &#x3D; 0; i &lt; gas.size(); i++) &#123;
            int rest &#x3D; gas[i] - cost[i];
            curSum +&#x3D; rest;
            if (curSum &lt; min) &#123;
                min &#x3D; curSum;
            &#125;
        &#125;
        if (curSum &lt; 0) return -1;  &#x2F;&#x2F; 情况1
        if (min &gt;&#x3D; 0) return 0;     &#x2F;&#x2F; 情况2
                                    &#x2F;&#x2F; 情况3
        for (int i &#x3D; gas.size() - 1; i &gt;&#x3D; 0; i--) &#123;
            int rest &#x3D; gas[i] - cost[i];
            min +&#x3D; rest;
            if (min &gt;&#x3D; 0) &#123;
                return i;
            &#125;
        &#125;
        return -1;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="思路3"><a href="#思路3" class="headerlink" title="思路3"></a>思路3</h3><p>首先如果总油量减去总消耗大于等于零那么一定可以跑完一圈，说明各个站点的加油站剩油量rest[i]相加一定是大于等于零的。</p>
<p>每个加油站的剩余量rest[i]为gas[i] - cost[i]。</p>
<p>i从0开始累加rest[i]，和记为curSum，一旦curSum小于零，说明[0, i]区间都不能作为起始位置，因为这个区间选择任何一个位置作为起点，到i这里都会断油，那么起始位置从i+1算起，再从0计算curSum。</p>
<h3 id="Code-10"><a href="#Code-10" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
public:
    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123;
        int curSum &#x3D; 0;
        int totalSum &#x3D; 0;
        int start &#x3D; 0;
        for (int i &#x3D; 0; i &lt; gas.size(); i++) &#123;
            curSum +&#x3D; gas[i] - cost[i];
            totalSum +&#x3D; gas[i] - cost[i];
            if (curSum &lt; 0) &#123;   &#x2F;&#x2F; 当前累加rest[i]和 curSum一旦小于0
                start &#x3D; i + 1;  &#x2F;&#x2F; 起始位置更新为i+1
                curSum &#x3D; 0;     &#x2F;&#x2F; curSum从0开始
            &#125;
        &#125;
        if (totalSum &lt; 0) return -1; &#x2F;&#x2F; 说明怎么走都不可能跑一圈了
        return start;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="分发糖果"><a href="#分发糖果" class="headerlink" title="分发糖果"></a>分发糖果</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230326165835546.png"></p>
<h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>这道题目一定是要确定一边之后，再确定另一边，例如比较每一个孩子的左边，然后再比较右边，<strong>如果两边一起考虑一定会顾此失彼</strong>。</p>
<p>如果 ratings[i] &gt; ratings[i + 1]，此时candyVec[i]（第i个小孩的糖果数量）就有两个选择了，一个是candyVec[i + 1] + 1（从右边这个加1得到的糖果数量），一个是candyVec[i]（之前比较右孩子大于左孩子得到的糖果数量）。</p>
<p>那么又要贪心了，局部最优：取candyVec[i + 1] + 1 和 candyVec[i] 最大的糖果数量，保证第i个小孩的糖果数量既大于左边的也大于右边的。全局最优：相邻的孩子中，评分高的孩子获得更多的糖果。</p>
<p>局部最优可以推出全局最优。</p>
<p>所以就取candyVec[i + 1] + 1 和 candyVec[i] 最大的糖果数量，<strong>candyVec[i]只有取最大的才能既保持对左边candyVec[i - 1]的糖果多，也比右边candyVec[i + 1]的糖果多</strong>。</p>
<h3 id="Code-11"><a href="#Code-11" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
public:
    int candy(vector&lt;int&gt;&amp; ratings) &#123;
        vector&lt;int&gt; candyVec(ratings.size(), 1);
        &#x2F;&#x2F; 从前向后
        for (int i &#x3D; 1; i &lt; ratings.size(); i++) &#123;
            if (ratings[i] &gt; ratings[i - 1]) candyVec[i] &#x3D; candyVec[i - 1] + 1;
        &#125;
        &#x2F;&#x2F; 从后向前
        for (int i &#x3D; ratings.size() - 2; i &gt;&#x3D; 0; i--) &#123;
            if (ratings[i] &gt; ratings[i + 1] ) &#123;
                candyVec[i] &#x3D; max(candyVec[i], candyVec[i + 1] + 1);
            &#125;
        &#125;
        &#x2F;&#x2F; 统计结果
        int result &#x3D; 0;
        for (int i &#x3D; 0; i &lt; candyVec.size(); i++) result +&#x3D; candyVec[i];
        return result;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="柠檬水找零"><a href="#柠檬水找零" class="headerlink" title="柠檬水找零"></a>柠檬水找零</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230326172300797.png"></p>
<h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><p>特殊考虑20美元的情况，因为20美元可以找三张5美元或者一张10美元+1张5美元。</p>
<p>有如下三种情况：</p>
<ul>
<li>情况一：账单是5，直接收下。</li>
<li>情况二：账单是10，消耗一个5，增加一个10</li>
<li>情况三：账单是20，优先消耗一个10和一个5，如果不够，再消耗三个5</li>
</ul>
<h3 id="Code-12"><a href="#Code-12" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
public:
    int count&#x3D;0;
    int count10&#x3D;0;
    bool lemonadeChange(vector&lt;int&gt;&amp; bills) &#123;
        for(int i&#x3D;0;i&lt;bills.size();i++)&#123;
            if((bills[i]&#x2F;5)&#x3D;&#x3D;1)&#123;
                count++;
            &#125;
            else if(bills[i]&#x2F;5&#x3D;&#x3D;2)&#123;
                count -&#x3D; 1;
                count10++;
            &#125;
            else&#123;
                if(count10&gt;0)&#123;
                    count10--;
                    count--;
                &#125;
                else&#123;
                    count-&#x3D;3;
                &#125;
            &#125;
            cout&lt;&lt;count;
            if(count&lt;0)return false;
        &#125;
        return true;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="根据身高重建队列"><a href="#根据身高重建队列" class="headerlink" title="根据身高重建队列"></a>根据身高重建队列</h2><h3 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h3><h3 id="Code-13"><a href="#Code-13" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
public:
    static bool cmp(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) &#123;
        if (a[0] &#x3D;&#x3D; b[0]) return a[1] &lt; b[1];
        return a[0] &gt; b[0];
    &#125;
    vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) &#123;
        sort (people.begin(), people.end(), cmp);
        vector&lt;vector&lt;int&gt;&gt; que;
        for (int i &#x3D; 0; i &lt; people.size(); i++) &#123;
            int position &#x3D; people[i][1];
            que.insert(que.begin() + position, people[i]);
        &#125;
        return que;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>但使用vector是非常费时的，C++中vector（可以理解是一个动态数组，底层是普通数组实现的）如果插入元素大于预先普通数组大小，vector底部会有一个扩容的操作，即申请两倍于原先普通数组的大小，然后把数据拷贝到另一个更大的数组上。</p>
<p>所以使用vector（动态数组）来insert，是费时的，插入再拷贝的话，单纯一个插入的操作就是O(n^2)了，甚至可能拷贝好几次，就不止O(n*n)了。</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
public:
    &#x2F;&#x2F; 身高从大到小排（身高相同k小的站前面）
    static bool cmp(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) &#123;
        if (a[0] &#x3D;&#x3D; b[0]) return a[1] &lt; b[1];
        return a[0] &gt; b[0];
    &#125;
    vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) &#123;
        sort (people.begin(), people.end(), cmp);
        list&lt;vector&lt;int&gt;&gt; que; &#x2F;&#x2F; list底层是链表实现，插入效率比vector高的多
        for (int i &#x3D; 0; i &lt; people.size(); i++) &#123;
            int position &#x3D; people[i][1]; &#x2F;&#x2F; 插入到下标为position的位置
            std::list&lt;vector&lt;int&gt;&gt;::iterator it &#x3D; que.begin();
            while (position--) &#123; &#x2F;&#x2F; 寻找在插入位置
                it++;
            &#125;
            que.insert(it, people[i]);
        &#125;
        return vector&lt;vector&lt;int&gt;&gt;(que.begin(), que.end());
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="用最少数量的箭引爆气球"><a href="#用最少数量的箭引爆气球" class="headerlink" title="用最少数量的箭引爆气球"></a>用最少数量的箭引爆气球</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230326211954385.png"></p>
<h3 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h3><p>为了让气球尽可能的重叠，需要对数组进行排序。按从小到大排序。</p>
<p>下一个气球左边界大于了第一组重叠气球的最小右边界，就需要一支箭来射气球了。</p>
<p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230326220635787.png"></p>
<h3 id="Code-14"><a href="#Code-14" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
private:
    static bool cmp(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) &#123;
        return a[0] &lt; b[0];
    &#125;
public:
    int findMinArrowShots(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;
        if (points.size() &#x3D;&#x3D; 0) return 0;
        sort(points.begin(), points.end(), cmp);

        int result &#x3D; 1; &#x2F;&#x2F; points 不为空至少需要一支箭
        for (int i &#x3D; 1; i &lt; points.size(); i++) &#123;
            if (points[i][0] &gt; points[i - 1][1]) &#123;  &#x2F;&#x2F; 气球i和气球i-1不挨着，注意这里不是&gt;&#x3D;
                result++; &#x2F;&#x2F; 需要一支箭
            &#125;
            else &#123;  &#x2F;&#x2F; 气球i和气球i-1挨着
                points[i][1] &#x3D; min(points[i - 1][1], points[i][1]); &#x2F;&#x2F; 更新重叠气球最小右边界
            &#125;
        &#125;
        return result;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="无重叠区间"><a href="#无重叠区间" class="headerlink" title="无重叠区间"></a>无重叠区间</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230326222231126.png"></p>
<h3 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h3><p>先排序，如果左边界大于上一个的右边界就丢掉，remove++。</p>
<h3 id="Code-15"><a href="#Code-15" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
public:
    static bool cmp(vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b)&#123;
        return a[1]&lt;b[1];
    &#125;
    int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;
        if(intervals.size()&#x3D;&#x3D;0)return 0;
        sort(intervals.begin(),intervals.end(),cmp);
        int remove&#x3D;0;
        int index&#x3D;0;
        for(int i&#x3D;1;i&lt;intervals.size();i++)&#123;
            cout&lt;&lt;remove;
            if(intervals[i][0]&lt;intervals[index][1])&#123;
                remove++;
                continue;
            &#125;
            index &#x3D; i;
        &#125;
        return remove;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="划分字母区间"><a href="#划分字母区间" class="headerlink" title="划分字母区间"></a>划分字母区间</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230327095017354.png"></p>
<h3 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h3><p>可以分为如下两步：</p>
<ul>
<li>统计每一个字符最后出现的位置</li>
<li>从头遍历字符，并更新字符的最远出现下标，如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点</li>
</ul>
<p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230327095619249.png"></p>
<h3 id="Code-16"><a href="#Code-16" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
public:
    vector&lt;int&gt; partitionLabels(string S) &#123;
        int hash[27] &#x3D; &#123;0&#125;; &#x2F;&#x2F; i为字符，hash[i]为字符出现的最后位置
        for (int i &#x3D; 0; i &lt; S.size(); i++) &#123; &#x2F;&#x2F; 统计每一个字符最后出现的位置
            hash[S[i] - &#39;a&#39;] &#x3D; i;
        &#125;
        vector&lt;int&gt; result;
        int left &#x3D; 0;
        int right &#x3D; 0;
        for (int i &#x3D; 0; i &lt; S.size(); i++) &#123;
            right &#x3D; max(right, hash[S[i] - &#39;a&#39;]); &#x2F;&#x2F; 找到字符出现的最远边界
            if (i &#x3D;&#x3D; right) &#123;
                result.push_back(right - left + 1);
                left &#x3D; i + 1;
            &#125;
        &#125;
        return result;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230327095713425.png"></p>
<h3 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h3><p>左边进行排序。判断是否有重叠区间，如果有就合并区间，没有就加入到结果集里。</p>
<h3 id="Code-17"><a href="#Code-17" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;
        vector&lt;vector&lt;int&gt;&gt; result;
        if (intervals.size() &#x3D;&#x3D; 0) return result; &#x2F;&#x2F; 区间集合为空直接返回
        &#x2F;&#x2F; 排序的参数使用了lambda表达式
        sort(intervals.begin(), intervals.end(), [](const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b)&#123;return a[0] &lt; b[0];&#125;);

        &#x2F;&#x2F; 第一个区间就可以放进结果集里，后面如果重叠，在result上直接合并
        result.push_back(intervals[0]); 

        for (int i &#x3D; 1; i &lt; intervals.size(); i++) &#123;
            if (result.back()[1] &gt;&#x3D; intervals[i][0]) &#123; &#x2F;&#x2F; 发现重叠区间
                &#x2F;&#x2F; 合并区间，只更新右边界就好，因为result.back()的左边界一定是最小值，因为我们按照左边界排序的
                result.back()[1] &#x3D; max(result.back()[1], intervals[i][1]); 
            &#125; else &#123;
                result.push_back(intervals[i]); &#x2F;&#x2F; 区间不重叠 
            &#125;
        &#125;
        return result;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="单调递增的数字"><a href="#单调递增的数字" class="headerlink" title="单调递增的数字"></a>单调递增的数字</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230327101401278.png"></p>
<h3 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h3><p>例如：98，一旦出现strNum[i - 1] &gt; strNum[i]的情况（非单调递增），首先想让strNum[i - 1]–，然后strNum[i]给为9，这样这个整数就是89，即小于98的最大的单调递增整数。</p>
<p>此时是从前向后遍历还是从后向前遍历呢？</p>
<p>从前向后遍历的话，遇到strNum[i - 1] &gt; strNum[i]的情况，让strNum[i - 1]减一，但此时如果strNum[i - 1]减一了，可能又小于strNum[i - 2]。</p>
<p>这么说有点抽象，举个例子，数字：332，从前向后遍历的话，那么就把变成了329，此时2又小于了第一位的3了，真正的结果应该是299。</p>
<h3 id="Code-18"><a href="#Code-18" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
public:
    int monotoneIncreasingDigits(int N) &#123;
        string strNum &#x3D; to_string(N);
        &#x2F;&#x2F; flag用来标记赋值9从哪里开始
        &#x2F;&#x2F; 设置为这个默认值，为了防止第二个for循环在flag没有被赋值的情况下执行
        int flag &#x3D; strNum.size();
        for (int i &#x3D; strNum.size() - 1; i &gt; 0; i--) &#123;
            if (strNum[i - 1] &gt; strNum[i] ) &#123;
                flag &#x3D; i;
                strNum[i - 1]--;
            &#125;
        &#125;
        for (int i &#x3D; flag; i &lt; strNum.size(); i++) &#123;
            strNum[i] &#x3D; &#39;9&#39;;
        &#125;
        return stoi(strNum);
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="监控二叉树"><a href="#监控二叉树" class="headerlink" title="监控二叉树"></a>监控二叉树</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230327102052121.png"></p>
<h3 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h3><p>所以我们要从下往上看，局部最优：让叶子节点的父节点安摄像头，所用摄像头最少，整体最优：全部摄像头数量所用最少！</p>
<p>局部最优推出全局最优，找不出反例，那么就按照贪心来！</p>
<p>此时，大体思路就是从低到上，先给叶子节点父节点放个摄像头，然后隔两个节点放一个摄像头，直至到二叉树头结点。</p>
<p>此时这道题目还有两个难点：</p>
<ol>
<li>二叉树的遍历</li>
<li>如何隔两个节点放一个摄像头</li>
</ol>
<p><strong>如何隔两个节点放一个摄像头:</strong></p>
<p>我们分别有三个数字来表示：</p>
<ul>
<li>0：该节点无覆盖</li>
<li>1：本节点有摄像头</li>
<li>2：本节点有覆盖</li>
</ul>
<h3 id="Code-19"><a href="#Code-19" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
private:
    int result;
    int traversal(TreeNode* cur) &#123;
        if (cur &#x3D;&#x3D; NULL) return 2;
        int left &#x3D; traversal(cur-&gt;left);    &#x2F;&#x2F; 左
        int right &#x3D; traversal(cur-&gt;right);  &#x2F;&#x2F; 右
        if (left &#x3D;&#x3D; 2 &amp;&amp; right &#x3D;&#x3D; 2) return 0;
        else if (left &#x3D;&#x3D; 0 || right &#x3D;&#x3D; 0) &#123;
            result++;
            return 1;
        &#125; else return 2;
    &#125;
public:
    int minCameraCover(TreeNode* root) &#123;
        result &#x3D; 0;
        if (traversal(root) &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; root 无覆盖
            result++;
        &#125;
        return result;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


                
            </div>
            <hr/>

            



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Code/">
                                    <span class="chip bg-color">Code</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    
    <div class="livere-card card" data-aos="fade-up">
    <!-- 来必力City版安装代码 -->
    <div id="lv-container" class="card-content" data-id="city" data-uid="MTAyMC81NzkxMS8zNDM3NA==">
        <script type="text/javascript">
            (function (d, s) {
                let j, e = d.getElementsByTagName(s)[0];
                if (typeof LivereTower === 'function') {
                    return;
                }

                j = d.createElement(s);
                j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
                j.async = true;

                e.parentNode.insertBefore(j, e);
            })(document, 'script');
        </script>
        <noscript>为正常使用来必力评论功能请激活JavaScript。</noscript>
    </div>
    <!-- City版安装代码已完成 -->
</div>
    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2023/03/30/Learn/LeetCode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/19.jpg" class="responsive-img" alt="代码随想录_动态规划">
                        
                        <span class="card-title">代码随想录_动态规划</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            动态规划专项练习
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-03-30
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Learn/" class="post-category">
                                    Learn
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Code/">
                        <span class="chip bg-color">Code</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/03/25/Learn/LeetCode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/19.jpg" class="responsive-img" alt="代码随想录_回溯算法">
                        
                        <span class="card-title">代码随想录_回溯算法</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            回溯算法专项练习
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-03-25
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Learn/" class="post-category">
                                    Learn
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Code/">
                        <span class="chip bg-color">Code</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>


  <!-- 是否加载使用自带的 prismjs. -->
  <script type="text/javascript" src="/libs/prism/prism.min.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2023</span>
            
            <a href="/about" target="_blank">Gzr</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            
            <br>
            
                &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                        class="white-color">118.4k</span>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/guozunrong123" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1650224714@qq.com" class="tooltipped" target="_blank" data-tooltip="邮箱联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope"></i>
    </a>




    <a href="https://m.weibo.cn/profile/2529234370" class="tooltipped" target="_blank" data-tooltip="微博联系我" data-position="top" data-delay="50">
        <i class="fab fa-weibo"></i>
    </a>



    <a href="tencent://message/?uin=1650224714&amp;Site=&amp;Menu=yes" class="tooltipped" target="_blank" data-tooltip="QQ联系我:1650224714" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>


</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
    
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    
    <script type="text/javascript" color="0,0,255"
        pointColor="0,0,255" opacity='0.7'
        zIndex="-1" count="99"
        src="/libs/background/canvas-nest.js"></script>
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
