<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2023.04.02 LeetCode周赛</title>
      <link href="/2023/04/02/Learn/LeetCode/%E5%91%A8%E8%B5%9B2023.04.02/"/>
      <url>/2023/04/02/Learn/LeetCode/%E5%91%A8%E8%B5%9B2023.04.02/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="最长平衡子字符串"><a href="#最长平衡子字符串" class="headerlink" title="最长平衡子字符串"></a>最长平衡子字符串</h1><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230402131849596.png"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>使用双指针并用num计000111的数。虽然这样做空间复杂度能做到O(n)，但是相对的产生的判断很多。</p><p>考虑的情况太多，不易快速解决。</p><h2 id="My-Code"><a href="#My-Code" class="headerlink" title="My Code"></a>My Code</h2><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    int findTheLongestBalancedSubstring(string s) &#123;        if(s.size()&lt;&#x3D;1)&#123;return 0;&#125;        int left &#x3D; 0;        int right &#x3D; 0;        int last_right &#x3D; 0;        int res &#x3D; 0;        int num &#x3D; 0;        bool flag &#x3D; false;        for(int i&#x3D;0;i&lt;s.size();i++)&#123;            if(s[right]&#x3D;&#x3D;&#39;0&#39;)&#123;                num++;                flag&#x3D;true;            &#125;            if(s[right]&#x3D;&#x3D;&#39;1&#39;)&#123;num--;&#125;            if(num&lt;0)&#123;                left&#x3D;right;                num&#x3D;0;            &#125;            &#x2F;&#x2F;cout&lt;&lt;num;            if(num&#x3D;&#x3D;0 &amp;&amp; flag&#x3D;&#x3D;true)&#123;                res &#x3D; max(res,right-left+1);                flag &#x3D; false;                &#x2F;&#x2F;cout&lt;&lt;flag&lt;&lt;i&lt;&lt;&#39; &#39;;            &#125;            else if(i&#x3D;&#x3D;s.size()-1 &amp;&amp; flag&#x3D;&#x3D;true &amp;&amp; num&gt;0 &amp;&amp; s[i]&#x3D;&#x3D;&#39;1&#39;)&#123;                res &#x3D; max(res,right-left+1-num);                &#x2F;&#x2F;cout&lt;&lt;&#39; &#39;&lt;&lt;num;                &#x2F;&#x2F;cout&lt;&lt;right&lt;&lt;&#39; &#39;&lt;&lt;left;                flag &#x3D; false;            &#125;            if(s[right]&#x3D;&#x3D;&#39;0&#39; &amp;&amp; s[last_right]&#x3D;&#x3D;&#39;1&#39;)&#123;                res &#x3D; max(res,right-left+1-num);                left &#x3D; right;                num &#x3D; 1;            &#125;            cout&lt;&lt;left&lt;&lt;&#39; &#39;&lt;&lt;right&lt;&lt;&#39; &#39;;            last_right &#x3D; right;            right++;        &#125;        if(res%2!&#x3D;0)res&#x3D;0;        return res;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><p>考虑的方法不是很好，导致一直在debug，解决时间花了很久，并且好几次提交错误。</p><p>先想解决问题再去减少复杂度。</p><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><p>找到1然后再去找1前面的0！逆天。我太菜了。</p><p>举例0011，先找到1后看1前面的0，cur&#x3D;2；继续找1，发现011再去找0前面是不是0，如果是就0011，cur&#x3D;4，记录cur最大值。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    int findTheLongestBalancedSubstring(string s) &#123;        int n &#x3D; s.size(), ret &#x3D; 0, cur &#x3D; 0;        for(int i &#x3D; 0; i &lt; n; ++i)&#123;            if(s[i] &#x3D;&#x3D; &#39;1&#39; &amp;&amp; i - cur - 1 &gt;&#x3D; 0 &amp;&amp; s[i - cur - 1] &#x3D;&#x3D; &#39;0&#39;)                cur +&#x3D; 2;            else                cur &#x3D; 0;            ret &#x3D; max(ret, cur);        &#125;        return ret;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="转换二位数组"><a href="#转换二位数组" class="headerlink" title="转换二位数组"></a>转换二位数组</h1><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230402132915592.png"></p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>考虑了递归，从重复的地方开始往后遍历，记录在map里，并通过find查找map里有没有重复。</p><p>使用过的数置为0，便于下次遍历。</p><h2 id="My-Code-1"><a href="#My-Code-1" class="headerlink" title="My Code"></a>My Code</h2><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    vector&lt;int&gt; path;    vector&lt;vector&lt;int&gt;&gt; result;    map&lt;int,int&gt; mp;    int count &#x3D; 0;    bool flag &#x3D; 0;    int start &#x3D; 0;    void backtracing(vector&lt;int&gt;&amp; nums, int startIndex)&#123;        if(count&#x3D;&#x3D;nums.size())&#123;return;&#125;        for(int i&#x3D;startIndex;i&lt;nums.size();i++)&#123;            cout&lt;&lt;i&lt;&lt;&#39; &#39;;            if(mp.find(nums[i])&#x3D;&#x3D;mp.end() &amp;&amp; nums[i]!&#x3D;0)&#123;                mp[nums[i]]++;                count++;                path.push_back(nums[i]);                nums[i]&#x3D;0;            &#125;            else if(flag &#x3D;&#x3D; 0 &amp;&amp; mp.find(nums[i])!&#x3D;mp.end())&#123;                start &#x3D; i;                flag &#x3D; 1;                &#x2F;&#x2F;cout&lt;&lt;i;            &#125;            if(i&#x3D;&#x3D;nums.size()-1)&#123;                result.push_back(path);                path.clear();                mp.clear();                flag &#x3D; 0;                backtracing(nums, start);                return;            &#125;        &#125;        return;    &#125;    vector&lt;vector&lt;int&gt;&gt; findMatrix(vector&lt;int&gt;&amp; nums) &#123;        if(nums.size()&#x3D;&#x3D;0)&#123;return result;&#125;        backtracing(nums,0);        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="不足-1"><a href="#不足-1" class="headerlink" title="不足"></a>不足</h2><p>应该把全部先放进map，再在map中减，这样会方便很多。遍历map，如果value还有值就留在map，如果没有值了就从map中删除，删除用erase。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; findMatrix(vector&lt;int&gt;&amp; nums) &#123;        map&lt;int, int&gt; mp;        for (int x : nums) &#123;            mp[x] +&#x3D; 1;        &#125;        vector&lt;vector&lt;int&gt;&gt; ans;        while (not mp.empty()) &#123;            vector&lt;int&gt; res;            for (auto it &#x3D; mp.begin(); it !&#x3D; mp.end(); ) &#123;                res.push_back(it-&gt;first);                if (it-&gt;second -&#x3D; 1) &#123;                    it &#x3D; next(it);                &#125; else &#123;                    it &#x3D; mp.erase(it);                &#125;            &#125;            ans.push_back(res);        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="学习-1"><a href="#学习-1" class="headerlink" title="学习"></a>学习</h2><p>Code如上所示。</p><p>采用map遍历，在这题优势很明显！！全部key全直接出来！！</p><h1 id="老鼠和奶酪"><a href="#老鼠和奶酪" class="headerlink" title="老鼠和奶酪"></a>老鼠和奶酪</h1><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230402132933857.png"></p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>这题最重要的是思路，先对(r1-r2)进行排序，取最大的k个r1[0-k]，剩下的都拿r2[k-size]。那么如何计算最大得分？</p><p>我们在排序的过程中已经计算出来前k个的r1-r2[0-k]，那么我们这时候再加上全部r2[0-size]，就是问题的解了。</p><p>可以看到加起来是r1[0-k]+r2[k-size]。</p><h2 id="My-Code-2"><a href="#My-Code-2" class="headerlink" title="My Code"></a>My Code</h2><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    int miceAndCheese(vector&lt;int&gt;&amp; reward1, vector&lt;int&gt;&amp; reward2, int k) &#123;        int ans &#x3D; 0;        int n &#x3D; reward1.size();        vector&lt;int&gt; v;        for (int i &#x3D; 0; i &lt; n; i +&#x3D; 1) &#123;            ans +&#x3D; reward2[i];            v.push_back(reward1[i] - reward2[i]);        &#125;        sort(v.begin(), v.end(), greater&lt;int&gt;());        for (int i &#x3D; 0; i &lt; k; i +&#x3D; 1) &#123;            ans +&#x3D; v[i];        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="不足-2"><a href="#不足-2" class="headerlink" title="不足"></a>不足</h2><p>第一次参加周赛，前两题花费的时间太长了，这题在比赛中没有做出来。在赛后参考了别人的题解，做了以上的Code。</p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode周赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux文件与目录管理</title>
      <link href="/2023/04/01/Learn/Linux/Linux%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"/>
      <url>/2023/04/01/Learn/Linux/Linux%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="Linux-文件与目录管理"><a href="#Linux-文件与目录管理" class="headerlink" title="Linux 文件与目录管理"></a>Linux 文件与目录管理</h1><p>在前一章我们认识了Linux系统下的文件权限概念以及目录的配置说明。 在这个章节当中，我们就直接来进一步的操作与管理文件及目录吧！包括在不同的目录间变换、 创建与删除目录、创建与删除文件，还有寻找文件、查阅文件内容等等。</p><h2 id="目录与路径"><a href="#目录与路径" class="headerlink" title="目录与路径"></a>目录与路径</h2><h3 id="相对路径与绝对路径"><a href="#相对路径与绝对路径" class="headerlink" title="相对路径与绝对路径"></a>相对路径与绝对路径</h3><ul><li>绝对路径：路径的写法“一定由根目录 &#x2F; 写起”，例如： &#x2F;usr&#x2F;share&#x2F;doc 这个目录。 </li><li>相对路径：路径的写法“不是由 &#x2F; 写起”，例如由 &#x2F;usr&#x2F;share&#x2F;doc 要到 &#x2F;usr&#x2F;share&#x2F;man 下面 时，可以写成： “cd ..&#x2F;man”这就是相对路径的写法啦！相对路径意指“相对于目前工作目录的路径！”</li></ul><h3 id="目录的相关操作"><a href="#目录的相关操作" class="headerlink" title="目录的相关操作"></a>目录的相关操作</h3><p>变换目录的指令是cd</p><pre class="line-numbers language-none"><code class="language-none">. 代表此层目录.. 代表上一层目录- 代表前一个工作目录~ 代表“目前使用者身份”所在的主文件夹~account 代表 account 这个使用者的主文件夹（account是个帐号名称）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例题：请问在Linux下面，根目录下有没有上层目录（..）存在？答：若使用“ ls -al &#x2F; ”去查询， 可以看到根目录下确实存在 . 与 .. 两个目录，再仔细的查阅， 可发现这两个目录的属性与权 限完全一致，这代表根目录的上一层（..）与根目录自己（.）是同一个目录。</p><p>几个常见的处理目录的指令：</p><ul><li>cd：变换目录&#x2F;&#x2F;Change Directory</li><li>pwd：显示目前的目录         &#x2F;&#x2F;Print Working Directory</li><li>mkdir：创建一个新的目录  &#x2F;&#x2F;Make Directory</li><li>rmdir：删除一个空的目录  &#x2F;&#x2F;Remove Directory<ul><li>目录需要一层一层的删除才行！而且被删除的目录里面必定不能存在其他 的目录或文件！ 这也是所谓的空的目录（empty directory）的意思啊！那如果要将所有目录 下的东西都杀掉呢？！ 这个时候就必须使用“ rm -r test ”！不过，还是使用 rmdir 比较不危险！你也可以尝试以 -p 的选项加入，来删除上层的目录喔！</li></ul></li></ul><pre class="line-numbers language-none"><code class="language-none">[dmtsai@study ~]$ su - # 先切换身份成为 root 看看！[root@study ~]# cd [相对路径或绝对路径]# 最重要的就是目录的绝对路径与相对路径，还有一些特殊目录的符号啰！[root@study ~]# cd ~dmtsai# 代表去到 dmtsai 这个使用者的主文件夹，亦即 &#x2F;home&#x2F;dmtsai[root@study dmtsai]# cd ~# 表示回到自己的主文件夹，亦即是 &#x2F;root 这个目录[root@study ~]# cd# 没有加上任何路径，也还是代表回到自己主文件夹的意思喔！[root@study ~]# cd ..# 表示去到目前的上层目录，亦即是 &#x2F;root 的上层目录的意思；[root@study &#x2F;]# cd -# 表示回到刚刚的那个目录，也就是 &#x2F;root 啰～[root@study ~]# cd &#x2F;var&#x2F;spool&#x2F;mail# 这个就是绝对路径的写法！直接指定要去的完整路径名称！[root@study mail]# cd ..&#x2F;postfix# 这个是相对路径的写法，我们由&#x2F;var&#x2F;spool&#x2F;mail 去到&#x2F;var&#x2F;spool&#x2F;postfix 就这样写！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="关于可执行文件路径的变量：-PATH"><a href="#关于可执行文件路径的变量：-PATH" class="headerlink" title="关于可执行文件路径的变量： $PATH"></a>关于可执行文件路径的变量： $PATH</h3><p>我们知道查阅文件属性的指令ls完整文件名为：&#x2F;bin&#x2F;ls（这是绝对 路径）， 那你会不会觉得很奇怪：“为什么我可以在任何地方执行&#x2F;bin&#x2F;ls这个指令呢？ ” 为什 么我在任何目录下输入 ls 就一定可以显示出一些讯息而不会说找不到该 &#x2F;bin&#x2F;ls 指令呢？ 这是因为环境变量 PATH 的帮助所致呀！</p><p>如果将ls移动到root，想要让root在任何目录均可执行&#x2F;root下面的ls，那么就将&#x2F;root加入PATH当中即可。</p><pre class="line-numbers language-none"><code class="language-none">[root@study ~]# PATH&#x3D;&quot;$&#123;PATH&#125;:&#x2F;root&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="文件与目录管理"><a href="#文件与目录管理" class="headerlink" title="文件与目录管理"></a>文件与目录管理</h2><h3 id="文件与目录的检视：-ls"><a href="#文件与目录的检视：-ls" class="headerlink" title="文件与目录的检视： ls"></a>文件与目录的检视： ls</h3><pre class="line-numbers language-none"><code class="language-none">[root@study ~]# ls [-aAdfFhilnrRSt] 文件名或目录名称..[root@study ~]# ls [--color&#x3D;&#123;never,auto,always&#125;] 文件名或目录名称..[root@study ~]# ls [--full-time] 文件名或目录名称..选项与参数：-a ：全部的文件，连同隐藏文件（ 开头为 . 的文件） 一起列出来（常用）-A ：全部的文件，连同隐藏文件，但不包括 . 与 .. 这两个目录-d ：仅列出目录本身，而不是列出目录内的文件数据（常用）-f ：直接列出结果，而不进行排序 （ls 默认会以文件名排序！）-F ：根据文件、目录等信息，给予附加数据结构，例如：*:代表可可执行文件； &#x2F;:代表目录； &#x3D;:代表 socket 文件； &amp;#124;:代表 FIFO 文件；-h ：将文件大小以人类较易读的方式（例如 GB, KB 等等）列出来；-i ：列出 inode 号码，inode 的意义下一章将会介绍；-l ：长数据串行出，包含文件的属性与权限等等数据；（常用）-n ：列出 UID 与 GID 而非使用者与群组的名称 （UID与GID会在帐号管理提到！）-r ：将排序结果反向输出，例如：原本文件名由小到大，反向则为由大到小；-R ：连同子目录内容一起列出来，等于该目录下的所有文件都会显示出来；-S ：以文件大小大小排序，而不是用文件名排序；-t ：依时间排序，而不是用文件名。--color&#x3D;never ：不要依据文件特性给予颜色显示；--color&#x3D;always ：显示颜色--color&#x3D;auto ：让系统自行依据设置来判断是否给予颜色--full-time ：以完整时间模式 （包含年、月、日、时、分） 输出--time&#x3D;&#123;atime,ctime&#125; ：输出 access 时间或改变权限属性时间 （ctime）   而非内容变更时间 （modification time）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="复制、删除与移动：-cp-rm-mv"><a href="#复制、删除与移动：-cp-rm-mv" class="headerlink" title="复制、删除与移动： cp, rm, mv"></a>复制、删除与移动： cp, rm, mv</h3><ul><li>cp</li></ul><pre class="line-numbers language-none"><code class="language-none">[root@study ~]# cp [-adfilprsu] 来源文件（source） 目标文件（destination）[root@study ~]# cp [options] source1 source2 source3 .... directory选项与参数：-a ：相当于 -dr --preserve&#x3D;all 的意思，至于 dr 请参考下列说明；（常用）-d ：若来源文件为链接文件的属性（link file），则复制链接文件属性而非文件本身；-f ：为强制（force）的意思，若目标文件已经存在且无法打开，则移除后再尝试一次；-i ：若目标文件（destination）已经存在时，在覆盖时会先询问动作的进行（常用）-l ：进行硬式链接（hard link）的链接文件创建，而非复制文件本身；-p ：连同文件的属性（权限、用户、时间）一起复制过去，而非使用默认属性（备份常用）；-r ：递回持续复制，用于目录的复制行为；（常用）-s ：复制成为符号链接文件 （symbolic link），亦即“捷径”文件；-u ：destination 比 source 旧才更新 destination，或 destination 不存在的情况下才复制。--preserve&#x3D;all ：除了 -p 的权限相关参数外，还加入 SELinux 的属性, links, xattr 等也复制了。最后需要注意的，如果来源文件有两个以上，则最后一个目的文件一定要是“目录”才行！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>rm</li></ul><pre class="line-numbers language-none"><code class="language-none">[root@study ~]# rm [-fir] 文件或目录选项与参数：-f ：就是 force 的意思，忽略不存在的文件，不会出现警告讯息；-i ：互动模式，在删除前会询问使用者是否动作-r ：递回删除啊！最常用在目录的删除了！这是非常危险的选项！！！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>mv</li></ul><pre class="line-numbers language-none"><code class="language-none">[root@study ~]# mv [-fiu] source destination[root@study ~]# mv [options] source1 source2 source3 .... directory选项与参数：-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；-i ：若目标文件 （destination） 已经存在时，就会询问是否覆盖！-u ：若目标文件已经存在，且 source 比较新，才会更新 （update）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="文件内容查阅"><a href="#文件内容查阅" class="headerlink" title="文件内容查阅"></a>文件内容查阅</h2><pre class="line-numbers language-none"><code class="language-none">cat 由第一行开始显示文件内容tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！nl 显示的时候，顺道输出行号！more 一页一页的显示文件内容less 与 more 类似，但是比 more 更好的是，他可以往前翻页！head 只看头几行tail 只看尾巴几行od 以二进制的方式读取文件内容！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="直接检视文件内容"><a href="#直接检视文件内容" class="headerlink" title="直接检视文件内容"></a>直接检视文件内容</h3><ul><li>cat （concatenate）</li></ul><pre class="line-numbers language-none"><code class="language-none">[root@study ~]# cat [-AbEnTv]选项与参数：-A ：相当于 -vET 的整合选项，可列出一些特殊字符而不是空白而已；-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！-E ：将结尾的断行字符 $ 显示出来；-n ：打印出行号，连同空白行也会有行号，与 -b 的选项不同；-T ：将 [tab] 按键以 ^I 显示出来；-v ：列出一些看不出来的特殊字符<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可翻页检视"><a href="#可翻页检视" class="headerlink" title="可翻页检视"></a>可翻页检视</h3><ul><li><p>more（一页一页翻动）</p></li><li><p>less （一页一页翻动）</p></li></ul><h3 id="数据撷取"><a href="#数据撷取" class="headerlink" title="数据撷取"></a>数据撷取</h3><p>我们可以将输出的数据作一个最简单的撷取，那就是取出文件前面几行 （head） 或取出后面 几行 （tail） 文字的功能。 不过，要注意的是， head 与 tail 都是以“行”为单位来进行数据撷取的喔！</p><ul><li>head （取出前面几行）</li></ul><pre class="line-numbers language-none"><code class="language-none">[root@study ~]# head [-n number] 文件选项与参数：-n ：后面接数字，代表显示几行的意思[root@study ~]# head &#x2F;etc&#x2F;man_db.conf# 默认的情况中，显示前面十行！若要显示前 20 行，就得要这样：[root@study ~]# head -n 20 &#x2F;etc&#x2F;man_db.conf范例：如果后面100行的数据都不打印，只打印&#x2F;etc&#x2F;man_db.conf的前面几行，该如何是好？[root@study ~]# head -n -100 &#x2F;etc&#x2F;man_db.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="修改文件时间或创建新文件：-touch"><a href="#修改文件时间或创建新文件：-touch" class="headerlink" title="修改文件时间或创建新文件： touch"></a>修改文件时间或创建新文件： touch</h3><pre class="line-numbers language-none"><code class="language-none">[root@study ~]# touch [-acdmt] 文件选项与参数：-a ：仅修订 access time；-c ：仅修改文件的时间，若该文件不存在则不创建新文件；-d ：后面可以接欲修订的日期而不用目前的日期，也可以使用 --date&#x3D;&quot;日期或时间&quot;-m ：仅修改 mtime ；-t ：后面可以接欲修订的时间而不用目前的时间，格式为[YYYYMMDDhhmm]范例一：新建一个空的文件并观察时间[dmtsai@study ~]# cd &#x2F;tmp[dmtsai@study tmp]# touch testtouch[dmtsai@study tmp]# ls -l testtouch-rw-rw-r--. 1 dmtsai dmtsai 0 Jun 16 00:45 testtouch# 注意到，这个文件的大小是 0 呢！在默认的状态下，如果 touch 后面有接文件，# 则该文件的三个时间 （atime&#x2F;ctime&#x2F;mtime） 都会更新为目前的时间。若该文件不存在，# 则会主动的创建一个新的空的文件喔！例如上面这个例子！范例二：将 ~&#x2F;.bashrc 复制成为 bashrc，假设复制完全的属性，检查其日期[dmtsai@study tmp]# cp -a ~&#x2F;.bashrc bashrc[dmtsai@study tmp]# date; ll bashrc; ll --time&#x3D;atime bashrc; ll --time&#x3D;ctime bashrcTue Jun 16 00:49:24 CST 2015 &lt;&#x3D;&#x3D;这是目前的时间-rw-r--r--. 1 dmtsai dmtsai 231 Mar 6 06:06 bashrc &lt;&#x3D;&#x3D;这是 mtime-rw-r--r--. 1 dmtsai dmtsai 231 Jun 15 23:44 bashrc &lt;&#x3D;&#x3D;这是 atime-rw-r--r--. 1 dmtsai dmtsai 231 Jun 16 00:47 bashrc &lt;&#x3D;&#x3D;这是 ctime<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="文件与目录的默认权限与隐藏权限"><a href="#文件与目录的默认权限与隐藏权限" class="headerlink" title="文件与目录的默认权限与隐藏权限"></a>文件与目录的默认权限与隐藏权限</h2><h3 id="文件默认权限：umask"><a href="#文件默认权限：umask" class="headerlink" title="文件默认权限：umask"></a>文件默认权限：umask</h3><p>umask 就是指定 “目前使用者在创建文件或目录时候的权限默认值”</p><pre class="line-numbers language-none"><code class="language-none">[root@study ~]# umask0022 &lt;&#x3D;&#x3D;与一般权限有关的是后面三个数字！[root@study ~]# umask -Su&#x3D;rwx,g&#x3D;rx,o&#x3D;rx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="文件隐藏属性"><a href="#文件隐藏属性" class="headerlink" title="文件隐藏属性"></a>文件隐藏属性</h3><ul><li>chattr （设置文件隐藏属性）</li></ul><pre class="line-numbers language-none"><code class="language-none">[root@study ~]# chattr [+-&#x3D;][ASacdistu] 文件或目录名称选项与参数：+ ：增加某一个特殊参数，其他原本存在参数则不动。- ：移除某一个特殊参数，其他原本存在参数则不动。&#x3D; ：设置一定，且仅有后面接的参数A ：当设置了 A 这个属性时，若你有存取此文件（或目录）时，他的存取时间 atime 将不会被修改，可避免 I&#x2F;O 较慢的机器过度的存取磁盘。（目前建议使用文件系统挂载参数处理这个项目）S ：一般文件是非同步写入磁盘的（原理请参考[前一章sync](..&#x2F;Text&#x2F;index.html#sync)的说明），如果加上 S 这个属性时，当你进行任何文件的修改，该更动会“同步”写入磁盘中。a ：当设置 a 之后，这个文件将只能增加数据，而不能删除也不能修改数据，只有root 才能设置这属性c ：这个属性设置之后，将会自动的将此文件“压缩”，在读取的时候将会自动解压缩，但是在储存的时候，将会先进行压缩后再储存（看来对于大文件似乎蛮有用的！）d ：当 dump 程序被执行的时候，设置 d 属性将可使该文件（或目录）不会被 dump 备份i ：这个 i 可就很厉害了！他可以让一个文件“不能被删除、改名、设置链接也无法写入或新增数据！”对于系统安全性有相当大的助益！只有 root 能设置此属性s ：当文件设置了 s 属性时，如果这个文件被删除，他将会被完全的移除出这个硬盘空间，所以如果误删了，完全无法救回来了喔！u ：与 s 相反的，当使用 u 来设置文件时，如果该文件被删除了，则数据内容其实还存在磁盘中，可以使用来救援该文件喔！注意1：属性设置常见的是 a 与 i 的设置值，而且很多设置值必须要身为 root 才能设置注意2：xfs 文件系统仅支持 AadiS 而已<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个指令是很重要的，尤其是在系统的数据安全上面！</p><ul><li>lsattr （显示文件隐藏属性）</li></ul><pre class="line-numbers language-none"><code class="language-none">[root@study ~]# lsattr [-adR] 文件或目录选项与参数：-a ：将隐藏文件的属性也秀出来；-d ：如果接的是目录，仅列出目录本身的属性而非目录内的文件名；-R ：连同子目录的数据也一并列出来！[root@study tmp]# chattr +aiS attrtest[root@study tmp]# lsattr attrtest--S-ia---------- attrtest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用 chattr 设置后，可以利用 lsattr 来查阅隐藏的属性。不过， 这两个指令在使用上必须要 特别小心，否则会造成很大的困扰。</p><h3 id="文件特殊权限：SUID-SGID-SBIT"><a href="#文件特殊权限：SUID-SGID-SBIT" class="headerlink" title="文件特殊权限：SUID, SGID, SBIT"></a>文件特殊权限：SUID, SGID, SBIT</h3><h4 id="Set-UID"><a href="#Set-UID" class="headerlink" title="Set UID"></a>Set UID</h4><ul><li>SUID 权限仅对二进制程序（binary program）有效； </li><li>执行者对于该程序需要具有 x 的可执行权限； </li><li>本权限仅在执行该程序的过程中有效 （run-time）； </li><li>执行者将具有该程序拥有者 （owner） 的权限。</li></ul><p>我们的 Linux 系统中，所有帐号的密码都记录在 &#x2F;etc&#x2F;shadow 这个文件里面，这个文件的权限为：“———- 1 root root”，意思是这个文件仅有root可读且仅有root可以强制写入而已。 既然这个文件仅有 root 可以修改，那么鸟哥的 dmtsai 这个一般帐号使用者能否自行修改自己的密码呢？ 你可以使用你自己的帐号输入“passwd”这个指令来看看，嘿嘿！一般使用者当然可以修改自己的密码了！ 唔！有没有冲突啊！明明 &#x2F;etc&#x2F;shadow 就不能让 dmtsai 这个一般帐户去存取的，为什么 dmtsai 还能够修改这个文件内的密码呢？ 这就是 SUID 的功能啦！</p><p>但如果 dmtsai 使用 cat 去读取 &#x2F;etc&#x2F;shadow 时，他能够读取吗？因为 cat 不具有 SUID 的权 限，所以 dmtsai 执行 “cat &#x2F;etc&#x2F;shadow” 时，是不能读取 &#x2F;etc&#x2F;shadow 的。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230401213159402.png" alt="SUID程序执行"></p><h4 id="Set-GID"><a href="#Set-GID" class="headerlink" title="Set GID"></a>Set GID</h4><p>与 SUID 不同的是，SGID 可以针对文件或目录来设置！如果是对文件来说， SGID 有如下的功能：</p><ul><li>SGID 对二进制程序有用；</li><li>程序执行者对于该程序来说，需具备 x 的权限； </li><li>执行者在执行的过程中将会获得该程序群组的支持！</li></ul><h4 id="Sticky-Bit"><a href="#Sticky-Bit" class="headerlink" title="Sticky Bit"></a>Sticky Bit</h4><p>这个 Sticky Bit, SBIT 目前只针对目录有效，对于文件已经没有效果了。SBIT 对于目录的作用是：</p><ul><li>当使用者对于此目录具有 w, x 权限，亦即具有写入的权限时； </li><li>当使用者在该目录下创建文件或目录时，仅有自己与 root 才有权力删除该文件</li></ul><h3 id="观察文件类型：file"><a href="#观察文件类型：file" class="headerlink" title="观察文件类型：file"></a>观察文件类型：file</h3><p>如果你想要知道某个文件的基本数据，例如是属于 ASCII 或者是 data 文件，或者是 binary ， 且其中有没有使用到动态函数库 （share library） 等等的信息，就可以利用 file 这个指令来检阅。</p><pre class="line-numbers language-none"><code class="language-none">[root@study ~]# file ~&#x2F;.bashrc&#x2F;root&#x2F;.bashrc: ASCII text &lt;&#x3D;&#x3D;告诉我们是 ASCII 的纯文本文件啊！[root@study ~]# file &#x2F;usr&#x2F;bin&#x2F;passwd&#x2F;usr&#x2F;bin&#x2F;passwd: setuid ELF 64-bit LSB shared object, x86-64, version 1 （SYSV）, dynamicallylinked （uses shared libs）, for GNU&#x2F;Linux 2.6.32,BuildID[sha1]&#x3D;0xbf35571e607e317bf107b9bcf65199988d0ed5ab, stripped# 可执行文件的数据可就多的不得了！包括这个文件的 suid 权限、相容于 Intel x86-64 等级的硬件平台# 使用的是 Linux 核心 2.6.32 的动态函数库链接等等。[root@study ~]# file &#x2F;var&#x2F;lib&#x2F;mlocate&#x2F;mlocate.db&#x2F;var&#x2F;lib&#x2F;mlocate&#x2F;mlocate.db: data &lt;&#x3D;&#x3D; 这是 data 文件！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="指令与文件的搜寻"><a href="#指令与文件的搜寻" class="headerlink" title="指令与文件的搜寻"></a>指令与文件的搜寻</h2><h3 id="指令文件名的搜寻"><a href="#指令文件名的搜寻" class="headerlink" title="指令文件名的搜寻"></a>指令文件名的搜寻</h3><ul><li>which （寻找“可执行文件”）</li></ul><pre class="line-numbers language-none"><code class="language-none">[root@study ~]# which [-a] command选项或参数：-a ：将所有由 PATH 目录中可以找到的指令均列出，而不止第一个被找到的指令名称范例一：搜寻 ifconfig 这个指令的完整文件名[root@study ~]# which ifconfig&#x2F;sbin&#x2F;ifconfig范例二：用 which 去找出 which 的文件名为何？[root@study ~]# which whichalias which&#x3D;&#39;alias &amp;#124; &#x2F;usr&#x2F;bin&#x2F;which --tty-only --read-alias --show-dot --show-tilde&#39;&#x2F;bin&#x2F;alias&#x2F;usr&#x2F;bin&#x2F;which# 竟然会有两个 which ，其中一个是 alias 这玩意儿呢！那是啥？# 那就是所谓的“命令别名”，意思是输入 which 会等于后面接的那串指令啦！# 更多的数据我们会在 bash 章节中再来谈的！范例三：请找出 history 这个指令的完整文件名[root@study ~]# which history&#x2F;usr&#x2F;bin&#x2F;which: no history in （&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;sbin:&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;root&#x2F;bin）[root@study ~]# history --help-bash: history: --: invalid optionhistory: usage: history [-c] [-d offset] [n] or history -anrw [filename] or history -ps arg# 瞎密？怎么可能没有 history ，我明明就能够用 root 执行 history 的啊！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="文件文件名的搜寻"><a href="#文件文件名的搜寻" class="headerlink" title="文件文件名的搜寻"></a>文件文件名的搜寻</h3><h4 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h4><p>（由一些特定的目录中寻找文件文件名）</p><pre class="line-numbers language-none"><code class="language-none">[root@study ~]# whereis [-bmsu] 文件或目录名选项与参数：-l :可以列出 whereis 会去查询的几个主要目录而已-b :只找 binary 格式的文件-m :只找在说明文档 manual 路径下的文件-s :只找 source 来源文件-u :搜寻不在上述三个项目当中的其他特殊文件范例一：请找出 ifconfig 这个文件名[root@study ~]# whereis ifconfigifconfig: &#x2F;sbin&#x2F;ifconfig &#x2F;usr&#x2F;share&#x2F;man&#x2F;man8&#x2F;ifconfig.8.gz范例二：只找出跟 passwd 有关的“说明文档”文件名（man page）[root@study ~]# whereis passwd # 全部的文件名通通列出来！passwd: &#x2F;usr&#x2F;bin&#x2F;passwd &#x2F;etc&#x2F;passwd &#x2F;usr&#x2F;share&#x2F;man&#x2F;man1&#x2F;passwd.1.gz &#x2F;usr&#x2F;share&#x2F;man&#x2F;man5&#x2F;passwd.5.gz[root@study ~]# whereis -m passwd # 只有在 man 里面的文件名才抓出来！passwd: &#x2F;usr&#x2F;share&#x2F;man&#x2F;man1&#x2F;passwd.1.gz &#x2F;usr&#x2F;share&#x2F;man&#x2F;man5&#x2F;passwd.5.g<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>whereis 主要是针对 &#x2F;bin &#x2F;sbin 下面的可执行文件， 以及 &#x2F;usr&#x2F;share&#x2F;man 下面的 man page 文 件，跟几个比较特定的目录来处理而已。</p><h4 id="locate-x2F-updatedb"><a href="#locate-x2F-updatedb" class="headerlink" title="locate &#x2F; updatedb"></a>locate &#x2F; updatedb</h4><pre class="line-numbers language-none"><code class="language-none">[root@study ~]# locate [-ir] keyword选项与参数：-i ：忽略大小写的差异；-c ：不输出文件名，仅计算找到的文件数量-l ：仅输出几行的意思，例如输出五行则是 -l 5-S ：输出 locate 所使用的数据库文件的相关信息，包括该数据库纪录的文件&#x2F;目录数量等-r ：后面可接正则表达式的显示方式范例一：找出系统中所有与 passwd 相关的文件名，且只列出 5 个[root@study ~]# locate -l 5 passwd&#x2F;etc&#x2F;passwd&#x2F;etc&#x2F;passwd-&#x2F;etc&#x2F;pam.d&#x2F;passwd&#x2F;etc&#x2F;security&#x2F;opasswd&#x2F;usr&#x2F;bin&#x2F;gpasswd范例二：列出 locate 查询所使用的数据库文件之文件名与各数据数量[root@study ~]# locate -SDatabase &#x2F;var&#x2F;lib&#x2F;mlocate&#x2F;mlocate.db:    8,086 directories # 总纪录目录数    109,605 files # 总纪录文件数    5,190,295 Bytes in file names    2,349,150 Bytes used to store database<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个 locate 的使用更简单，直接在后面输入“文件的部分名称”后，就能够得到结果。 举上面 的例子来说，我输入 locate passwd ，那么在完整文件名 （包含路径名称） 当中，只要有 passwd 在其中， 就会被显示出来的！这也是个很方便好用的指令，如果你忘记某个文件的完整文件名时。</p><p> locate 寻找的数据是由“已创建的数据库 &#x2F;var&#x2F;lib&#x2F;mlocate&#x2F;” 里面的数据所搜寻到的，刚创建的没录入，要手动更新。更新 locate 数据库的方法非常简单，直接输入“ updatedb ”就可以了。</p><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><pre class="line-numbers language-none"><code class="language-none">[root@study ~]# find [PATH] [option] [action]选项与参数：1\. 与时间有关的选项：共有 -atime, -ctime 与 -mtime ，以 -mtime 说明-mtime n ：n 为数字，意义为在 n 天之前的“一天之内”被更动过内容的文件；-mtime +n ：列出在 n 天之前（不含 n 天本身）被更动过内容的文件文件名；-mtime -n ：列出在 n 天之内（含 n 天本身）被更动过内容的文件文件名。-newer file ：file 为一个存在的文件，列出比 file 还要新的文件文件名范例一：将过去系统上面 24 小时内有更动过内容 （mtime） 的文件列出[root@study ~]# find &#x2F; -mtime 0# 那个 0 是重点！0 代表目前的时间，所以，从现在开始到 24 小时前，# 有变动过内容的文件都会被列出来！那如果是三天前的 24 小时内？# find &#x2F; -mtime 3 有变动过的文件都被列出的意思！范例二：寻找 &#x2F;etc 下面的文件，如果文件日期比 &#x2F;etc&#x2F;passwd 新就列出[root@study ~]# find &#x2F;etc -newer &#x2F;etc&#x2F;passwd# -newer 用在分辨两个文件之间的新旧关系是很有用的！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux文件权限与目录配置</title>
      <link href="/2023/04/01/Learn/Linux/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B8%8E%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE/"/>
      <url>/2023/04/01/Learn/Linux/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B8%8E%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="Linux文件权限与目录配置"><a href="#Linux文件权限与目录配置" class="headerlink" title="Linux文件权限与目录配置"></a>Linux文件权限与目录配置</h1><p>Linux最优秀的地方之一就在于他的多用户多任务环境。而为了让各个使用者具有较保密的文件数据，因此文件的权限管理就变的很重要了。Linux一般将文件可存取的身份分为三个类别，分别是 owner&#x2F;group&#x2F;others，且三种身份各有 read&#x2F;write&#x2F;execute 等权限。</p><h2 id="使用者与群组"><a href="#使用者与群组" class="headerlink" title="使用者与群组"></a>使用者与群组</h2><h3 id="文件拥有者"><a href="#文件拥有者" class="headerlink" title="文件拥有者"></a>文件拥有者</h3><p>为了考虑每个人的隐私权以及每个人喜好的工作环境，因此，这 个“文件拥有者”的角色就显的相当的重要了！</p><p>可以把该文件设置成“只有文件拥有者，就是我，才能看与修改这个文件的内容”。由于你有设置适当的权限， 所以其他人自然也就无法知道该文件的内容。</p><h3 id="群组"><a href="#群组" class="headerlink" title="群组"></a>群组</h3><p>群组最有用的功能之一，就是当你在团队开发资源的时候。</p><p>我可以经由简易的文件权限设置，就能限制非自己团队（亦即是群组） 的其他人不能够阅览内容。</p><h3 id="其他人"><a href="#其他人" class="headerlink" title="其他人"></a>其他人</h3><p>外人。</p><h3 id="Linux-使用者身份与群组记录的文件"><a href="#Linux-使用者身份与群组记录的文件" class="headerlink" title="Linux 使用者身份与群组记录的文件"></a>Linux 使用者身份与群组记录的文件</h3><p>在Linux系统当中，默认的情况下，所有的系统上的帐号与一般身份使用者，还有root的相关信息， 都是记录在**&#x2F;etc&#x2F;passwd<strong>这个文件内的。至于个人的密码则是记录 在</strong>&#x2F;etc&#x2F;shadow<strong>这个文件下。 此外，Linux所有的群组名称都记录在</strong>&#x2F;etc&#x2F;group**内！这三个文件可以说是Linux系统里面帐号、密码、群组信息的集中地！</p><h2 id="Linux文件权限概念"><a href="#Linux文件权限概念" class="headerlink" title="Linux文件权限概念"></a>Linux文件权限概念</h2><p>当出现了“Permission deny”的时 候，不要担心，肯定是权限设置错误！</p><h3 id="Linux文件属性"><a href="#Linux文件属性" class="headerlink" title="Linux文件属性"></a>Linux文件属性</h3><pre class="line-numbers language-none"><code class="language-none">[dmtsai@study ~]$ su - # 先来切换一下身份看看Password:Last login: Tue Jun 2 19:32:31 CST 2015 on tty2[root@study ~]# ls -altotal 48dr-xr-x---. 5 root root 4096 May 29 16:08 .dr-xr-xr-x. 17 root root 4096 May 4 17:56 ..-rw-------. 1 root root 1816 May 4 17:57 anaconda-ks.cfg-rw-------. 1 root root 927 Jun 2 11:27 .bash_history-rw-r--r--. 1 root root 18 Dec 29 2013 .bash_logout-rw-r--r--. 1 root root 176 Dec 29 2013 .bash_profile-rw-r--r--. 1 root root 176 Dec 29 2013 .bashrcdrwxr-xr-x. 3 root root 17 May 6 00:14 .config &lt;&#x3D;范例说明处drwx------. 3 root root 24 May 4 17:59 .dbus-rw-r--r--. 1 root root 1864 May 4 18:01 initial-setup-ks.cfg &lt;&#x3D;范例说明处[ 1 ][ 2 ]  [ 3 ]  [ 4 ][ 5 ][ 6 ] [ 7 ][ 权限 ] [链接] [拥有者][群组][文件大小][ 修改日期 ] [ 文件名 ]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ls是“list”的意思，重点在显示文件的文件名与相关属性。而选项“-al”则表示列出所有的文件详细的权限与属性 （包含隐藏文件，就是文件名第一个字符为“ . ”的文件）。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230401172323265.png"></p><h4 id="第一栏"><a href="#第一栏" class="headerlink" title="第一栏"></a>第一栏</h4><p>代表这个文件是“目录、文件或链接文件等等”：</p><ul><li>当为[ d ]则是目录，例如上表文件名为“.config”的那一行； </li><li>当为[ - ]则是文件，例如上表文件名为“initial-setup-ks.cfg”那一行； </li><li>若是[ l ]则表示为链接文件（link file）； </li><li>若是[ b ]则表示为设备文件里面的可供储存的周边设备（可随机存取设备）； </li><li>若是[ c ]则表示为设备文件里面的序列埠设备，例如键盘、鼠标（一次性读取设备）。</li></ul><p>接下来的字符中，以三个为一组，且均为“rwx” 的三个参数的组合。其中，[ r ]代表可读 （read）、[ w ]代表可写（write）、[ x ]代表可执行（execute）。 要注意的是，这三个 权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。</p><h4 id="第二栏"><a href="#第二栏" class="headerlink" title="第二栏"></a>第二栏</h4><p>表示有多少文件名链接到此节点（i-node）：</p><p>每个文件都会将他的权限与属性记录到文件系统的i-node中，不过，我们使用的目录树却是使用文件名来记录， 因此每个文件名就会链接到一个i-node！这个属性记录的，就是有多少不同的文件名链接到相同的一个i-node号码去就是了。</p><h4 id="第三栏"><a href="#第三栏" class="headerlink" title="第三栏"></a>第三栏</h4><p>表示这个文件（或目录）的“拥有者帐号”</p><h4 id="第四栏"><a href="#第四栏" class="headerlink" title="第四栏"></a>第四栏</h4><p>表示这个文件的所属群组</p><h4 id="第五栏"><a href="#第五栏" class="headerlink" title="第五栏"></a>第五栏</h4><p>这个文件的容量大小，默认单位为Bytes</p><h4 id="第六栏"><a href="#第六栏" class="headerlink" title="第六栏"></a>第六栏</h4><p>这个文件的创建日期或者是最近的修改日期。如果这个文件被修改的时间距离现在太久了，那 么时间部分会仅显示年份而已。 </p><p>显示出完整的时间：</p><pre class="line-numbers language-none"><code class="language-none">ls -l --full-time<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="第七栏"><a href="#第七栏" class="headerlink" title="第七栏"></a>第七栏</h4><p>这个文件的文件名。比较特殊的是：如果文件名之前多一个“ . ”，则代表这个文件为“隐藏文件”。</p><h3 id="如何改变文件属性和权限"><a href="#如何改变文件属性和权限" class="headerlink" title="如何改变文件属性和权限"></a>如何改变文件属性和权限</h3><pre class="line-numbers language-none"><code class="language-none">chgrp ：改变文件所属群组  &#x2F;&#x2F;change groupchown ：改变文件拥有者   &#x2F;&#x2F;change ownerchmod ：改变文件的权限, SUID, SGID, SBIT等等的特性<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">[root@study ~]# chgrp [-R] dirname&#x2F;filename ...选项与参数：-R : 进行递回（recursive）的持续变更，亦即连同次目录下的所有文件、目录都更新成为这个群组之意。常常用在变更某一目录内所有的文件之情况。&#x2F;&#x2F;chown同理。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h4><pre class="line-numbers language-none"><code class="language-none">chgrp users initial-setup-ks.cfg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h4><pre class="line-numbers language-none"><code class="language-none">chown bin initial-setup-ks.cfg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="chomd"><a href="#chomd" class="headerlink" title="chomd"></a>chomd</h4><p>各权限的分数对照表如下： &gt; r:4 &gt; w:2 &gt; x:1 （2进制）</p><p>每种身份（owner&#x2F;group&#x2F;others）各自的三个权限（r&#x2F;w&#x2F;x）分数是需要累加的</p><p>例如当权限为： [-rwxrwx—] </p><p>分数则是： &gt; owner &#x3D; rwx &#x3D; 4+2+1 &#x3D; 7 &gt; group &#x3D; rwx &#x3D; 4+2+1 &#x3D; 7 &gt; others&#x3D; — &#x3D; 0+0+0 &#x3D; 0</p><pre class="line-numbers language-none"><code class="language-none">chmod 770 .bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="目录与文件之权限意义"><a href="#目录与文件之权限意义" class="headerlink" title="目录与文件之权限意义"></a>目录与文件之权限意义</h3><h4 id="权限对文件的重要性"><a href="#权限对文件的重要性" class="headerlink" title="权限对文件的重要性"></a>权限对文件的重要性</h4><ul><li>r （read）：可读取此一文件的实际内容，如读取文本文件的文字内容等； </li><li>w （write）：可以编辑、新增或者是修改该文件的内容（但不含删除该文件）； </li><li>x （execute）：该文件具有可以被系统执行的权限。</li></ul><p>因为在Windows下面一个文件是否具有执行的能力是借由“ 扩展名 ”来判断的， 例如：.exe, .bat, .com 等等，但是在Linux下面，我们的文件是否能被执行，则是借由是否具有“x”这个权 限来决定的！跟文件名是没有绝对的关系的！</p><h4 id="权限对目录的重要性"><a href="#权限对目录的重要性" class="headerlink" title="权限对目录的重要性"></a>权限对目录的重要性</h4><ul><li>r （read contents in directory）： 表示具有读取目录结构清单的权限，所以当你具有读取（r）一个目录的权限时，表示你 可以查询该目录下的文件名数据。 所以你就可以利用 ls 这个指令将该目录的内容列表显示出来！ </li><li>w （modify contents of directory）： 这个可写入的权限对目录来说，是很了不起的！ 因为他表示你具有异动该目录结构清单 的权限，也就是下面这些权限： 创建新的文件与目录； 删除已经存在的文件与目录（不论该文件的权限为何！） 将已存在的文件或目录进行更名； 搬移该目录内的文件、目录位置。 总之，目录的w权限就与该目录下面的文件名异 动有关就对了啦！ </li><li>x （access directory）： 咦！目录的执行权限有啥用途啊？目录只是记录文件名而已，总不能拿来执行吧？没 错！目录不可以被执行，目录的x代表的是使用者能否进入该目录成为工作目录的用途！ 所谓的工作目录（work directory）就是你目前所在的目录啦！举例来说，当你登陆Linux 鸟哥的 Linux 私房菜：基础学习篇 第四版 5.2 Linux 文件权限概念 272 时， 你所在的主文件夹就是你当下的工作目录。而变换目录的指令是“cd”（change directory）！</li></ul><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230401175711066.png"></p><h3 id="Linux文件种类与拓展名"><a href="#Linux文件种类与拓展名" class="headerlink" title="Linux文件种类与拓展名"></a>Linux文件种类与拓展名</h3><h4 id="正规文件（regular-file）"><a href="#正规文件（regular-file）" class="headerlink" title="正规文件（regular file）"></a>正规文件（regular file）</h4><p>就是一般我们在进行存取的类型的文件，在由 ls -al 所显示出 来的属性方面，第一个字符为 [ - ]，例如 [-rwxrwxrwx ]。另外，依照文件的内容，又大略可以分为：</p><ul><li>纯文本文件（ASCII）：这是Linux系统中最多的一种文件类型啰， 称为纯文本文件是因为内容为我们人类可以直接读到的数据，例如数字、字母等等。 几乎只要我们 可以用来做为设置的文件都属于这一种文件类型。 举例来说，你可以下达“ cat ~&#x2F;.bashrc ”就可以看到该文件的内容。 （cat 是将一个文件内容读出来的指令）</li><li>二进制档（binary）：Linux当中的可执行文件（scripts, 文字体批处理文件不算）就是这种格式的啦～ 举例来说，刚刚下达的指令cat就是一个binary file。</li><li>数据格式文件（data）： 有些程序在运行的过程当中会读取某些特定格式的文件， 那些特定格式的文件可以被称为数据文件 （data file）。举例来说，我们的Linux在使用者登陆时，都会将登录的数据记录在 &#x2F;var&#x2F;log&#x2F;wtmp那个文件内，该文件是一个 data file，他能够通过last这个指令读出来！ 但是使用cat时，会读出乱码～因为他是 属于一种特殊格式的文件。</li></ul><h4 id="目录（directory）"><a href="#目录（directory）" class="headerlink" title="目录（directory）"></a>目录（directory）</h4><p>第一个属性为 [ d ]</p><h4 id="链接文件（link）"><a href="#链接文件（link）" class="headerlink" title="链接文件（link）"></a>链接文件（link）</h4><p>第一个属性为 [ l ]</p><h4 id="设备与设备文件（device）"><a href="#设备与设备文件（device）" class="headerlink" title="设备与设备文件（device）"></a>设备与设备文件（device）</h4><p>与系统周边及储存等相关的一些文件， 通常都集中在&#x2F;dev 这个目录之下！通常又分为两种：</p><ul><li>区块（block）设备文件 ：就是一些储存数据， 以提供系统随机存取的周边设备，举 例来说，硬盘与软盘等就是啦！ 你可以随机的在硬盘的不同区块读写，这种设备就 是区块设备啰！你可以自行查一下&#x2F;dev&#x2F;sda看看， 会发现第一个属性为[ b ]喔！</li><li>字符（character）设备文件：亦即是一些序列埠的周边设备， 例如键盘、鼠标等 等！这些设备的特色就是“一次性读取”的，不能够截断输出。 举例来说，你不可能 让鼠标“跳到”另一个画面，而是“连续性滑动”到另一个地方啊！第一个属性为 [ c ]。</li></ul><h4 id="数据接口文件（sockets）"><a href="#数据接口文件（sockets）" class="headerlink" title="数据接口文件（sockets）"></a>数据接口文件（sockets）</h4><p>既然被称为数据接口文件， 想当然尔，这种类型的文件通常被用在网络上的数据承接了。我们可以启动一个程序来监听用户端的要求， 而用户端就可以通过这个socket来进行数据的沟通了。第一个属性为 [ s ]， 最常在&#x2F;run或&#x2F;tmp这些 个目录中看到这种文件类型了。</p><h4 id="数据输送档（FIFO-pipe）"><a href="#数据输送档（FIFO-pipe）" class="headerlink" title="数据输送档（FIFO, pipe）"></a>数据输送档（FIFO, pipe）</h4><p>FIFO也是一种特殊的文件类型，他主要的目的在解决多个程序同时存取一个文件所造成的错误问题。 FIFO是first-in-first-out的缩写。第一个属性为 [p] 。</p><h1 id="Linux目录配置"><a href="#Linux目录配置" class="headerlink" title="Linux目录配置"></a>Linux目录配置</h1><h2 id="Linux目录配置的依据–FHS"><a href="#Linux目录配置的依据–FHS" class="headerlink" title="Linux目录配置的依据–FHS"></a>Linux目录配置的依据–FHS</h2><p>根据FHS的标准文件指出，他们的主要目的是希望让使用者可以了解到已安装软件通常放 置于那个目录下， 所以他们希望独立的软件开发商、操作系统制作者、以及想要维护系统的 使用者，都能够遵循FHS的标准。 也就是说，FHS的重点在于规范每个特定的目录下应该要 放置什么样子的数据而已。 这样做好处非常多，因为Linux操作系统就能够在既有的面貌下 （目录架构不变）发展出开发者想要的独特风格。</p><p>FHS依据文件系统使用的频繁与否与 是否允许使用者随意更动， 而将目录定义成为四种交互作用的形态，用表格来说有点像下面这样：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230401191015670.png"></p><p>事实上，FHS针对目录树架构仅定义出三层目录下面应该放置什么数据而已，分别是下面这三个目录的定义： </p><ul><li>&#x2F; （root, 根目录）：与开机系统有关； </li><li>&#x2F;usr （unix software resource）：与软件安装&#x2F;执行有关；</li><li>&#x2F;var （variable）：与系统运行过程有关。</li></ul><p>细分略</p><h2 id="目录树"><a href="#目录树" class="headerlink" title="目录树"></a>目录树</h2><p>主要的特性有：</p><ul><li>目录树的启始点为根目录 （&#x2F;, root）； </li><li>每一个目录不止能使用本地端的 partition 的文件系统，也可以使用网络上的 filesystem 。举例来说， 可以利用 Network File System （NFS） 服务器挂载某特定目录等。</li><li>每一个文件在此目录树中的文件名（包含完整路径）都是独一无二的。</li></ul><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230401193841433.png"></p><h2 id="绝对路径与相对路径"><a href="#绝对路径与相对路径" class="headerlink" title="绝对路径与相对路径"></a>绝对路径与相对路径</h2><ul><li>绝对路径：由根目录（&#x2F;）开始写起的文件名或目录名称， 例如 &#x2F;home&#x2F;dmtsai&#x2F;.bashrc；</li><li>相对路径：相对于目前路径的文件名写法。 例如 .&#x2F;home&#x2F;dmtsai 或 ..&#x2F;..&#x2F;home&#x2F;dmtsai&#x2F; 等 等。反正开头不是 &#x2F; 就属于相对路径的写法</li></ul><p>举例来说，你目前在 &#x2F;home 这个目录下， 如果想要进入 &#x2F;var&#x2F;log 这个目录时，可以怎么写呢？</p><ol><li>cd &#x2F;var&#x2F;log （absolute）</li><li>cd ..&#x2F;var&#x2F;log （relative）</li></ol><p>因为你在 &#x2F;home 下面，所以要回到上一层 （..&#x2F;） 之后，才能继续往 &#x2F;var 来移动的！ 特别注 意这两个特殊的目录：</p><ul><li>. ：代表当前的目录，也可以使用 .&#x2F; 来表示；</li><li>.. ：代表上一层目录，也可以 ..&#x2F; 来代表。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络通信</title>
      <link href="/2023/04/01/Learn/Linux/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"/>
      <url>/2023/04/01/Learn/Linux/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h1><h2 id="网络通信概述"><a href="#网络通信概述" class="headerlink" title="网络通信概述"></a>网络通信概述</h2><h3 id="IP和端口"><a href="#IP和端口" class="headerlink" title="IP和端口"></a>IP和端口</h3><p>所有的数据传输，都有三个要素 ：源、目的、长度。 怎么表示源或者目的呢？</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230401143033747.png"></p><p>所以，在网络传输中需要使用“IP 和端口”来表示源或目的。</p><h3 id="网络传输中的-2-个对象：server-和-client"><a href="#网络传输中的-2-个对象：server-和-client" class="headerlink" title="网络传输中的 2 个对象：server 和 client"></a>网络传输中的 2 个对象：server 和 client</h3><p>我们经常访问网站，这涉及 2 个对象：网站服务器，浏览器。网站服务器平 时安静地呆着，浏览器主动发起数据请求。网站服务器、浏览器可以抽象成 2 个 软件的概念：server 程序、client 程序。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230401143221718.png" alt="image-20230401143221718"></p><h3 id="两种传输方式：TCP-x2F-UDP"><a href="#两种传输方式：TCP-x2F-UDP" class="headerlink" title="两种传输方式：TCP&#x2F;UDP"></a>两种传输方式：TCP&#x2F;UDP</h3><p>在一般的网络书籍中，网络协议被分为 5 层，如图 8.3 所示：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230401143238965.png"></p><ul><li><p>应用层：它是体系结构中的最高层，直接为用户的应用进程（例如电子邮件、 文件传输和终端仿真）提供服务。在因特网中的应用层协议很多，如支持万维网 应用的 HTTP 协议，支持电子邮件的 SMTP 协议，支持文件传送的 FTP 协议，DNS， POP3，SNMP，Telnet 等等。 </p></li><li><p>运输层：负责向两个主机中进程之间的通信提供服务。 运输层主要使用以下两种协议：<br>传输控制协议 TCP(Transmission Control Protocol)：面向连接的，数据传输的单位是报文段，能够提供可靠的交付。<br>用户数据包协议 UDP(User Datagram Protocol)：无连接的，数据传输的单位是用户数据报，不保证提供可靠的交付，只能提供“尽最大努力交付”。</p></li><li><p>网络层：负责将被称为数据包（datagram）的网络层分组从一台主机移动到另一台主机。</p></li><li><p>链路层：因特网的网络层通过源和目的地之间的一系列路由器路由数据报。</p></li><li><p>物理层：在物理层上所传数据的单位是比特。物理层的任务就是透明地传送比特流。</p></li></ul><p><strong>TCP 和 UDP 原理上的区别</strong></p><p>TCP 向它的应用程序提供了面向连接的服务。这种服务有 2 个特点：可靠传 输、流量控制（即发送方&#x2F;接收方速率匹配）。它包括了应用层报文划分为短报文， 并提供拥塞控制机制。</p><p>UDP 协议向它的应用程序提供无连接服务。它没有可靠性，没有流量控制， 也没有拥塞控制。</p><p><strong>为何存在 UDP 协议</strong></p><p>既然 TCP 提供了可靠数据传输服务，而 UDP 不能提供，那么 TCP 是否总是首选呢？</p><p>答案是否定的，因为有许多应用更适合用 UDP，举个例子：视频通话时，使 用 UDP，偶尔的丢包、偶尔的花屏时可以忍受的；如果使用 TCP，每个数据包都 要确保可靠传输，当它出错时就重传，这会导致后续的数据包被阻滞，视频效果反而不好。</p><p>使用 UDP 时，有如下特点：</p><ol><li>关于何时发送什么数据控制的更为精细<br>采用 UDP 时只要应用进程将数据传递给 UDP，UDP 就会立即将其传递给网络层。而 TCP 有重传机制，而不管可靠交付需要多长时间。但是实时应用通常不希望过分的延迟报文段的传送，且能容忍一部分数据丢失。 </li><li>无需建立连接，不会引入建立连接时的延迟。 </li><li>无连接状态，能支持更多的活跃客户。 </li><li>分组首部开销较小。</li></ol><p><strong>TCP&#x2F;UDP 网络通信大概交互图</strong></p><p>下面我们分别画出运用 TCP 协议和运用 UDP 协议的客户端和服务器大概交互图。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230401150722095.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230401150732681.png"></p><h2 id="网络编程主要函数介绍"><a href="#网络编程主要函数介绍" class="headerlink" title="网络编程主要函数介绍"></a>网络编程主要函数介绍</h2><h3 id="socket函数"><a href="#socket函数" class="headerlink" title="socket函数"></a>socket函数</h3><pre class="line-numbers language-none"><code class="language-none">int socket(int domain, int type,int protocol);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此函数用于创建一个套接字。</p><ul><li><p>domain 是网络程序所在的主机采用的通讯协族(AF_UNIX 和 AF_INET 等)。<br>◼ AF_UNIX 只能够用于单一的 Unix 系统进程间通信，而 AF_INET 是针对 Internet 的，因而可以允许远程通信使用。</p></li><li><p>type 是网络程序所采用的通讯协议(SOCK_STREAM,SOCK_DGRAM 等)。<br>◼ SOCK_STREAM 表明用的是 TCP 协议，这样会提供按顺序的，可靠，双向，面向连接的比特流。<br>◼ SOCK_DGRAM 表明用的是 UDP 协议，这样只会提不可靠，无连接的通信。</p></li><li><p>关于 protocol，由于指定了 type，所以这个地方一般只要用 0 来代替就可以了。</p></li></ul><p>此函数执行成功时返回文件描述符，失败时返回-1,看 errno 可知道出错的 详细情况。</p><h3 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h3><pre class="line-numbers language-none"><code class="language-none">int bind(int sockfd, struct sockaddr *my_addr, int addrlen);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>从函数用于将地址绑定到一个套接字。</p><ul><li>sockfd 是由 socket 函数调用返回的文件描述符。 </li><li>my_addr 是一个指向 sockaddr 的指针。 </li><li>addrlen 是 sockaddr 结构的长度。</li></ul><p>sockaddr 的定义：</p><pre class="line-numbers language-none"><code class="language-none">struct sockaddr&#123;unsigned short as_family;char sa_data[14];&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>不 过 由 于 系 统 的 兼 容 性 , 我 们 一 般 使 用 另 外 一 个 结 构 (struct  sockaddr_in) 来代替。</p><p> sockaddr_in 的定义：</p><pre class="line-numbers language-none"><code class="language-none">struct sockaddr_in&#123;unsigned short sin_family;unsigned short sin_port;struct in_addr sin_addr;unsigned char sin_zero[8];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果使用 Internet 所以 sin_family 一般为 AF_INET。</p><ul><li>sin_addr 设置为 INADDR_ANY 表示可以和任何的主机通信。 </li><li>sin_port 是要监听的端口号。 </li><li>bind 将本地的端口同 socket 返回的文件描述符捆绑在一起.成功是返回 0, 失败的情况和 socket 一样。</li></ul><h3 id="listen函数"><a href="#listen函数" class="headerlink" title="listen函数"></a>listen函数</h3><pre class="line-numbers language-none"><code class="language-none">int listen(int sockfd,int backlog);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此函数宣告服务器可以接受连接请求。</p><ul><li>sockfd 是 bind 后的文件描述符。</li><li>backlog 设置请求排队的最大长度。当有多个客户端程序和服务端相连时， 使用这个表示可以介绍的排队长度。 </li><li>listen 函数将 bind 的文件描述符变为监听套接字，返回的情况和 bind 一样。</li></ul><h3 id="accept函数"><a href="#accept函数" class="headerlink" title="accept函数"></a>accept函数</h3><pre class="line-numbers language-none"><code class="language-none">int accept(int sockfd, struct sockaddr *addr,int *addrlen);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>服务器使用此函数获得连接请求，并且建立连接。</p><ul><li>sockfd 是 listen 后的文件描述符。 </li><li>addr，addrlen 是用来给客户端的程序填写的,服务器端只要传递指针就可 以了， bind,listen 和 accept 是服务器端用的函数。</li><li>accept 调用时，服务器端的程序会一直阻塞到有一个客户程序发出了连接。 accept 成功时返回最后的服务器端的文件描述符，这个时候服务器端可以向该 描述符写信息了，失败时返回-1 。</li></ul><h3 id="connect函数"><a href="#connect函数" class="headerlink" title="connect函数"></a>connect函数</h3><pre class="line-numbers language-none"><code class="language-none">int connect(int sockfd, struct sockaddr * serv_addr,int addrlen);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以用 connect 建立一个连接，在 connect 中所指定的地址是想与之通信的服务器的地址。</p><ul><li>sockfd 是 socket 函数返回的文件描述符。</li><li>serv_addr 储存了服务器端的连接信息，其中 sin_add 是服务端的地址。 </li><li>addrlen 是 serv_addr 的长度 。</li><li>connect 函数是客户端用来同服务端连接的.成功时返回 0，sockfd 是同服务端通讯的文件描述符，失败时返回-1。</li></ul><h3 id="send函数"><a href="#send函数" class="headerlink" title="send函数"></a>send函数</h3><pre class="line-numbers language-none"><code class="language-none">ssize_t send(int sockfd, const void *buf, size_t len, int flags);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>sockfd 指定发送端套接字描述符；</li><li>buf 指明一个存放应用程序要发送数据的缓冲区； </li><li>len 指明实际要发送的数据的字节数； </li><li>flags 一般置 0。 </li><li>客户或者服务器应用程序都用 send 函数来向 TCP 连接的另一端发送数据</li></ul><h3 id="recv函数"><a href="#recv函数" class="headerlink" title="recv函数"></a>recv函数</h3><pre class="line-numbers language-none"><code class="language-none">ssize_t recv(int sockfd, void *buf, size_t len, int flags);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>sockfd 指定接收端套接字描述符；  </li><li>buf 指明一个缓冲区，该缓冲区用来存放 recv 函数接收到的数据； </li><li>len 指明 buf 的长度； </li><li>flags 一般置 0。 </li><li>客户或者服务器应用程序都用 recv 函数从 TCP 连接的另一端接收数据。</li></ul><h3 id="recvfrom函数"><a href="#recvfrom函数" class="headerlink" title="recvfrom函数"></a>recvfrom函数</h3><pre class="line-numbers language-none"><code class="language-none">ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>recvfrom 通常用于无连接套接字，因为此函数可以获得发送者的地址。 </li><li>src_addr 是一个 struct sockaddr 类型的变量，该变量保存源机的 IP 地址及端口号。 </li><li>addrlen 常置为 sizeof（struct sockaddr）。</li></ul><h3 id="sendto函数"><a href="#sendto函数" class="headerlink" title="sendto函数"></a>sendto函数</h3><pre class="line-numbers language-none"><code class="language-none">ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>sendto 和 send 相似，区别在于 sendto 允许在无连接的套接字上指定一个 目标地址。 </li><li>dest_addr 表示目地机的 IP 地址和端口号信息， 243 &#x2F; 566 </li><li>addrlen 常常被赋值为 sizeof （struct sockaddr）。 </li><li>sendto 函数也返回实际发送的数据字节长度或在出现发送错误时返回-1。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Makefile的使用</title>
      <link href="/2023/03/31/Learn/Linux/Makefile%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/03/31/Learn/Linux/Makefile%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="Makefile的使用"><a href="#Makefile的使用" class="headerlink" title="Makefile的使用"></a>Makefile的使用</h1><p>在 Linux 中使用 make 命令来编译程序，特别是大程序；而 make 命令所执 行的动作依赖于 Makefile 文件。最简单的 Makefile 文件如下：</p><pre class="line-numbers language-none"><code class="language-none">hello: hello.cgcc -o hello hello.cclean:rm -f hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>将上述 4 行存为 Makefile 文件(注意必须以 Tab 键缩进第 2、4 行，不能以空格 键缩进)，放入 01_hello 目录下，然后直接执行 make 命令即可编译程序，执行 “make clean”即可清除编译出来的结果。 make 命令根据文件更新的时间戳来决定哪些文件需要重新编译，这使得可 以避免编译已经编译过的、没有变化的程序，可以大大提高编译效率。</p><h2 id="Makefile规则与示例"><a href="#Makefile规则与示例" class="headerlink" title="Makefile规则与示例"></a>Makefile规则与示例</h2><p><strong>为什么需要 Makefile</strong></p><p>怎么高效地编译程序？想达到什么样的效果？请参考 Visual Studio：修 改源文件或头文件，只需要重新编译牵涉到的文件，就可以重新生成 APP</p><p><strong>Makefile 其实挺简单</strong></p><p>一个简单的 Makefile 文件包含一系列的“规则”，其样式如下：</p><pre class="line-numbers language-none"><code class="language-none">目标(target)…: 依赖(prerequiries)…&lt;tab&gt;命令(command)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果“依赖文件”比“目标文件”更加新，那么执行“命令”来重新生成“目标文件”。</p><p>命令被执行的 2 个条件：依赖文件比目标文件新，或是 目标文件还没生成。</p><p><strong>先介绍 Makefile 的 2 个函数</strong></p><p>$(foreach var,list,text) </p><p>简单地说，就是 for each var in list, change it to text。</p><p>对 list 中的每一个元素，取出来赋给 var，然后把 var 改为 text 所描述 的形式。 例子：</p><pre class="line-numbers language-none"><code class="language-none">objs :&#x3D; a.o b.odep_files :&#x3D; $(foreach f, $(objs), .$(f).d) &#x2F;&#x2F; 最终 dep_files :&#x3D; .a.o.d .b.o.d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> $(wildcard pattern)</p><p>pattern 所列出的文件是否存在，把存在的文件都列出来。 例子：</p><pre class="line-numbers language-none"><code class="language-none">src_files :&#x3D; $( wildcard *.c) &#x2F;&#x2F; 最终 src_files 中列出了当前目录下的所有.c 文件<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>一步一步完善 Makefile</strong></p><p>第 1 个 Makefile，简单粗暴，效率低：</p><pre class="line-numbers language-none"><code class="language-none">test : main.c sub.c sub.hgcc -o test main.c sub.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>第 2 个 Makefile，效率高，相似规则太多太啰嗦，不支持检测头文件：</p><pre class="line-numbers language-none"><code class="language-none">test : main.o sub.ogcc -o test main.o sub.omain.o : main.cgcc -c -o main.o main.csub.o : sub.cgcc -c -o sub.o sub.cclean:rm *.o test -f<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第 3 个 Makefile，效率高，精炼，不支持检测头文件：</p><pre class="line-numbers language-none"><code class="language-none">test : main.o sub.ogcc -o test main.o sub.o%.o : %.cgcc -c -o $@ $&lt;clean:rm *.o test -f<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第 4 个 Makefile，效率高，精炼，支持检测头文件(但是需要手工添加头文 件规则)：</p><pre class="line-numbers language-none"><code class="language-none">test : main.o sub.ogcc -o test main.o sub.o%.o : %.cgcc -c -o $@ $&lt;sub.o : sub.hclean:rm *.o test -f<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第 5 个 Makefile，效率高，精炼，支持自动检测头文件：</p><pre class="line-numbers language-none"><code class="language-none">objs :&#x3D; main.o sub.otest : $(objs)gcc -o test $^# 需要判断是否存在依赖文件# .main.o.d .sub.o.ddep_files :&#x3D; $(foreach f, $(objs), .$(f).d)dep_files :&#x3D; $(wildcard $(dep_files))# 把依赖文件包含进来ifneq ($(dep_files),) include $(dep_files)endif%.o : %.cgcc -Wp,-MD,.$@.d -c -o $@ $&lt;clean:rm *.o test -fdistclean:rm $(dep_files) *.o test -f<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="通用Makefile的解析"><a href="#通用Makefile的解析" class="headerlink" title="通用Makefile的解析"></a>通用Makefile的解析</h2><h3 id="make-命令的使用"><a href="#make-命令的使用" class="headerlink" title="make 命令的使用"></a>make 命令的使用</h3><p>执行 make 命令时，它会去当前目录下查找名为“Makefile”的文件，并根 据它的指示去执行操作，生成第一个目标。 我们可以使用“-f”选项指定文件，不再使用名为“Makefile”的文件，比 如：</p><pre class="line-numbers language-none"><code class="language-none">make -f Makefile.build<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们可以使用“-C”选项指定目录，切换到其他目录里去，比如：</p><pre class="line-numbers language-none"><code class="language-none">make -C a&#x2F; -f Makefile.build<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们可以指定目标，不再默认生成第一个目标：</p><pre class="line-numbers language-none"><code class="language-none">make -C a&#x2F; -f Makefile.build other_target<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="即时变量、延时变量"><a href="#即时变量、延时变量" class="headerlink" title="即时变量、延时变量"></a>即时变量、延时变量</h3><p>变量的定义语法形式如下：</p><pre class="line-numbers language-none"><code class="language-none">A &#x3D; xxx &#x2F;&#x2F; 延时变量B ?&#x3D; xxx &#x2F;&#x2F; 延时变量，只有第一次定义时赋值才成功；如果曾定义过，此赋值无效C :&#x3D; xxx &#x2F;&#x2F; 立即变量D +&#x3D; yyy &#x2F;&#x2F; 如果 D 在前面是延时变量，那么现在它还是延时变量；&#x2F;&#x2F; 如果 D 在前面是立即变量，那么现在它还是立即变量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 GNU make 中对变量的赋值有两种方式：延时变量、立即变量。上面语句 中，变量 A 是延时变量，它的值在使用时才展开、才确定。比如：</p><pre class="line-numbers language-none"><code class="language-none">A &#x3D; $@test:@echo $A<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上述 Makefile 中，变量 A 的值在执行时才确定，它等于 test，是延时变量。如 果使用“A :&#x3D; $@”，这是立即变量，这时$@为空，所以 A 的值就是空。</p><h3 id="变量的导出-export"><a href="#变量的导出-export" class="headerlink" title="变量的导出(export)"></a>变量的导出(export)</h3><p>在编译程序时，我们会不断地使用“make -C dir”切换到其他目录，执行其他 目录里的 Makefile。如果想让某个变量的值在所有目录中都可见，要把它 export 出来。 比如“<u>CC &#x3D; $(CROSS_COMPILE)gcc</u>”，这个 CC 变量表示编译器，在整个过程中都 是一样的。定义它之后，要使用“export CC”把它导出来。</p><h3 id="Makefile-中可以使用-shell-命令："><a href="#Makefile-中可以使用-shell-命令：" class="headerlink" title="Makefile 中可以使用 shell 命令："></a>Makefile 中可以使用 shell 命令：</h3><pre class="line-numbers language-none"><code class="language-none">TOPDIR :&#x3D; $(shell pwd)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这是个立即变量，TOPDIR 等于 shell 命令 pwd 的结果。</p><h3 id="在-Makefile-中怎么放置第-1-个目标："><a href="#在-Makefile-中怎么放置第-1-个目标：" class="headerlink" title="在 Makefile 中怎么放置第 1 个目标："></a>在 Makefile 中怎么放置第 1 个目标：</h3><p>执行 make 命令时如果不指定目标，那么它默认是去生成第 1 个目标。 所以“第 1 个目标”，位置很重要。有时候不太方便把第 1 个目标完整地放 在文件前面，这时可以在文件的前面直接放置目标，在后面再完善它的依赖与命 令。比如：</p><pre class="line-numbers language-none"><code class="language-none">First_target: &#x2F;&#x2F; 这句话放在前面．．．． &#x2F;&#x2F; 其他代码，比如 include 其他文件得到后面的 xxx 变量First_target : $(xxx) $(yyy) &#x2F;&#x2F; 在文件的后面再来完善command<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="假想目标"><a href="#假想目标" class="headerlink" title="假想目标"></a>假想目标</h3><p>我们的 Makefile 中有这样的目标：</p><pre class="line-numbers language-none"><code class="language-none">clean:rm -f $(shell find -name &quot;*.o&quot;)rm -f $(TARGET)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果当前目录下恰好有名为“clean”的文件，那么执行“make clean”时它 就不会执行那些删除命令。这时我们需要把“clean”这个目标，设置为“假想目 标”，这样可以确保执行“make clean”时那些删除命令肯定可以得到执行。 使用下面的语句把“clean”设置为假想目标：</p><pre class="line-numbers language-none"><code class="language-none">.PHONY : clean<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="常用的函数"><a href="#常用的函数" class="headerlink" title="常用的函数"></a>常用的函数</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230331213340123.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230331213332177.png"></p><h2 id="通用-Makefile-的设计思想"><a href="#通用-Makefile-的设计思想" class="headerlink" title="通用 Makefile 的设计思想"></a>通用 Makefile 的设计思想</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230331213852949.png"></p><h1 id="Makefile规则"><a href="#Makefile规则" class="headerlink" title="Makefile规则"></a>Makefile规则</h1><p>一个简单的 Makefile 文件包含一系列的“规则”，其样式如下：</p><pre class="line-numbers language-none"><code class="language-none">目标(target)…: 依赖(prerequiries)…&lt;tab&gt;命令(command)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​目标(target)通常是要生成的文件的名称，可以是可执行文件或OBJ文件， 也可以是一个执行的动作名称，诸如&#96;clean’。</p><p>​ 依赖是用来产生目标的材料(比如源文件)，一个目标经常有几个依赖。 </p><p>​命令是生成目标时执行的动作，一个规则可以含有几个命令，每个命令占一行。</p><p> 注意：每个命令行前面必须是一个 Tab 字符，即命令行第一个字符是 Tab。这是容易出错的地方。</p><p> 通常，如果一个依赖发生了变化，就需要规则调用命令以更新或创建目标。 但是并非所有的目标都有依赖，例如，目标“clean”的作用是清除文件，它没 有依赖。</p><p> 规则一般是用于解释怎样和何时重建目标。make 首先调用命令处理依赖， 进而才能创建或更新目标。当然，一个规则也可以是用于解释怎样和何时执行一个动作，即打印提示信息。 </p><p>一个 Makefile 文件可以包含规则以外的其他文本，但一个简单的 Makefile 文件仅仅需要包含规则。虽然真正的规则比这里展示的例子复杂，但格式是完全 一样的。 </p><p>对于上面的 Makefile，执行“make”命令时，仅当 hello.c 文件比 hello 文件新，才会执行命令“arm-linux-gcc –o hello hello.c”生成可执行文件 hello； 160 &#x2F; 566 如果还没有 hello 文件，这个命令也会执行。 </p><p>运行“make clean”时，由于目标 clean 没有依赖，它的命令“rm -f hello” 将被强制执行。</p><h1 id="Makefile文件里的赋值方法"><a href="#Makefile文件里的赋值方法" class="headerlink" title="Makefile文件里的赋值方法"></a>Makefile文件里的赋值方法</h1><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230331214423863.png"></p><h1 id="Makefile常用函数"><a href="#Makefile常用函数" class="headerlink" title="Makefile常用函数"></a>Makefile常用函数</h1><p>略</p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GCC编译器的使用</title>
      <link href="/2023/03/31/Learn/Linux/GCC%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/03/31/Learn/Linux/GCC%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="GCC编译过程"><a href="#GCC编译过程" class="headerlink" title="GCC编译过程"></a>GCC编译过程</h1><p>一个 C&#x2F;C++文件要经过预处理(preprocessing)、编译(compilation)、汇编(assembly)和链接(linking)等 4 步才能变成可执行文件。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230331194200438.png"></p><p>使用示例：</p><pre class="line-numbers language-none"><code class="language-none">gcc hello.c &#x2F;&#x2F; 输出一个名为 a.out 的可执行程序，然后可以执行.&#x2F;a.outgcc -o hello hello.c &#x2F;&#x2F; 输出名为 hello 的可执行程序，然后可以执行.&#x2F;hellogcc -o hello hello.c -static &#x2F;&#x2F; 静态链接gcc -c -o hello.o hello.c &#x2F;&#x2F; 先编译(不链接)gcc -o hello hello.o &#x2F;&#x2F; 再链接<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="常用编译选项"><a href="#常用编译选项" class="headerlink" title="常用编译选项"></a>常用编译选项</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230331195227143.png"></p><h2 id="怎么编译多个文件"><a href="#怎么编译多个文件" class="headerlink" title="怎么编译多个文件"></a>怎么编译多个文件</h2><p>一起编译、链接：</p><pre class="line-numbers language-none"><code class="language-none">gcc -o test main.c sub.c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>分开编译，统一链接：</p><pre class="line-numbers language-none"><code class="language-none">gcc -c -o main.o main.cgcc -c -o sub.o sub.cgcc -o test main.o sub.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="制作、使用动态库"><a href="#制作、使用动态库" class="headerlink" title="制作、使用动态库"></a>制作、使用动态库</h2><p>制作、编译：</p><pre class="line-numbers language-none"><code class="language-none">gcc -c -o main.o main.cgcc -c -o sub.o sub.cgcc -shared -o libsub.so sub.o sub2.o sub3.o(可以使用多个.o 生成动态库)gcc -o test main.o -lsub -L &#x2F;libsub.so&#x2F;所在目录&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>运行：</p><p>①先把 libsub.so 放到 Ubuntu 的&#x2F;lib 目录，然后就可以运行 test 程序。</p><p>② 如果不想把 libsub.so 放到&#x2F;lib，也可以放在某个目录比如&#x2F;a，然后如下执行：</p><pre class="line-numbers language-none"><code class="language-none">export LD_LIBRARY_PATH&#x3D;$LD_LIBRARY_PATH:&#x2F;a .&#x2F;test<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="制作、使用静态库"><a href="#制作、使用静态库" class="headerlink" title="制作、使用静态库"></a>制作、使用静态库</h2><pre class="line-numbers language-none"><code class="language-none">gcc -c -o main.o main.cgcc -c -o sub.o sub.car crs libsub.a sub.o sub2.o sub3.o(可以使用多个.o 生成静态库)gcc -o test main.o libsub.a (如果.a 不在当前目录下，需要指定它的绝对或相对路径)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注意：执行 arm-buildroot-linux-gnueabihf-gcc -c -o sub.o sub.c 交叉编译需要在 最后面加上-fPIC 参数。</p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拓竹嵌入式实习一面</title>
      <link href="/2023/03/30/Summary/%E6%B1%82%E8%81%8C/%E6%8B%93%E7%AB%B9%E4%B8%80%E9%9D%A2/"/>
      <url>/2023/03/30/Summary/%E6%B1%82%E8%81%8C/%E6%8B%93%E7%AB%B9%E4%B8%80%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>先进行自我介绍后，面试官就以下环节进行了提问。</p><p>以下仅为个人记录使用。</p><h1 id="1、外设"><a href="#1、外设" class="headerlink" title="1、外设"></a>1、外设</h1><p>Q：你用过陀螺仪，用的是什么协议呢？</p><p>A：我用过mpu6050，使用的是iic。还有icm20602，使用的是spi。</p><p>Q：可以说一下iic的时序吗？</p><p>A：SCL先拉高，SDA下降沿，表示开始。发送7位地址+一位0&#x2F;1表示收发，从机响应。发数据，响应。发数据，响应。SCL拉高，SDA后拉高，表示结束。</p><pre class="line-numbers language-none"><code class="language-none">这个地方当时答的差不多，但是开始结束SDA上升沿还是下降沿有点忘。补一下。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230331215753490.png"></p><p>Q：iic是怎么实现的？</p><p>A：软件iic</p><p>Q：为什么不用硬件iic，DMA？</p><p>A：正在做….——-</p><pre class="line-numbers language-none"><code class="language-none">小boy昨晚刚说...硬件iic+DMA+中断去做。可惜。但是目前仍然是软件iic<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Q：那DMA传输需要配置什么？</p><p>A：数据大小，地址。字长…啥的。</p><p>​然后就不会，道歉。</p><pre class="line-numbers language-none"><code class="language-none">不会。。这几天补一下！<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Q：可以讲一下你人机交互模块的设计吗？</p><p>A：矩阵键盘，oled&#x3D;&#x3D;&#x3D;&#x3D;</p><p>Q：oled用什么协议？</p><p>A：iic</p><p>Q：spi的四种模式？</p><p>A：通过极性和相位可以分为四种模式。极性代表上升沿或者下降沿有效，相位是Edge1或Edge2，然后比划了一下。</p><p>Q：串口空闲中断+DMA怎么实现？</p><p>A：先开启DMA接收，中断时判断寄存器ISR的IDLE标志位是否置位，如果是则进入。清空标志位，关闭DMA，防止数据混乱，处理完数据后开启DMA。</p><p>Q：我觉得你这样做不好，为什么要关DMA？数据会丢失。有没有更好的解决方法？</p><p>A：那就不关。然后道歉…不会</p><p>面试官提醒了一下考虑一下DMA的寄存器。</p><p>还是不会。。。没有看过。</p><p>面试官没有为难。</p><h1 id="2、RTOS"><a href="#2、RTOS" class="headerlink" title="2、RTOS"></a>2、RTOS</h1><p>Q：怎么看待Freertos的实时性？</p><p>A：任务调度器。优先级抢占&#x3D;&#x3D;。</p><p>Q：优先级是怎么调度？</p><p>A：他有优先级链表，每个优先级一个链表，从上到下看看高优先级有没有ready。。。</p><p>Q：任务与任务之间有什么通信方法？你用了什么？</p><p>A：队列、信号量、互斥量、任务通知。还有一个忘了。我用了队列、信号量和互斥量。</p><pre class="line-numbers language-none"><code class="language-none">事件组忘了，没答上来。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Q：用一个词来概括一下任务通信。</p><p>A：实时性….</p><pre class="line-numbers language-none"><code class="language-none">被骂了。面试官说我觉得是解耦。确实...解耦...我也是这样用的。紧张了，没答点上。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Q：你有管理过堆栈大小吗？</p><p>A：有。我用过heap3和heap5。在heap5里，我使用getstackhighwater那个函数去检测剩余多少，然后给了一定余量。最后用getfree那个全局去减少total的大小。</p><p>Q：余量怎么判断？</p><p>A：栈主要与局部变量，函数嵌套深度等有关，我给的余量是1.5倍。</p><p>Q：任务什么时候会进行调度？</p><p>A：tick中断、队列信号量等发送和阻塞。然后不会了。</p><pre class="line-numbers language-none"><code class="language-none">还有中断和主动delay。可惜，这个应该会的。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="3、控制"><a href="#3、控制" class="headerlink" title="3、控制"></a>3、控制</h1><p>Q：PID传递函数？</p><p>A：输出对误差：Kp+1&#x2F;Kis+Kds。输出对输入：假设为一阶系统。1&#x2F;1+(Kp+1&#x2F;Kis+Kds)(k&#x2F;ms+1)</p><p>Q：怎么处理积分饱和</p><p>A：积分清零和积分限幅。</p><h1 id="4、ARM架构"><a href="#4、ARM架构" class="headerlink" title="4、ARM架构"></a>4、ARM架构</h1><p>由于自我介绍讲了换平台，由此深深坑害自己。</p><p>Q：F7换到F4，考虑什么？</p><p>A：Flash和RAM，我的…多少多少，满足要求。</p><p>Q：时钟呢？会产生什么问题？</p><p>A：一个216MHz，一个168MHz。没有什么问题吧。。重新生成底层。</p><p>Q：那你考虑过CPU占用率吗？</p><p>我就说没有。</p><pre class="line-numbers language-none"><code class="language-none">此处被问懵了。这个应该指的是SystemView全部任务跑的时间占一个周期的百分比。应该说一下SystemView的，但是有点呆住了。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Q：F4和F7是什么架构？</p><p>A：Cortex-M7和M4</p><p>Q：F1和F4的最大区别是什么？</p><p>A：F1没有浮点运算单元。</p><p>Q：那假设我F4处理的浮点数发给F1处理，会出现什么样的结果？</p><p>A：处..理..不会。(平时应该能答上，紧张…)</p><p>面试官解答了一下：处理时间会长。</p><p>Q：栈和堆有什么区别？</p><p>A：堆是程序员malloc等开辟的。栈主要保护现场，存局部变量、返回值&#x3D;&#x3D;</p><p>Q：那假设执行一个计算的函数，栈会怎么样？</p><p>A：R0-R15。我只记得我当时的形参传给了R0寄存器。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230331222914702.png"></p><h1 id="5、项目"><a href="#5、项目" class="headerlink" title="5、项目"></a>5、项目</h1><p>Q：你考虑了什么指标？</p><p>A：—-谈到电池和质量</p><p>Q：你电池考虑了什么？</p><p>A：限制4Wh，8.4v。我算出来最大500mah，我关心电池容量和放电倍率，即最大放电电流。</p><p>Q：那和质量结合起来是什么指标？</p><p>A：…</p><p>一时没反应过来。道歉。</p><p>Q：能量密度…</p><p>有道理。记住了！。。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总结一下今天的面试。根据项目问的比较多，横向问的很广，纵向问的很深。</p><p>不得不说，面试下来，个人认为拓竹开发水平特别高。</p><p>回答的尽力了…有点紧张，挺多会的没想起来。</p><p>作为第一次参加求职面试，自认为自己表现的还可以。</p><p>希望拓竹能给个机会！！</p>]]></content>
      
      
      <categories>
          
          <category> Summary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码随想录_动态规划</title>
      <link href="/2023/03/30/Learn/LeetCode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2023/03/30/Learn/LeetCode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="动态规划五部曲"><a href="#动态规划五部曲" class="headerlink" title="动态规划五部曲"></a>动态规划五部曲</h2><ol><li>确定dp数组以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ol><h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230330215428143.png"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li><p>确定dp数组以及下标的含义：<br>dp[i]的定义为：第i个数的斐波那契数值是dp[i]</p></li><li><p>确定递推公式<br>dp[i] &#x3D; dp[i - 1] + dp[i - 2]</p></li><li><p>dp数组如何初始化<br>dp[0] &#x3D; 0;     dp[1] &#x3D; 1;</p></li><li><p>确定遍历顺序<br>从递归公式dp[i] &#x3D; dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的</p></li><li><p>举例推导dp数组</p><p>按照这个递推公式dp[i] &#x3D; dp[i - 1] + dp[i - 2]，我们来推导一下，当N为10的时候，dp数组应该是如下的数列：</p><p>0 1 1 2 3 5 8 13 21 34 55</p></li></ol><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><h4 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h4><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    int fib(int N) &#123;        if (N &lt; 2) return N;        return fib(N - 1) + fib(N - 2);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h4><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    int fib(int N) &#123;        if (N &lt;&#x3D; 1) return N;        int dp[2];        dp[0] &#x3D; 0;        dp[1] &#x3D; 1;        for (int i &#x3D; 2; i &lt;&#x3D; N; i++) &#123;            int sum &#x3D; dp[0] + dp[1];            dp[0] &#x3D; dp[1];            dp[1] &#x3D; sum;        &#125;        return dp[1];    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230330222911827.png"></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>蛮有意思的一个题目。dp[n]是从dp[n-1]爬一格或者是dp[n-2]爬两格，那么是不是可以认为dp[n] &#x3D; dp[n-1] + dp[n-2]; 于是，这题演变成为斐波那契数列题。</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    int climbStairs(int n) &#123;        int dp[2];        dp[0]&#x3D;1;        dp[1]&#x3D;2;        if(n&#x3D;&#x3D;1)return n;        for(int i&#x3D;1;i&lt;n-1;i++)&#123;            int sum &#x3D; dp[0] + dp[1];            dp[0]&#x3D;dp[1];            dp[1]&#x3D;sum;        &#125;        return dp[1];    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="使用最小花费爬楼梯"><a href="#使用最小花费爬楼梯" class="headerlink" title="使用最小花费爬楼梯"></a>使用最小花费爬楼梯</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230330222935390.png"></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>dp[i - 1] 跳到 dp[i] 需要花费 dp[i - 1] + cost[i - 1]。</p><p>dp[i - 2] 跳到 dp[i] 需要花费 dp[i - 2] + cost[i - 2]。</p><p>那么究竟是选从dp[i - 1]跳还是从dp[i - 2]跳呢？</p><p>一定是选最小的，所以dp[i] &#x3D; min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);</p><p>dp[i]由dp[i-1]dp[i-2]推出，所以是从前到后遍历cost数组就可以了。</p><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) &#123;        int dp[2];        dp[0] &#x3D; 0;        dp[1] &#x3D; 0;        for(int i&#x3D;2;i&lt;&#x3D;cost.size();i++)&#123;            int least &#x3D; min(dp[0]+cost[i-2],dp[1]+cost[i-1]);            dp[0] &#x3D; dp[1];            dp[1] &#x3D; least;        &#125;        return dp[1];    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a>不同路径</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230330225653271.png"></p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ul><li>dp数组</li></ul><p>dp[i]‘[j] ：表示从（0 ，0）出发，到(i, j) 有dp[i]’[j]条不同的路径。</p><ul><li>递推公式</li></ul><p>dp[i]’[j] &#x3D; dp[i-1]’[j] + dp[i]’[j - 1]</p><ul><li>初始化</li></ul><p>如何初始化呢，首先dp[i]’[0]一定都是1，因为从(0, 0)的位置到(i, 0)的路径只有一条，那么dp[0]‘[j]也同理。</p><ul><li>确定遍历顺序</li></ul><p>从其上方和左方推导而来，那么从左到右一层一层遍历就可以了。</p><ul><li>举例推导</li></ul><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230331131916297.png"></p><h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    int uniquePaths(int m, int n) &#123;        vector&lt;vector&lt;int&gt;&gt; dp(m,vector&lt;int&gt;(n,0));        for(int i&#x3D;0;i&lt;m;i++)&#123;dp[i][0]&#x3D;1;&#125;        for(int j&#x3D;0;j&lt;n;j++)&#123;dp[0][j]&#x3D;1;&#125;        for(int i&#x3D;1;i&lt;m;i++)&#123;            for(int j&#x3D;1;j&lt;n;j++)&#123;                dp[i][j] &#x3D; dp[i-1][j] + dp[i][j-1];            &#125;        &#125;        return dp[m-1][n-1];    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="不同路径II"><a href="#不同路径II" class="headerlink" title="不同路径II"></a>不同路径II</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230331132004718.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230331132014996.png"></p><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>从(0, 0)的位置到(i, 0)的路径只有一条，所以dp[i]‘[0]一定为1，dp[0]’[j]也同理。</p><p>但如果(i, 0) 这条边有了障碍之后，障碍之后（包括障碍）都是走不到的位置了，所以障碍之后的dp[i]‘[0]应该还是初始值0。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230331235921324.png"></p><p><strong>注意代码里for循环的终止条件，一旦遇到obstacleGrid[i][0] &#x3D;&#x3D; 1的情况就停止dp[i][0]的赋值1的操作，dp[0][j]同理</strong></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230331235848164.png"></p><h3 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123;        int m &#x3D; obstacleGrid.size();        int n &#x3D; obstacleGrid[0].size();if (obstacleGrid[m - 1][n - 1] &#x3D;&#x3D; 1 || obstacleGrid[0][0] &#x3D;&#x3D; 1) &#x2F;&#x2F;如果在起点或终点出现了障碍，直接返回0            return 0;        vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0));        for (int i &#x3D; 0; i &lt; m &amp;&amp; obstacleGrid[i][0] &#x3D;&#x3D; 0; i++) dp[i][0] &#x3D; 1;        for (int j &#x3D; 0; j &lt; n &amp;&amp; obstacleGrid[0][j] &#x3D;&#x3D; 0; j++) dp[0][j] &#x3D; 1;        for (int i &#x3D; 1; i &lt; m; i++) &#123;            for (int j &#x3D; 1; j &lt; n; j++) &#123;                if (obstacleGrid[i][j] &#x3D;&#x3D; 1) continue;                dp[i][j] &#x3D; dp[i - 1][j] + dp[i][j - 1];            &#125;        &#125;        return dp[m - 1][n - 1];    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a>整数拆分</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230401093044038.png"></p><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p><strong>1.确定dp数组（dp table）以及下标的含义</strong></p><p>dp[i]：分拆数字i，可以得到的最大乘积为dp[i]。</p><p><strong>2.确定递推公式</strong></p><p>可以想 dp[i]最大乘积是怎么得到的呢？</p><p>其实可以从1遍历j，然后有两种渠道得到dp[i].</p><p>一个是j * (i - j) 直接相乘。</p><p>一个是j * dp[i - j]，相当于是拆分(i - j)（两个以上相乘）</p><p>递推公式：dp[i] &#x3D; max(dp[i], max((i - j) * j, dp[i - j] * j));</p><p><strong>3.dp的初始化</strong></p><p>只初始化dp[2] &#x3D; 1</p><p><strong>4.确定遍历顺序</strong></p><p>从前向后遍历</p><p><strong>5.举例推导dp数组</strong></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230401094907002.png"></p><h3 id="Code-5"><a href="#Code-5" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    int integerBreak(int n) &#123;        vector&lt;int&gt; dp(n + 1);        dp[2] &#x3D; 1;        for (int i &#x3D; 3; i &lt;&#x3D; n ; i++) &#123;            for (int j &#x3D; 1; j &lt;&#x3D; i &#x2F; 2; j++) &#123;                dp[i] &#x3D; max(dp[i], max((i - j) * j, dp[i - j] * j));            &#125;        &#125;        return dp[n];    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="不同的二叉搜索树"><a href="#不同的二叉搜索树" class="headerlink" title="不同的二叉搜索树"></a>不同的二叉搜索树</h2><p> <img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230401095001845.png"></p><h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>递推公式：dp[i] +&#x3D; dp[j - 1] * dp[i - j]; ，j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量</p><h3 id="Code-6"><a href="#Code-6" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    int numTrees(int n) &#123;        vector&lt;int&gt; dp(n + 1);        dp[0] &#x3D; 1;        for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;            for (int j &#x3D; 1; j &lt;&#x3D; i; j++) &#123;                dp[i] +&#x3D; dp[j - 1] * dp[i - j];            &#125;        &#125;        return dp[n];    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a>分割等和子集</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230401103750479.png"></p><h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><p>把所有数求和除以二作为容量。如果有数之和大小等于容量，可以认为能分割成两个元素和相等的子集。</p><h3 id="Code-7"><a href="#Code-7" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    bool canPartition(vector&lt;int&gt;&amp; nums) &#123;        int sum &#x3D; 0;        &#x2F;&#x2F; dp[i]中的i表示背包内总和        &#x2F;&#x2F; 题目中说：每个数组中的元素不会超过 100，数组的大小不会超过 200        &#x2F;&#x2F; 总和不会大于20000，背包最大只需要其中一半，所以10001大小就可以了        vector&lt;int&gt; dp(10001, 0);        for (int i &#x3D; 0; i &lt; nums.size(); i++) &#123;            sum +&#x3D; nums[i];        &#125;        &#x2F;&#x2F; 也可以使用库函数一步求和        &#x2F;&#x2F; int sum &#x3D; accumulate(nums.begin(), nums.end(), 0);        if (sum % 2 &#x3D;&#x3D; 1) return false;        int target &#x3D; sum &#x2F; 2;        &#x2F;&#x2F; 开始 01背包        for(int i &#x3D; 0; i &lt; nums.size(); i++) &#123;            for(int j &#x3D; target; j &gt;&#x3D; nums[i]; j--) &#123; &#x2F;&#x2F; 每一个元素一定是不可重复放入，所以从大到小遍历                dp[j] &#x3D; max(dp[j], dp[j - nums[i]] + nums[i]);            &#125;        &#125;        &#x2F;&#x2F; 集合中的元素正好可以凑成总和target        if (dp[target] &#x3D;&#x3D; target) return true;        return false;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="最后一块石头的重量II"><a href="#最后一块石头的重量II" class="headerlink" title="最后一块石头的重量II"></a>最后一块石头的重量II</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230401104437918.png"></p><h3 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h3><p>相对于 01背包，本题中，石头的重量是 stones[i]，石头的价值也是 stones[i] ，可以 “最多可以装的价值为 dp[j]” &#x3D;&#x3D; “最多可以背的重量为dp[j]”。</p><p>最后dp[target]里是容量为target的背包所能背的最大重量。</p><p>那么分成两堆石头，一堆石头的总重量是dp[target]，另一堆就是sum - dp[target]。</p><p><strong>在计算target的时候，target &#x3D; sum &#x2F; 2 因为是向下取整，所以sum - dp[target] 一定是大于等于dp[target]的</strong>。</p><p>那么相撞之后剩下的最小石头重量就是 (sum - dp[target]) - dp[target]。</p><h3 id="Code-8"><a href="#Code-8" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    int lastStoneWeightII(vector&lt;int&gt;&amp; stones) &#123;        vector&lt;int&gt; dp(1501,0);        int sum &#x3D; 0;        for(int i&#x3D;0;i&lt;stones.size();i++)&#123;            sum +&#x3D; stones[i];        &#125;        int target &#x3D; sum&#x2F;2;        for(int i&#x3D;0;i&lt;stones.size();i++)&#123;            for(int j&#x3D;target;j&gt;&#x3D;stones[i];j--)&#123;                dp[j]&#x3D;max(dp[j],dp[j-stones[i]]+stones[i]);            &#125;        &#125;        return sum-dp[target]-dp[target];    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码随想录_贪心算法</title>
      <link href="/2023/03/27/Learn/LeetCode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
      <url>/2023/03/27/Learn/LeetCode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h2 id="分发饼干"><a href="#分发饼干" class="headerlink" title="分发饼干"></a>分发饼干</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230326105229879.png"></p><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p><strong>大饼干喂给大胃口</strong></p><p>使用贪心策略，先将饼干数组和小孩数组排序。然后从后向前遍历小孩数组，用大饼干优先满足胃口大的，并统计满足小孩数量。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123;        sort(g.begin(),g.end());        sort(s.begin(),s.end());        int index &#x3D; s.size()-1;        int result &#x3D; 0;        for(int i&#x3D;g.size()-1;i&gt;&#x3D;0;i--)&#123;            if(index&gt;&#x3D;0 &amp;&amp; g[i]&lt;&#x3D;s[index])&#123;                index--;                result++;            &#125;        &#125;        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p><strong>小饼干喂给小胃口</strong></p><p>饼干从小变大，满足胃口小的小孩，从前向后遍历，并统计。</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123;        sort(g.begin(),g.end());        sort(s.begin(),s.end());        int index &#x3D; 0;        for(int i&#x3D;0;i&lt;s.size();i++)&#123;            if(index&lt;g.size() &amp;&amp; s[i]&gt;&#x3D;g[index])&#123;                index++;            &#125;        &#125;        return index;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="摆动序列"><a href="#摆动序列" class="headerlink" title="摆动序列"></a>摆动序列</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230326120120304.png"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>判断有多少个局部峰值</p><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    int wiggleMaxLength(vector&lt;int&gt;&amp; nums) &#123;        if(nums.size()&#x3D;&#x3D;1)return 1;        int pre &#x3D; 0;        int cur &#x3D; 0;        int result &#x3D; 1;        for(int i&#x3D;1;i&lt;nums.size();i++)&#123;            cur&#x3D;nums[i]-nums[i-1];            if((cur&gt;0 &amp;&amp; pre&lt;&#x3D;0) || (cur&lt;0 &amp;&amp; pre&gt;&#x3D;0))&#123;                result++;                pre&#x3D;cur;            &#125;        &#125;        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230326130302014.png"></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>用maxSum记录最大的子序列和，用count记录全部和。如果count&lt;0了，会使之后的和变小，所有把他清零，从下一个开始算。</p><h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;        int maxSum&#x3D;INT_MIN;        int count&#x3D;0;        for(int i&#x3D;0;i&lt;nums.size();i++)&#123;            count +&#x3D; nums[i];            maxSum &#x3D; count&gt;maxSum?count:maxSum;            if(count&lt;0)&#123;                count &#x3D; 0;            &#125;        &#125;        return maxSum;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="买卖股票的最佳时机II"><a href="#买卖股票的最佳时机II" class="headerlink" title="买卖股票的最佳时机II"></a>买卖股票的最佳时机II</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>我们需要收集每天的正利润就可以，收集正利润的区间，就是股票买卖的区间，而我们只需要关注最终利润，不需要记录区间。</p><h3 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;        int pre &#x3D; prices[0];        int cur &#x3D; 0;        int profit &#x3D; 0;        for(int i&#x3D;0;i&lt;prices.size();i++)&#123;            cur&#x3D;prices[i];            if(cur&gt;&#x3D;pre)&#123;                profit +&#x3D; cur-pre;            &#125;            pre&#x3D;cur;        &#125;        return profit;    &#125;&#125;; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>简化后</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;        int result &#x3D; 0;        for (int i &#x3D; 1; i &lt; prices.size(); i++) &#123;            result +&#x3D; max(prices[i] - prices[i - 1], 0);        &#125;        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230326145741030.png"></p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>局部最优：每次取最大跳跃步数（取最大覆盖范围）</p><p>整体最优：最后得到整体最大覆盖范围，看是否能到终点。</p><h3 id="Code-5"><a href="#Code-5" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    bool canJump(vector&lt;int&gt;&amp; nums) &#123;        int maxCount&#x3D;0;        for(int i&#x3D;0;i&lt;nums.size();i++)&#123;            if(maxCount&lt;i)return false;            maxCount&#x3D;max(maxCount,i+nums[i]);            cout&lt;&lt;maxCount;        &#125;        return true;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="跳跃游戏II"><a href="#跳跃游戏II" class="headerlink" title="跳跃游戏II"></a>跳跃游戏II</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230326145752701.png"></p><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>移动下标达到了当前覆盖的最远距离下标时，步数就要加一，来增加覆盖距离。最后的步数就是最少步数。</p><p>这里还是有个特殊情况需要考虑，当移动下标达到了当前覆盖的最远距离下标时</p><ul><li>如果当前覆盖最远距离下标不是是集合终点，步数就加一，还需要继续走。</li><li>如果当前覆盖最远距离下标就是是集合终点，步数不用加一，因为不能再往后走了。</li></ul><h3 id="Code-6"><a href="#Code-6" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    int jump(vector&lt;int&gt;&amp; nums) &#123;        if (nums.size() &#x3D;&#x3D; 1) return 0;        int curDistance &#x3D; 0;    &#x2F;&#x2F; 当前覆盖最远距离下标        int ans &#x3D; 0;            &#x2F;&#x2F; 记录走的最大步数        int nextDistance &#x3D; 0;   &#x2F;&#x2F; 下一步覆盖最远距离下标        for (int i &#x3D; 0; i &lt; nums.size(); i++) &#123;            nextDistance &#x3D; max(nums[i] + i, nextDistance);  &#x2F;&#x2F; 更新下一步覆盖最远距离下标            if (i &#x3D;&#x3D; curDistance) &#123;                         &#x2F;&#x2F; 遇到当前覆盖最远距离下标                if (curDistance &lt; nums.size() - 1) &#123;       &#x2F;&#x2F; 如果当前覆盖最远距离下标不是终点                    ans++;                                  &#x2F;&#x2F; 需要走下一步                    curDistance &#x3D; nextDistance;             &#x2F;&#x2F; 更新当前覆盖最远距离下标（相当于加油了）                    if (nextDistance &gt;&#x3D; nums.size() - 1) break; &#x2F;&#x2F; 下一步的覆盖范围已经可以达到终点，结束循环                &#125; else break;                               &#x2F;&#x2F; 当前覆盖最远距到达集合终点，不用做ans++操作了，直接结束            &#125;        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="K次取反后最大化的数组和"><a href="#K次取反后最大化的数组和" class="headerlink" title="K次取反后最大化的数组和"></a>K次取反后最大化的数组和</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230326162653733.png"></p><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>1、给数组取绝对值后排序。</p><p>2、从绝对值最大开始遍历，如果为负数就翻转。</p><p>3、到最后没翻转完，k有剩余的话就让最后一个绝对值最小的数自个翻转。</p><h3 id="Code-7"><a href="#Code-7" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;static bool cmp(int a, int b) &#123;    return abs(a) &gt; abs(b);&#125;public:    int largestSumAfterKNegations(vector&lt;int&gt;&amp; A, int K) &#123;        sort(A.begin(), A.end(), cmp);       &#x2F;&#x2F; 第一步        for (int i &#x3D; 0; i &lt; A.size(); i++) &#123; &#x2F;&#x2F; 第二步            if (A[i] &lt; 0 &amp;&amp; K &gt; 0) &#123;                A[i] *&#x3D; -1;                K--;            &#125;        &#125;        if (K % 2 &#x3D;&#x3D; 1) A[A.size() - 1] *&#x3D; -1; &#x2F;&#x2F; 第三步        int result &#x3D; 0;        for (int a : A) result +&#x3D; a;        &#x2F;&#x2F; 第四步        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="加油站"><a href="#加油站" class="headerlink" title="加油站"></a>加油站</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230326163618504.png"></p><h3 id="思路1-1"><a href="#思路1-1" class="headerlink" title="思路1"></a>思路1</h3><p>暴力搜索，遍历每一个加油站为起点的情况，模拟一圈。</p><p>如果跑了一圈，中途没有断油，而且最后油量大于等于0，说明这个起点是ok的。</p><p>暴力的方法思路比较简单，但代码写起来也不是很容易，关键是要模拟跑一圈的过程。</p><p><strong>for循环适合模拟从头到尾的遍历，而while循环适合模拟环形遍历，要善于使用while！</strong></p><h3 id="Code-8"><a href="#Code-8" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123;        for (int i &#x3D; 0; i &lt; cost.size(); i++) &#123;            int rest &#x3D; gas[i] - cost[i]; &#x2F;&#x2F; 记录剩余油量            int index &#x3D; (i + 1) % cost.size();            while (rest &gt; 0 &amp;&amp; index !&#x3D; i) &#123; &#x2F;&#x2F; 模拟以i为起点行驶一圈（如果有rest&#x3D;&#x3D;0，那么答案就不唯一了）                rest +&#x3D; gas[index] - cost[index];                index &#x3D; (index + 1) % cost.size();            &#125;            &#x2F;&#x2F; 如果以i为起点跑一圈，剩余油量&gt;&#x3D;0，返回该起始位置            if (rest &gt;&#x3D; 0 &amp;&amp; index &#x3D;&#x3D; i) return i;        &#125;        return -1;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="思路2-1"><a href="#思路2-1" class="headerlink" title="思路2"></a>思路2</h3><p>直接从全局进行贪心选择，情况如下：</p><ul><li>情况一：如果gas的总和小于cost总和，那么无论从哪里出发，一定是跑不了一圈的</li><li>情况二：rest[i] &#x3D; gas[i]-cost[i]为一天剩下的油，i从0开始计算累加到最后一站，如果累加没有出现负数，说明从0出发，油就没有断过，那么0就是起点。</li><li>情况三：如果累加的最小值是负数，汽车就要从非0节点出发，从后向前，看哪个节点能把这个负数填平，能把这个负数填平的节点就是出发节点。</li></ul><p>为什么呢？我们先算出了从前到最后油箱的最小值，有可能是负多少。那么我们从后面开始补，看从哪开始油箱值能大于这个值的绝对值。</p><h3 id="Code-9"><a href="#Code-9" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123;        int curSum &#x3D; 0;        int min &#x3D; INT_MAX; &#x2F;&#x2F; 从起点出发，油箱里的油量最小值        for (int i &#x3D; 0; i &lt; gas.size(); i++) &#123;            int rest &#x3D; gas[i] - cost[i];            curSum +&#x3D; rest;            if (curSum &lt; min) &#123;                min &#x3D; curSum;            &#125;        &#125;        if (curSum &lt; 0) return -1;  &#x2F;&#x2F; 情况1        if (min &gt;&#x3D; 0) return 0;     &#x2F;&#x2F; 情况2                                    &#x2F;&#x2F; 情况3        for (int i &#x3D; gas.size() - 1; i &gt;&#x3D; 0; i--) &#123;            int rest &#x3D; gas[i] - cost[i];            min +&#x3D; rest;            if (min &gt;&#x3D; 0) &#123;                return i;            &#125;        &#125;        return -1;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="思路3"><a href="#思路3" class="headerlink" title="思路3"></a>思路3</h3><p>首先如果总油量减去总消耗大于等于零那么一定可以跑完一圈，说明各个站点的加油站剩油量rest[i]相加一定是大于等于零的。</p><p>每个加油站的剩余量rest[i]为gas[i] - cost[i]。</p><p>i从0开始累加rest[i]，和记为curSum，一旦curSum小于零，说明[0, i]区间都不能作为起始位置，因为这个区间选择任何一个位置作为起点，到i这里都会断油，那么起始位置从i+1算起，再从0计算curSum。</p><h3 id="Code-10"><a href="#Code-10" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123;        int curSum &#x3D; 0;        int totalSum &#x3D; 0;        int start &#x3D; 0;        for (int i &#x3D; 0; i &lt; gas.size(); i++) &#123;            curSum +&#x3D; gas[i] - cost[i];            totalSum +&#x3D; gas[i] - cost[i];            if (curSum &lt; 0) &#123;   &#x2F;&#x2F; 当前累加rest[i]和 curSum一旦小于0                start &#x3D; i + 1;  &#x2F;&#x2F; 起始位置更新为i+1                curSum &#x3D; 0;     &#x2F;&#x2F; curSum从0开始            &#125;        &#125;        if (totalSum &lt; 0) return -1; &#x2F;&#x2F; 说明怎么走都不可能跑一圈了        return start;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="分发糖果"><a href="#分发糖果" class="headerlink" title="分发糖果"></a>分发糖果</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230326165835546.png"></p><h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>这道题目一定是要确定一边之后，再确定另一边，例如比较每一个孩子的左边，然后再比较右边，<strong>如果两边一起考虑一定会顾此失彼</strong>。</p><p>如果 ratings[i] &gt; ratings[i + 1]，此时candyVec[i]（第i个小孩的糖果数量）就有两个选择了，一个是candyVec[i + 1] + 1（从右边这个加1得到的糖果数量），一个是candyVec[i]（之前比较右孩子大于左孩子得到的糖果数量）。</p><p>那么又要贪心了，局部最优：取candyVec[i + 1] + 1 和 candyVec[i] 最大的糖果数量，保证第i个小孩的糖果数量既大于左边的也大于右边的。全局最优：相邻的孩子中，评分高的孩子获得更多的糖果。</p><p>局部最优可以推出全局最优。</p><p>所以就取candyVec[i + 1] + 1 和 candyVec[i] 最大的糖果数量，<strong>candyVec[i]只有取最大的才能既保持对左边candyVec[i - 1]的糖果多，也比右边candyVec[i + 1]的糖果多</strong>。</p><h3 id="Code-11"><a href="#Code-11" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    int candy(vector&lt;int&gt;&amp; ratings) &#123;        vector&lt;int&gt; candyVec(ratings.size(), 1);        &#x2F;&#x2F; 从前向后        for (int i &#x3D; 1; i &lt; ratings.size(); i++) &#123;            if (ratings[i] &gt; ratings[i - 1]) candyVec[i] &#x3D; candyVec[i - 1] + 1;        &#125;        &#x2F;&#x2F; 从后向前        for (int i &#x3D; ratings.size() - 2; i &gt;&#x3D; 0; i--) &#123;            if (ratings[i] &gt; ratings[i + 1] ) &#123;                candyVec[i] &#x3D; max(candyVec[i], candyVec[i + 1] + 1);            &#125;        &#125;        &#x2F;&#x2F; 统计结果        int result &#x3D; 0;        for (int i &#x3D; 0; i &lt; candyVec.size(); i++) result +&#x3D; candyVec[i];        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="柠檬水找零"><a href="#柠檬水找零" class="headerlink" title="柠檬水找零"></a>柠檬水找零</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230326172300797.png"></p><h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><p>特殊考虑20美元的情况，因为20美元可以找三张5美元或者一张10美元+1张5美元。</p><p>有如下三种情况：</p><ul><li>情况一：账单是5，直接收下。</li><li>情况二：账单是10，消耗一个5，增加一个10</li><li>情况三：账单是20，优先消耗一个10和一个5，如果不够，再消耗三个5</li></ul><h3 id="Code-12"><a href="#Code-12" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    int count&#x3D;0;    int count10&#x3D;0;    bool lemonadeChange(vector&lt;int&gt;&amp; bills) &#123;        for(int i&#x3D;0;i&lt;bills.size();i++)&#123;            if((bills[i]&#x2F;5)&#x3D;&#x3D;1)&#123;                count++;            &#125;            else if(bills[i]&#x2F;5&#x3D;&#x3D;2)&#123;                count -&#x3D; 1;                count10++;            &#125;            else&#123;                if(count10&gt;0)&#123;                    count10--;                    count--;                &#125;                else&#123;                    count-&#x3D;3;                &#125;            &#125;            cout&lt;&lt;count;            if(count&lt;0)return false;        &#125;        return true;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="根据身高重建队列"><a href="#根据身高重建队列" class="headerlink" title="根据身高重建队列"></a>根据身高重建队列</h2><h3 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h3><h3 id="Code-13"><a href="#Code-13" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    static bool cmp(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) &#123;        if (a[0] &#x3D;&#x3D; b[0]) return a[1] &lt; b[1];        return a[0] &gt; b[0];    &#125;    vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) &#123;        sort (people.begin(), people.end(), cmp);        vector&lt;vector&lt;int&gt;&gt; que;        for (int i &#x3D; 0; i &lt; people.size(); i++) &#123;            int position &#x3D; people[i][1];            que.insert(que.begin() + position, people[i]);        &#125;        return que;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但使用vector是非常费时的，C++中vector（可以理解是一个动态数组，底层是普通数组实现的）如果插入元素大于预先普通数组大小，vector底部会有一个扩容的操作，即申请两倍于原先普通数组的大小，然后把数据拷贝到另一个更大的数组上。</p><p>所以使用vector（动态数组）来insert，是费时的，插入再拷贝的话，单纯一个插入的操作就是O(n^2)了，甚至可能拷贝好几次，就不止O(n*n)了。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    &#x2F;&#x2F; 身高从大到小排（身高相同k小的站前面）    static bool cmp(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) &#123;        if (a[0] &#x3D;&#x3D; b[0]) return a[1] &lt; b[1];        return a[0] &gt; b[0];    &#125;    vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) &#123;        sort (people.begin(), people.end(), cmp);        list&lt;vector&lt;int&gt;&gt; que; &#x2F;&#x2F; list底层是链表实现，插入效率比vector高的多        for (int i &#x3D; 0; i &lt; people.size(); i++) &#123;            int position &#x3D; people[i][1]; &#x2F;&#x2F; 插入到下标为position的位置            std::list&lt;vector&lt;int&gt;&gt;::iterator it &#x3D; que.begin();            while (position--) &#123; &#x2F;&#x2F; 寻找在插入位置                it++;            &#125;            que.insert(it, people[i]);        &#125;        return vector&lt;vector&lt;int&gt;&gt;(que.begin(), que.end());    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="用最少数量的箭引爆气球"><a href="#用最少数量的箭引爆气球" class="headerlink" title="用最少数量的箭引爆气球"></a>用最少数量的箭引爆气球</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230326211954385.png"></p><h3 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h3><p>为了让气球尽可能的重叠，需要对数组进行排序。按从小到大排序。</p><p>下一个气球左边界大于了第一组重叠气球的最小右边界，就需要一支箭来射气球了。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230326220635787.png"></p><h3 id="Code-14"><a href="#Code-14" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;private:    static bool cmp(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) &#123;        return a[0] &lt; b[0];    &#125;public:    int findMinArrowShots(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;        if (points.size() &#x3D;&#x3D; 0) return 0;        sort(points.begin(), points.end(), cmp);        int result &#x3D; 1; &#x2F;&#x2F; points 不为空至少需要一支箭        for (int i &#x3D; 1; i &lt; points.size(); i++) &#123;            if (points[i][0] &gt; points[i - 1][1]) &#123;  &#x2F;&#x2F; 气球i和气球i-1不挨着，注意这里不是&gt;&#x3D;                result++; &#x2F;&#x2F; 需要一支箭            &#125;            else &#123;  &#x2F;&#x2F; 气球i和气球i-1挨着                points[i][1] &#x3D; min(points[i - 1][1], points[i][1]); &#x2F;&#x2F; 更新重叠气球最小右边界            &#125;        &#125;        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="无重叠区间"><a href="#无重叠区间" class="headerlink" title="无重叠区间"></a>无重叠区间</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230326222231126.png"></p><h3 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h3><p>先排序，如果左边界大于上一个的右边界就丢掉，remove++。</p><h3 id="Code-15"><a href="#Code-15" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    static bool cmp(vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b)&#123;        return a[1]&lt;b[1];    &#125;    int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;        if(intervals.size()&#x3D;&#x3D;0)return 0;        sort(intervals.begin(),intervals.end(),cmp);        int remove&#x3D;0;        int index&#x3D;0;        for(int i&#x3D;1;i&lt;intervals.size();i++)&#123;            cout&lt;&lt;remove;            if(intervals[i][0]&lt;intervals[index][1])&#123;                remove++;                continue;            &#125;            index &#x3D; i;        &#125;        return remove;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="划分字母区间"><a href="#划分字母区间" class="headerlink" title="划分字母区间"></a>划分字母区间</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230327095017354.png"></p><h3 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h3><p>可以分为如下两步：</p><ul><li>统计每一个字符最后出现的位置</li><li>从头遍历字符，并更新字符的最远出现下标，如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点</li></ul><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230327095619249.png"></p><h3 id="Code-16"><a href="#Code-16" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    vector&lt;int&gt; partitionLabels(string S) &#123;        int hash[27] &#x3D; &#123;0&#125;; &#x2F;&#x2F; i为字符，hash[i]为字符出现的最后位置        for (int i &#x3D; 0; i &lt; S.size(); i++) &#123; &#x2F;&#x2F; 统计每一个字符最后出现的位置            hash[S[i] - &#39;a&#39;] &#x3D; i;        &#125;        vector&lt;int&gt; result;        int left &#x3D; 0;        int right &#x3D; 0;        for (int i &#x3D; 0; i &lt; S.size(); i++) &#123;            right &#x3D; max(right, hash[S[i] - &#39;a&#39;]); &#x2F;&#x2F; 找到字符出现的最远边界            if (i &#x3D;&#x3D; right) &#123;                result.push_back(right - left + 1);                left &#x3D; i + 1;            &#125;        &#125;        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230327095713425.png"></p><h3 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h3><p>左边进行排序。判断是否有重叠区间，如果有就合并区间，没有就加入到结果集里。</p><h3 id="Code-17"><a href="#Code-17" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;        vector&lt;vector&lt;int&gt;&gt; result;        if (intervals.size() &#x3D;&#x3D; 0) return result; &#x2F;&#x2F; 区间集合为空直接返回        &#x2F;&#x2F; 排序的参数使用了lambda表达式        sort(intervals.begin(), intervals.end(), [](const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b)&#123;return a[0] &lt; b[0];&#125;);        &#x2F;&#x2F; 第一个区间就可以放进结果集里，后面如果重叠，在result上直接合并        result.push_back(intervals[0]);         for (int i &#x3D; 1; i &lt; intervals.size(); i++) &#123;            if (result.back()[1] &gt;&#x3D; intervals[i][0]) &#123; &#x2F;&#x2F; 发现重叠区间                &#x2F;&#x2F; 合并区间，只更新右边界就好，因为result.back()的左边界一定是最小值，因为我们按照左边界排序的                result.back()[1] &#x3D; max(result.back()[1], intervals[i][1]);             &#125; else &#123;                result.push_back(intervals[i]); &#x2F;&#x2F; 区间不重叠             &#125;        &#125;        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="单调递增的数字"><a href="#单调递增的数字" class="headerlink" title="单调递增的数字"></a>单调递增的数字</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230327101401278.png"></p><h3 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h3><p>例如：98，一旦出现strNum[i - 1] &gt; strNum[i]的情况（非单调递增），首先想让strNum[i - 1]–，然后strNum[i]给为9，这样这个整数就是89，即小于98的最大的单调递增整数。</p><p>此时是从前向后遍历还是从后向前遍历呢？</p><p>从前向后遍历的话，遇到strNum[i - 1] &gt; strNum[i]的情况，让strNum[i - 1]减一，但此时如果strNum[i - 1]减一了，可能又小于strNum[i - 2]。</p><p>这么说有点抽象，举个例子，数字：332，从前向后遍历的话，那么就把变成了329，此时2又小于了第一位的3了，真正的结果应该是299。</p><h3 id="Code-18"><a href="#Code-18" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    int monotoneIncreasingDigits(int N) &#123;        string strNum &#x3D; to_string(N);        &#x2F;&#x2F; flag用来标记赋值9从哪里开始        &#x2F;&#x2F; 设置为这个默认值，为了防止第二个for循环在flag没有被赋值的情况下执行        int flag &#x3D; strNum.size();        for (int i &#x3D; strNum.size() - 1; i &gt; 0; i--) &#123;            if (strNum[i - 1] &gt; strNum[i] ) &#123;                flag &#x3D; i;                strNum[i - 1]--;            &#125;        &#125;        for (int i &#x3D; flag; i &lt; strNum.size(); i++) &#123;            strNum[i] &#x3D; &#39;9&#39;;        &#125;        return stoi(strNum);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="监控二叉树"><a href="#监控二叉树" class="headerlink" title="监控二叉树"></a>监控二叉树</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230327102052121.png"></p><h3 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h3><p>所以我们要从下往上看，局部最优：让叶子节点的父节点安摄像头，所用摄像头最少，整体最优：全部摄像头数量所用最少！</p><p>局部最优推出全局最优，找不出反例，那么就按照贪心来！</p><p>此时，大体思路就是从低到上，先给叶子节点父节点放个摄像头，然后隔两个节点放一个摄像头，直至到二叉树头结点。</p><p>此时这道题目还有两个难点：</p><ol><li>二叉树的遍历</li><li>如何隔两个节点放一个摄像头</li></ol><p><strong>如何隔两个节点放一个摄像头:</strong></p><p>我们分别有三个数字来表示：</p><ul><li>0：该节点无覆盖</li><li>1：本节点有摄像头</li><li>2：本节点有覆盖</li></ul><h3 id="Code-19"><a href="#Code-19" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;private:    int result;    int traversal(TreeNode* cur) &#123;        if (cur &#x3D;&#x3D; NULL) return 2;        int left &#x3D; traversal(cur-&gt;left);    &#x2F;&#x2F; 左        int right &#x3D; traversal(cur-&gt;right);  &#x2F;&#x2F; 右        if (left &#x3D;&#x3D; 2 &amp;&amp; right &#x3D;&#x3D; 2) return 0;        else if (left &#x3D;&#x3D; 0 || right &#x3D;&#x3D; 0) &#123;            result++;            return 1;        &#125; else return 2;    &#125;public:    int minCameraCover(TreeNode* root) &#123;        result &#x3D; 0;        if (traversal(root) &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; root 无覆盖            result++;        &#125;        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码随想录_回溯算法</title>
      <link href="/2023/03/25/Learn/LeetCode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
      <url>/2023/03/25/Learn/LeetCode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><h2 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230324210224949.png"></p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;private:    vector&lt;vector&lt;int&gt;&gt; result; &#x2F;&#x2F; 存放符合条件结果的集合    vector&lt;int&gt; path; &#x2F;&#x2F; 用来存放符合条件结果    void backtracking(int n, int k, int startIndex) &#123;        if (path.size() &#x3D;&#x3D; k) &#123;            result.push_back(path);            return;        &#125;        for(int i&#x3D;startIndex;i&lt;&#x3D;n;i++)&#123;            path.push_back(i);            backtracking(n,k,i+1);            path.pop_back();        &#125;    &#125;public:    vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123;        backtracking(n, k, 1);        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="减枝优化"><a href="#减枝优化" class="headerlink" title="减枝优化"></a>减枝优化</h3><p>如果4、4，只有一个解{1，2，3，4}，那么我们回溯的时候会很浪费，这时候可以进行减枝。</p><p>接下来看一下优化过程如下：</p><ol><li>已经选择的元素个数：path.size();</li><li>所需需要的元素个数为: k - path.size();</li><li>列表中剩余元素（n-i） &gt;&#x3D; 所需需要的元素个数（k - path.size()）</li><li>在集合n中至多要从该起始位置 : i &lt;&#x3D; n - (k - path.size()) + 1，开始遍历</li></ol><p>为什么有个+1呢，因为包括起始位置，我们要是一个左闭的集合。</p><p>举个例子，n &#x3D; 4，k &#x3D; 3， 目前已经选取的元素为0（path.size为0），n - (k - 0) + 1 即 4 - ( 3 - 0) + 1 &#x3D; 2。</p><p>从2开始搜索都是合理的，可以是组合[2, 3, 4]。</p><p>这里大家想不懂的话，建议也举一个例子，就知道是不是要+1了。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230324222244522.png" alt="image-20230324222244522"></p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;private:    vector&lt;vector&lt;int&gt;&gt; result;    vector&lt;int&gt; path;    void backtracking(int n, int k, int startIndex) &#123;        if (path.size() &#x3D;&#x3D; k) &#123;            result.push_back(path);            return;        &#125;        for (int i &#x3D; startIndex; i &lt;&#x3D; n - (k - path.size()) + 1; i++) &#123; &#x2F;&#x2F; 优化的地方            path.push_back(i); &#x2F;&#x2F; 处理节点            backtracking(n, k, i + 1);            path.pop_back(); &#x2F;&#x2F; 回溯，撤销处理的节点        &#125;    &#125;public:    vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123;        backtracking(n, k, 1);        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="组合总和III"><a href="#组合总和III" class="headerlink" title="组合总和III"></a>组合总和III</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230325132505487.png"></p><p>暴力递归搜索后减枝</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; result;    vector&lt;int&gt; path;    void backtracing(int k,int n,int startIndex)&#123;        if(n&lt;0)return;            if(n &#x3D;&#x3D; 0 &amp;&amp; path.size()&#x3D;&#x3D;k)&#123;            result.push_back(path);            return;        &#125;        for(int i&#x3D;startIndex;i&lt;&#x3D;9-(k - path.size())+1;i++)&#123;            path.push_back(i);            backtracing(k,n-i,i+1);            path.pop_back();        &#125;        return;    &#125;    vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123;        backtracing(k,n,1);        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230325132907686.png"></p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;private:    const string letterMap[10] &#x3D; &#123;        &quot;&quot;, &#x2F;&#x2F; 0        &quot;&quot;, &#x2F;&#x2F; 1        &quot;abc&quot;, &#x2F;&#x2F; 2        &quot;def&quot;, &#x2F;&#x2F; 3        &quot;ghi&quot;, &#x2F;&#x2F; 4        &quot;jkl&quot;, &#x2F;&#x2F; 5        &quot;mno&quot;, &#x2F;&#x2F; 6        &quot;pqrs&quot;, &#x2F;&#x2F; 7        &quot;tuv&quot;, &#x2F;&#x2F; 8        &quot;wxyz&quot;, &#x2F;&#x2F; 9    &#125;;public:    vector&lt;string&gt; result;    void backtracing(const string&amp; digits,int num,const string&amp; str)&#123;        if(num&#x3D;&#x3D;digits.size())&#123;            result.push_back(str);            return;        &#125;        int dig &#x3D; digits[num]-&#39;0&#39;;        string letter&#x3D;letterMap[dig];        for(int i&#x3D;0;i&lt;letter.size();i++)&#123;            backtracing(digits, num+1, str+letter[i]);        &#125;        return;    &#125;    vector&lt;string&gt; letterCombinations(string digits) &#123;        if(digits&#x3D;&#x3D;&quot;&quot;)&#123;return result;&#125;        result.clear();        backtracing(digits,0,&quot;&quot;);        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230325140052847.png"></p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    vector&lt;int&gt; path;    vector&lt;vector&lt;int&gt;&gt; result;    void backtracing(vector&lt;int&gt;&amp; candidates,int target,int startIndex)&#123;        if(target&lt;0)return;        if(target&#x3D;&#x3D;0)&#123;            result.push_back(path);            return;        &#125;        for(int i&#x3D;startIndex;i&lt;candidates.size();i++)&#123;            path.push_back(candidates[i]);            backtracing(candidates,target-candidates[i],i);            path.pop_back();        &#125;        return;    &#125;    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123;        backtracing(candidates,target,0);        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="组合总和II"><a href="#组合总和II" class="headerlink" title="组合总和II"></a>组合总和II</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230325141750589.png"></p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;private:    vector&lt;vector&lt;int&gt;&gt; result;    vector&lt;int&gt; path;    void backtracking(vector&lt;int&gt;&amp; candidates, int target, int sum, int startIndex, vector&lt;bool&gt;&amp; used) &#123;        if (sum &#x3D;&#x3D; target) &#123;            result.push_back(path);            return;        &#125;        for (int i &#x3D; startIndex; i &lt; candidates.size() &amp;&amp; sum + candidates[i] &lt;&#x3D; target; i++) &#123;            &#x2F;&#x2F; used[i - 1] &#x3D;&#x3D; true，说明同一树枝candidates[i - 1]使用过            &#x2F;&#x2F; used[i - 1] &#x3D;&#x3D; false，说明同一树层candidates[i - 1]使用过            &#x2F;&#x2F; 要对同一树层使用过的元素进行跳过            if (i &gt; 0 &amp;&amp; candidates[i] &#x3D;&#x3D; candidates[i - 1] &amp;&amp; used[i - 1] &#x3D;&#x3D; false) &#123;                continue;            &#125;            sum +&#x3D; candidates[i];            path.push_back(candidates[i]);            used[i] &#x3D; true;            backtracking(candidates, target, sum, i + 1, used); &#x2F;&#x2F; 和39.组合总和的区别1，这里是i+1，每个数字在每个组合中只能使用一次            used[i] &#x3D; false;            sum -&#x3D; candidates[i];            path.pop_back();        &#125;    &#125;public:    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123;        vector&lt;bool&gt; used(candidates.size(), false);        path.clear();        result.clear();        &#x2F;&#x2F; 首先把给candidates排序，让其相同的元素都挨在一起。        sort(candidates.begin(), candidates.end());        backtracking(candidates, target, 0, 0, used);        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="分割回文串"><a href="#分割回文串" class="headerlink" title="分割回文串"></a>分割回文串</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230325145606689.png"></p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;private:    vector&lt;vector&lt;string&gt;&gt; result;    vector&lt;string&gt; path; &#x2F;&#x2F; 放已经回文的子串    void backtracking (const string&amp; s, int startIndex) &#123;        &#x2F;&#x2F; 如果起始位置已经大于s的大小，说明已经找到了一组分割方案了        if (startIndex &gt;&#x3D; s.size()) &#123;            result.push_back(path);            return;        &#125;        for (int i &#x3D; startIndex; i &lt; s.size(); i++) &#123;            if (isPalindrome(s, startIndex, i)) &#123;   &#x2F;&#x2F; 是回文子串                &#x2F;&#x2F; 获取[startIndex,i]在s中的子串                string str &#x3D; s.substr(startIndex, i - startIndex + 1);                path.push_back(str);            &#125; else &#123;                                &#x2F;&#x2F; 不是回文，跳过                continue;            &#125;            backtracking(s, i + 1); &#x2F;&#x2F; 寻找i+1为起始位置的子串            path.pop_back(); &#x2F;&#x2F; 回溯过程，弹出本次已经填在的子串        &#125;    &#125;    bool isPalindrome(const string&amp; s, int start, int end) &#123;        for (int i &#x3D; start, j &#x3D; end; i &lt; j; i++, j--) &#123;            if (s[i] !&#x3D; s[j]) &#123;                return false;            &#125;        &#125;        return true;    &#125;public:    vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123;        result.clear();        path.clear();        backtracking(s, 0);        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="复原IP地址"><a href="#复原IP地址" class="headerlink" title="复原IP地址"></a>复原IP地址</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230325161128773.png"></p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;private:    vector&lt;string&gt; result;&#x2F;&#x2F; 记录结果    &#x2F;&#x2F; startIndex: 搜索的起始位置，pointNum:添加逗点的数量    void backtracking(string&amp; s, int startIndex, int pointNum) &#123;        if (pointNum &#x3D;&#x3D; 3) &#123; &#x2F;&#x2F; 逗点数量为3时，分隔结束            &#x2F;&#x2F; 判断第四段子字符串是否合法，如果合法就放进result中            if (isValid(s, startIndex, s.size() - 1)) &#123;                result.push_back(s);            &#125;            return;        &#125;        for (int i &#x3D; startIndex; i &lt; s.size(); i++) &#123;            if (isValid(s, startIndex, i)) &#123; &#x2F;&#x2F; 判断 [startIndex,i] 这个区间的子串是否合法                s.insert(s.begin() + i + 1 , &#39;.&#39;);  &#x2F;&#x2F; 在i的后面插入一个逗点                pointNum++;                backtracking(s, i + 2, pointNum);   &#x2F;&#x2F; 插入逗点之后下一个子串的起始位置为i+2                pointNum--;                         &#x2F;&#x2F; 回溯                s.erase(s.begin() + i + 1);         &#x2F;&#x2F; 回溯删掉逗点            &#125; else break; &#x2F;&#x2F; 不合法，直接结束本层循环        &#125;    &#125;    &#x2F;&#x2F; 判断字符串s在左闭又闭区间[start, end]所组成的数字是否合法    bool isValid(const string&amp; s, int start, int end) &#123;        if (start &gt; end) &#123;            return false;        &#125;        if (s[start] &#x3D;&#x3D; &#39;0&#39; &amp;&amp; start !&#x3D; end) &#123; &#x2F;&#x2F; 0开头的数字不合法                return false;        &#125;        int num &#x3D; 0;        for (int i &#x3D; start; i &lt;&#x3D; end; i++) &#123;            if (s[i] &gt; &#39;9&#39; || s[i] &lt; &#39;0&#39;) &#123; &#x2F;&#x2F; 遇到非数字字符不合法                return false;            &#125;            num &#x3D; num * 10 + (s[i] - &#39;0&#39;);            if (num &gt; 255) &#123; &#x2F;&#x2F; 如果大于255了不合法                return false;            &#125;        &#125;        return true;    &#125;public:    vector&lt;string&gt; restoreIpAddresses(string s) &#123;        result.clear();        if (s.size() &lt; 4 || s.size() &gt; 12) return result; &#x2F;&#x2F; 算是剪枝了        backtracking(s, 0, 0);        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="子集问题"><a href="#子集问题" class="headerlink" title="子集问题"></a>子集问题</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230325171233470.png"></p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; result;    vector&lt;int&gt; path;    void backtracing(vector&lt;int&gt;&amp; nums, int startIndex)&#123;        result.push_back(path);        for(int i&#x3D;startIndex;i&lt;nums.size();i++)&#123;            path.push_back(nums[i]);            backtracing(nums,i+1);            path.pop_back();        &#125;    &#125;    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;        backtracing(nums,0);        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="子集II"><a href="#子集II" class="headerlink" title="子集II"></a>子集II</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230325171613496.png"></p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    vector&lt;int&gt; path;    vector&lt;vector&lt;int&gt;&gt; result;    void backtracing(vector&lt;int&gt;&amp; nums, int startIndex, vector&lt;bool&gt;&amp; used)&#123;        result.push_back(path);        for(int i&#x3D;startIndex;i&lt;nums.size();i++)&#123;            if(i&gt;0 &amp;&amp; nums[i-1]&#x3D;&#x3D;nums[i] &amp;&amp; used[i-1]&#x3D;&#x3D;false)&#123;                continue;            &#125;            path.push_back(nums[i]);            used[i] &#x3D; true;            backtracing(nums,i+1,used);            used[i] &#x3D; false;            path.pop_back();        &#125;        return;    &#125;    vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123;        sort(nums.begin(),nums.end());        vector&lt;bool&gt; used(nums.size(),false);        backtracing(nums,0,used);        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="递增子序列"><a href="#递增子序列" class="headerlink" title="递增子序列"></a>递增子序列</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230325173247152.png"></p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;private:    vector&lt;vector&lt;int&gt;&gt; result;    vector&lt;int&gt; path;    void backtracking(vector&lt;int&gt;&amp; nums, int startIndex) &#123;        if (path.size() &gt; 1) &#123;            result.push_back(path);            &#x2F;&#x2F; 注意这里不要加return，要取树上的节点        &#125;        unordered_set&lt;int&gt; uset; &#x2F;&#x2F; 使用set对本层元素进行去重        for (int i &#x3D; startIndex; i &lt; nums.size(); i++) &#123;            if ((!path.empty() &amp;&amp; nums[i] &lt; path.back())                    || uset.find(nums[i]) !&#x3D; uset.end()) &#123;                    continue;            &#125;            uset.insert(nums[i]); &#x2F;&#x2F; 记录这个元素在本层用过了，本层后面不能再用了            path.push_back(nums[i]);            backtracking(nums, i + 1);            path.pop_back();        &#125;    &#125;public:    vector&lt;vector&lt;int&gt;&gt; findSubsequences(vector&lt;int&gt;&amp; nums) &#123;        result.clear();        path.clear();        backtracking(nums, 0);        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230325191241119.png"></p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; result;    vector&lt;int&gt; path;    int numset[21]&#x3D;&#123;0&#125;;    void backtracing(vector&lt;int&gt;&amp; nums,int startIndex)&#123;        if(path.size()&#x3D;&#x3D;nums.size())&#123;            result.push_back(path);            return;        &#125;        for(int i&#x3D;0;i&lt;nums.size();i++)&#123;            if(numset[nums[i]+10])continue;            path.push_back(nums[i]);            numset[nums[i]+10]++;            backtracing(nums,i);            path.pop_back();            numset[nums[i]+10]--;        &#125;        return;    &#125;    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;        backtracing(nums,-1);        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另解</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; result;    vector&lt;int&gt; path;    void backtracking (vector&lt;int&gt;&amp; nums, vector&lt;bool&gt;&amp; used) &#123;        &#x2F;&#x2F; 此时说明找到了一组        if (path.size() &#x3D;&#x3D; nums.size()) &#123;            result.push_back(path);            return;        &#125;        for (int i &#x3D; 0; i &lt; nums.size(); i++) &#123;            if (used[i] &#x3D;&#x3D; true) continue; &#x2F;&#x2F; path里已经收录的元素，直接跳过            used[i] &#x3D; true;            path.push_back(nums[i]);            backtracking(nums, used);            path.pop_back();            used[i] &#x3D; false;        &#125;    &#125;    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;        result.clear();        path.clear();        vector&lt;bool&gt; used(nums.size(), false);        backtracking(nums, used);        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="全排列II"><a href="#全排列II" class="headerlink" title="全排列II"></a>全排列II</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230325191354441.png"></p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    vector&lt;int&gt; path;    vector&lt;vector&lt;int&gt;&gt; result;    void backtracing(vector&lt;int&gt;&amp; nums, vector&lt;bool&gt;&amp; used)&#123;        if(path.size()&#x3D;&#x3D;nums.size())&#123;            result.push_back(path);            return;        &#125;        for(int i&#x3D;0;i&lt;nums.size();i++)&#123;            if(i&gt;0 &amp;&amp; nums[i]&#x3D;&#x3D;nums[i-1] &amp;&amp; used[i-1]&#x3D;&#x3D;false)continue;            if(used[i]&#x3D;&#x3D;false)&#123;                used[i]&#x3D;true;                path.push_back(nums[i]);                backtracing(nums,used);                used[i]&#x3D;false;                path.pop_back();            &#125;        &#125;    &#125;    vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123;        sort(nums.begin(),nums.end());        vector&lt;bool&gt; used(nums.size(),false);        backtracing(nums,used);        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码随想录_二叉树</title>
      <link href="/2023/03/24/Learn/LeetCode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2023/03/24/Learn/LeetCode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="二叉树的递归遍历"><a href="#二叉树的递归遍历" class="headerlink" title="二叉树的递归遍历"></a>二叉树的递归遍历</h2><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    void Traversal(TreeNode* cur, vector&lt;int&gt; &amp;num)&#123;        if(cur &#x3D;&#x3D; nullptr)&#123;            return;        &#125;        num.push_back(cur-&gt;val);        Traversal(cur-&gt;left, num);        Traversal(cur-&gt;right, num);    &#125;    vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt; res;        Traversal(root,res);        return res;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    void Traversal(TreeNode* cur, vector&lt;int&gt; &amp;num)&#123;        if(cur &#x3D;&#x3D; nullptr)&#123;            return;        &#125;        Traversal(cur-&gt;left,num);        num.push_back(cur-&gt;val);        Traversal(cur-&gt;right,num);    &#125;    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt; res;        Traversal(root,res);        return res;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    void Traversal(TreeNode* cur, vector&lt;int&gt; &amp;num)&#123;        if(cur &#x3D;&#x3D; nullptr)&#123;            return;        &#125;        Traversal(cur-&gt;left,num);        Traversal(cur-&gt;right,num);        num.push_back(cur-&gt;val);    &#125;    vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt; res;        Traversal(root,res);        return res;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二叉树的迭代遍历"><a href="#二叉树的迭代遍历" class="headerlink" title="二叉树的迭代遍历"></a>二叉树的迭代遍历</h2><h3 id="前序遍历-1"><a href="#前序遍历-1" class="headerlink" title="前序遍历"></a>前序遍历</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;        stack&lt;TreeNode*&gt; st;        vector&lt;int&gt; result;        if (root &#x3D;&#x3D; NULL) return result;        st.push(root);        while (!st.empty()) &#123;            TreeNode* node &#x3D; st.top();                       &#x2F;&#x2F; 中            st.pop();            result.push_back(node-&gt;val);            if (node-&gt;right) st.push(node-&gt;right);           &#x2F;&#x2F; 右（空节点不入栈）            if (node-&gt;left) st.push(node-&gt;left);             &#x2F;&#x2F; 左（空节点不入栈）        &#125;        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="中序遍历-1"><a href="#中序遍历-1" class="headerlink" title="中序遍历"></a>中序遍历</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt; result;        stack&lt;TreeNode*&gt; st;        TreeNode* cur &#x3D; root;        while (cur !&#x3D; NULL || !st.empty()) &#123;            if (cur !&#x3D; NULL) &#123; &#x2F;&#x2F; 指针来访问节点，访问到最底层                st.push(cur); &#x2F;&#x2F; 将访问的节点放进栈                cur &#x3D; cur-&gt;left;                &#x2F;&#x2F; 左            &#125; else &#123;                cur &#x3D; st.top(); &#x2F;&#x2F; 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）                st.pop();                result.push_back(cur-&gt;val);     &#x2F;&#x2F; 中                cur &#x3D; cur-&gt;right;               &#x2F;&#x2F; 右            &#125;        &#125;        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="后序遍历-1"><a href="#后序遍历-1" class="headerlink" title="后序遍历"></a>后序遍历</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;        stack&lt;TreeNode*&gt; st;        vector&lt;int&gt; result;        if (root &#x3D;&#x3D; NULL) return result;        st.push(root);        while (!st.empty()) &#123;            TreeNode* node &#x3D; st.top();            st.pop();            result.push_back(node-&gt;val);            if (node-&gt;left) st.push(node-&gt;left); &#x2F;&#x2F; 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈）            if (node-&gt;right) st.push(node-&gt;right); &#x2F;&#x2F; 空节点不入栈        &#125;        reverse(result.begin(), result.end()); &#x2F;&#x2F; 将结果反转之后就是左右中的顺序了        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二叉树的统一迭代法"><a href="#二叉树的统一迭代法" class="headerlink" title="二叉树的统一迭代法"></a>二叉树的统一迭代法</h2><h3 id="前序遍历-2"><a href="#前序遍历-2" class="headerlink" title="前序遍历"></a>前序遍历</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt; result;        stack&lt;TreeNode*&gt; st;        if (root !&#x3D; NULL) st.push(root);        while (!st.empty()) &#123;            TreeNode* node &#x3D; st.top();            if (node !&#x3D; NULL) &#123;                st.pop();                if (node-&gt;right) st.push(node-&gt;right);  &#x2F;&#x2F; 右                if (node-&gt;left) st.push(node-&gt;left);    &#x2F;&#x2F; 左                st.push(node);                          &#x2F;&#x2F; 中                st.push(NULL);            &#125; else &#123;                st.pop();                node &#x3D; st.top();                st.pop();                result.push_back(node-&gt;val);            &#125;        &#125;        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="中序遍历-2"><a href="#中序遍历-2" class="headerlink" title="中序遍历"></a>中序遍历</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt; result;        stack&lt;TreeNode*&gt; st;        if (root !&#x3D; NULL) st.push(root);        while (!st.empty()) &#123;            TreeNode* node &#x3D; st.top();            if (node !&#x3D; NULL) &#123;                st.pop(); &#x2F;&#x2F; 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中                if (node-&gt;right) st.push(node-&gt;right);  &#x2F;&#x2F; 添加右节点（空节点不入栈）                st.push(node);                          &#x2F;&#x2F; 添加中节点                st.push(NULL); &#x2F;&#x2F; 中节点访问过，但是还没有处理，加入空节点做为标记。                if (node-&gt;left) st.push(node-&gt;left);    &#x2F;&#x2F; 添加左节点（空节点不入栈）            &#125; else &#123; &#x2F;&#x2F; 只有遇到空节点的时候，才将下一个节点放进结果集                st.pop();           &#x2F;&#x2F; 将空节点弹出                node &#x3D; st.top();    &#x2F;&#x2F; 重新取出栈中元素                st.pop();                result.push_back(node-&gt;val); &#x2F;&#x2F; 加入到结果集            &#125;        &#125;        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="后序遍历-2"><a href="#后序遍历-2" class="headerlink" title="后序遍历"></a>后序遍历</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt; result;        stack&lt;TreeNode*&gt; st;        if (root !&#x3D; NULL) st.push(root);        while (!st.empty()) &#123;            TreeNode* node &#x3D; st.top();            if (node !&#x3D; NULL) &#123;                st.pop();                st.push(node);                          &#x2F;&#x2F; 中                st.push(NULL);                if (node-&gt;right) st.push(node-&gt;right);  &#x2F;&#x2F; 右                if (node-&gt;left) st.push(node-&gt;left);    &#x2F;&#x2F; 左            &#125; else &#123;                st.pop();                node &#x3D; st.top();                st.pop();                result.push_back(node-&gt;val);            &#125;        &#125;        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h2><h3 id="层序遍历模板"><a href="#层序遍历模板" class="headerlink" title="层序遍历模板"></a>层序遍历模板</h3><p>队列</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;        queue&lt;TreeNode*&gt; que;        if (root !&#x3D; NULL) que.push(root);        vector&lt;vector&lt;int&gt;&gt; result;        while (!que.empty()) &#123;            int size &#x3D; que.size();            vector&lt;int&gt; vec;            &#x2F;&#x2F; 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的            for (int i &#x3D; 0; i &lt; size; i++) &#123;                TreeNode* node &#x3D; que.front();                que.pop();                vec.push_back(node-&gt;val);                if (node-&gt;left) que.push(node-&gt;left);                if (node-&gt;right) que.push(node-&gt;right);            &#125;            result.push_back(vec);        &#125;        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 递归法</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    void order(TreeNode* cur, vector&lt;vector&lt;int&gt;&gt;&amp; result, int depth)    &#123;        if (cur &#x3D;&#x3D; nullptr) return;        if (result.size() &#x3D;&#x3D; depth) result.push_back(vector&lt;int&gt;());        result[depth].push_back(cur-&gt;val);        order(cur-&gt;left, result, depth + 1);        order(cur-&gt;right, result, depth + 1);    &#125;    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;        vector&lt;vector&lt;int&gt;&gt; result;        int depth &#x3D; 0;        order(root, result, depth);        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102.二叉树的层序遍历"></a>102.二叉树的层序遍历</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;        queue&lt;TreeNode*&gt; que;        que.push(root);        vector&lt;vector&lt;int&gt;&gt; res;        if(root &#x3D;&#x3D; nullptr)&#123;return res;&#125;        while(!que.empty())&#123;            int _size &#x3D; que.size();            vector&lt;int&gt; level;            for(int i&#x3D;0;i&lt;_size;i++)&#123;                level.push_back(que.front()-&gt;val);                if(que.front()-&gt;left)&#123;que.push(que.front()-&gt;left);&#125;                if(que.front()-&gt;right)&#123;que.push(que.front()-&gt;right);&#125;                que.pop();            &#125;            res.push_back(level);        &#125;        return res;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="107-二叉树的层次遍历II"><a href="#107-二叉树的层次遍历II" class="headerlink" title="107.二叉树的层次遍历II"></a>107.二叉树的层次遍历II</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123;        queue&lt;TreeNode*&gt; que;         if(root !&#x3D; nullptr)que.push(root);        vector&lt;vector&lt;int&gt;&gt; res;        while(!que.empty())&#123;            int _size &#x3D; que.size();            vector&lt;int&gt; level;            for(int i&#x3D;0;i&lt;_size;i++)&#123;                level.push_back(que.front()-&gt;val);                if(que.front()-&gt;left)&#123;que.push(que.front()-&gt;left);&#125;                if(que.front()-&gt;right)&#123;que.push(que.front()-&gt;right);&#125;                que.pop();            &#125;            res.push_back(level);        &#125;        reverse(res.begin(),res.end());        return res;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199.二叉树的右视图"></a>199.二叉树的右视图</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    vector&lt;int&gt; rightSideView(TreeNode* root) &#123;        queue&lt;TreeNode*&gt; que;         if(root !&#x3D; nullptr)que.push(root);        vector&lt;int&gt; res;        while(!que.empty())&#123;            int _size &#x3D; que.size();            vector&lt;int&gt; level;            for(int i&#x3D;0;i&lt;_size;i++)&#123;                level.push_back(que.front()-&gt;val);                if(que.front()-&gt;left)&#123;que.push(que.front()-&gt;left);&#125;                if(que.front()-&gt;right)&#123;que.push(que.front()-&gt;right);&#125;                que.pop();            &#125;            res.push_back(level[level.size()-1]);        &#125;        return res;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="637-二叉树的层平均值"><a href="#637-二叉树的层平均值" class="headerlink" title="637.二叉树的层平均值"></a>637.二叉树的层平均值</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    vector&lt;double&gt; averageOfLevels(TreeNode* root) &#123;        queue&lt;TreeNode*&gt; que;        vector&lt;double&gt; res;        if(root!&#x3D;nullptr)&#123;que.push(root);&#125;        while(!que.empty())&#123;            int _size &#x3D; que.size();            vector&lt;int&gt; tmp;            for(int i&#x3D;0;i&lt;_size;i++)&#123;                tmp.push_back(que.front()-&gt;val);                if(que.front()-&gt;left)&#123;                    que.push(que.front()-&gt;left);                &#125;                if(que.front()-&gt;right)&#123;                    que.push(que.front()-&gt;right);                                    &#125;                que.pop();            &#125;            double sum &#x3D; 0;            for(auto i:tmp)&#123;                sum +&#x3D; i;            &#125;            double aver &#x3D; sum&#x2F;_size;            res.push_back(aver);        &#125;        return res;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="429-N叉树的层序遍历"><a href="#429-N叉树的层序遍历" class="headerlink" title="429.N叉树的层序遍历"></a>429.N叉树的层序遍历</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; levelOrder(Node* root) &#123;        queue&lt;Node*&gt; que;        vector&lt;vector&lt;int&gt;&gt; res;        if(root !&#x3D; nullptr)que.push(root);        while(!que.empty())&#123;            int size&#x3D;que.size();            vector&lt;int&gt; tmp;            for(int i&#x3D;0;i&lt;size;i++)&#123;                tmp.push_back(que.front()-&gt;val);                for(auto c:que.front()-&gt;children)&#123;                        que.push(c);                    &#125;                que.pop();                &#125;                res.push_back(tmp);            &#125;            return res;        &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="515-在每个树行中找最大值"><a href="#515-在每个树行中找最大值" class="headerlink" title="515.在每个树行中找最大值"></a>515.在每个树行中找最大值</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    vector&lt;int&gt; largestValues(TreeNode* root) &#123;        vector&lt;int&gt; res;        queue&lt;TreeNode*&gt; que;        if(root!&#x3D;nullptr)que.push(root);        while(!que.empty())&#123;            int size&#x3D;que.size();            int lar &#x3D; que.front()-&gt;val;            for(int i&#x3D;0;i&lt;size;i++)&#123;                lar &#x3D; max(lar,que.front()-&gt;val);                if(que.front()-&gt;left)&#123;                    que.push(que.front()-&gt;left);                &#125;                if(que.front()-&gt;right)&#123;                    que.push(que.front()-&gt;right);                &#125;                que.pop();            &#125;            res.push_back(lar);        &#125;        return res;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116.填充每个节点的下一个右侧节点指针"></a>116.填充每个节点的下一个右侧节点指针</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    Node* connect(Node* root) &#123;        queue&lt;Node*&gt; que;        vector&lt;Node*&gt; vec;        if(root!&#x3D;nullptr)que.push(root);        while(!que.empty())&#123;            int size&#x3D;que.size();            for(int i&#x3D;0;i&lt;size;i++)&#123;                Node* node &#x3D; que.front();                if(que.front()-&gt;left)&#123;                    que.push(que.front()-&gt;left);                &#125;                if(que.front()-&gt;right)&#123;                    que.push(que.front()-&gt;right);                &#125;                que.pop();                if(i&lt;size-1)node-&gt;next &#x3D; que.front();            &#125;        &#125;        return root;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="117-填充每个节点的下一个右侧节点指针II"><a href="#117-填充每个节点的下一个右侧节点指针II" class="headerlink" title="117.填充每个节点的下一个右侧节点指针II"></a>117.填充每个节点的下一个右侧节点指针II</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    Node* connect(Node* root) &#123;        queue&lt;Node*&gt; que;        vector&lt;Node*&gt; vec;        if(root!&#x3D;nullptr)que.push(root);        while(!que.empty())&#123;            int size&#x3D;que.size();            for(int i&#x3D;0;i&lt;size;i++)&#123;                Node* node &#x3D; que.front();                if(que.front()-&gt;left)&#123;                    que.push(que.front()-&gt;left);                &#125;                if(que.front()-&gt;right)&#123;                    que.push(que.front()-&gt;right);                &#125;                que.pop();                if(i&lt;size-1)node-&gt;next &#x3D; que.front();            &#125;        &#125;        return root;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104.二叉树的最大深度"></a>104.二叉树的最大深度</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    int maxDepth(TreeNode* root) &#123;        queue&lt;TreeNode*&gt; que;        if(root!&#x3D;nullptr)que.push(root);        int k&#x3D;0;        while(!que.empty())&#123;            int size&#x3D;que.size();            for(int i&#x3D;0;i&lt;size;i++)&#123;                if(que.front()-&gt;left)&#123;                    que.push(que.front()-&gt;left);                &#125;                if(que.front()-&gt;right)&#123;                    que.push(que.front()-&gt;right);                &#125;                que.pop();            &#125;            k++;        &#125;        return k;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>后续遍历求高度</p><pre class="line-numbers language-none"><code class="language-none">class solution &#123;public:    int getdepth(treenode* node) &#123;        if (node &#x3D;&#x3D; NULL) return 0;        int leftdepth &#x3D; getdepth(node-&gt;left);       &#x2F;&#x2F; 左        int rightdepth &#x3D; getdepth(node-&gt;right);     &#x2F;&#x2F; 右        int depth &#x3D; 1 + max(leftdepth, rightdepth); &#x2F;&#x2F; 中        return depth;    &#125;    int maxdepth(treenode* root) &#123;        return getdepth(root);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111.二叉树的最小深度"></a>111.二叉树的最小深度</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    int minDepth(TreeNode* root) &#123;        queue&lt;TreeNode*&gt; que;        long long res &#x3D; 0;        if(root!&#x3D;nullptr)que.push(root);        while(!que.empty())&#123;            int size&#x3D;que.size();            for(int i&#x3D;0;i&lt;size;i++)&#123;                if(!que.front()-&gt;left &amp;&amp; !que.front()-&gt;right)&#123;                    return res+1;                &#125;                if(que.front()-&gt;left)&#123;                    que.push(que.front()-&gt;left);                &#125;                if(que.front()-&gt;right)&#123;                    que.push(que.front()-&gt;right);                &#125;                que.pop();            &#125;            res++;        &#125;        return res;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230323092644112.png"></p><p>递归法</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    TreeNode* invertTree(TreeNode* root) &#123;        if (root &#x3D;&#x3D; NULL) return root;        swap(root-&gt;left, root-&gt;right);  &#x2F;&#x2F; 中        invertTree(root-&gt;left);         &#x2F;&#x2F; 左        invertTree(root-&gt;right);        &#x2F;&#x2F; 右        return root;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>迭代法</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    TreeNode* invertTree(TreeNode* root) &#123;        if (root &#x3D;&#x3D; NULL) return root;        stack&lt;TreeNode*&gt; st;        st.push(root);        while(!st.empty()) &#123;            TreeNode* node &#x3D; st.top();              &#x2F;&#x2F; 中            st.pop();            swap(node-&gt;left, node-&gt;right);            if(node-&gt;right) st.push(node-&gt;right);   &#x2F;&#x2F; 右            if(node-&gt;left) st.push(node-&gt;left);     &#x2F;&#x2F; 左        &#125;        return root;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230323092710551.png"></p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    bool compare(TreeNode* left,TreeNode* right)&#123;        if(left&#x3D;&#x3D;nullptr &amp;&amp; right&#x3D;&#x3D;nullptr)return true;        else if(left&#x3D;&#x3D;nullptr &amp;&amp; right!&#x3D;nullptr)return false;        else if(left!&#x3D;nullptr &amp;&amp; right&#x3D;&#x3D;nullptr)return false;        else if(left-&gt;val!&#x3D;right-&gt;val)return false;        else&#123;            return compare(left-&gt;left,right-&gt;right)&amp;&amp;compare(left-&gt;right,right-&gt;left);        &#125;    &#125;    bool isSymmetric(TreeNode* root) &#123;        if(root &#x3D;&#x3D; nullptr)return true;        return compare(root-&gt;left,root-&gt;right);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100.相同的树"></a>100.相同的树</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    bool compare(TreeNode* p, TreeNode* q)&#123;        if(p&#x3D;&#x3D;nullptr &amp;&amp; q&#x3D;&#x3D;nullptr)return true;        else if(p!&#x3D;nullptr &amp;&amp; q&#x3D;&#x3D;nullptr)return false;        else if(p&#x3D;&#x3D;nullptr &amp;&amp; q!&#x3D;nullptr)return false;        else if(p-&gt;val !&#x3D; q-&gt;val)return false;        else&#123;            return compare(p-&gt;left,q-&gt;left)&amp;&amp;compare(p-&gt;right,q-&gt;right);        &#125;    &#125;    bool isSameTree(TreeNode* p, TreeNode* q) &#123;        return compare(p, q);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="572-另一棵树的子树"><a href="#572-另一棵树的子树" class="headerlink" title="572.另一棵树的子树"></a>572.另一棵树的子树</h3><p>双递归，一递归判断是否相同，另一递归取左子树和右子树</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    bool compare(TreeNode* p, TreeNode* q)&#123;        if(p&#x3D;&#x3D;nullptr &amp;&amp; q&#x3D;&#x3D;nullptr)return true;        else if(p!&#x3D;nullptr &amp;&amp; q&#x3D;&#x3D;nullptr)return false;        else if(p&#x3D;&#x3D;nullptr &amp;&amp; q!&#x3D;nullptr)return false;        else if(p-&gt;val !&#x3D; q-&gt;val)return false;        else&#123;            return compare(p-&gt;left,q-&gt;left)&amp;&amp;compare(p-&gt;right,q-&gt;right);        &#125;    &#125;    bool isSubtree(TreeNode* root, TreeNode* subRoot) &#123;        if(root&#x3D;&#x3D;nullptr &amp;&amp; subRoot&#x3D;&#x3D;nullptr)return true;        else if(root!&#x3D;nullptr &amp;&amp; subRoot&#x3D;&#x3D;nullptr)return false;        else if(root&#x3D;&#x3D;nullptr &amp;&amp; subRoot!&#x3D;nullptr)return false;        return compare(root,subRoot)||isSubtree(root-&gt;left,subRoot)||isSubtree(root-&gt;right,subRoot);    &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="完美二叉树的节点个数"><a href="#完美二叉树的节点个数" class="headerlink" title="完美二叉树的节点个数"></a>完美二叉树的节点个数</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230323103318926.png"></p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    int countNodes(TreeNode* root) &#123;        queue&lt;TreeNode*&gt; que;        int res &#x3D; 0;        if(root&#x3D;&#x3D;nullptr)return res;        que.push(root);        while(!que.empty())&#123;            int size &#x3D; que.size();            for(int i&#x3D;0;i&lt;size;i++)&#123;                if(que.front()-&gt;left)que.push(que.front()-&gt;left);                if(que.front()-&gt;right)que.push(que.front()-&gt;right);                que.pop();                res++;            &#125;        &#125;        return res;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230323110924812.png"></p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    &#x2F;&#x2F; 返回以该节点为根节点的二叉树的高度，如果不是平衡二叉树了则返回-1    int getHeight(TreeNode* node) &#123;        if (node &#x3D;&#x3D; NULL) &#123;            return 0;        &#125;        int leftHeight &#x3D; getHeight(node-&gt;left);        if (leftHeight &#x3D;&#x3D; -1) return -1;        int rightHeight &#x3D; getHeight(node-&gt;right);        if (rightHeight &#x3D;&#x3D; -1) return -1;        return abs(leftHeight - rightHeight) &gt; 1 ? -1 : 1 + max(leftHeight, rightHeight);    &#125;    bool isBalanced(TreeNode* root) &#123;        return getHeight(root) &#x3D;&#x3D; -1 ? false : true;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二叉树的所有路径"><a href="#二叉树的所有路径" class="headerlink" title="二叉树的所有路径"></a>二叉树的所有路径</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230323113704725.png"></p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;private:    void traversal(TreeNode* cur, vector&lt;int&gt;&amp; path, vector&lt;string&gt;&amp; result) &#123;        path.push_back(cur-&gt;val); &#x2F;&#x2F; 中，中为什么写在这里，因为最后一个节点也要加入到path中         &#x2F;&#x2F; 这才到了叶子节点        if (cur-&gt;left &#x3D;&#x3D; NULL &amp;&amp; cur-&gt;right &#x3D;&#x3D; NULL) &#123;            string sPath;            for (int i &#x3D; 0; i &lt; path.size() - 1; i++) &#123;                sPath +&#x3D; to_string(path[i]);                sPath +&#x3D; &quot;-&gt;&quot;;            &#125;            sPath +&#x3D; to_string(path[path.size() - 1]);            result.push_back(sPath);            return;        &#125;        if (cur-&gt;left) &#123; &#x2F;&#x2F; 左             traversal(cur-&gt;left, path, result);            path.pop_back(); &#x2F;&#x2F; 回溯        &#125;        if (cur-&gt;right) &#123; &#x2F;&#x2F; 右            traversal(cur-&gt;right, path, result);            path.pop_back(); &#x2F;&#x2F; 回溯        &#125;    &#125;public:    vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123;        vector&lt;string&gt; result;        vector&lt;int&gt; path;        if (root &#x3D;&#x3D; NULL) return result;        traversal(root, path, result);        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="左子叶之和"><a href="#左子叶之和" class="headerlink" title="左子叶之和"></a>左子叶之和</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">sumOfLeftLeaves</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">sumOfLeftLeaves</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>root<span class="token operator">-></span>left<span class="token operator">-></span>left <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>root<span class="token operator">-></span>left<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            sum<span class="token operator">+=</span>root<span class="token operator">-></span>left<span class="token operator">-></span>val<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">sumOfLeftLeaves</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="找树最左边的值"><a href="#找树最左边的值" class="headerlink" title="找树最左边的值"></a>找树最左边的值</h2><p>递归法</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    int maxDepth &#x3D; INT_MIN;    int result;    void traversal(TreeNode* root, int depth) &#123;        if (root-&gt;left &#x3D;&#x3D; NULL &amp;&amp; root-&gt;right &#x3D;&#x3D; NULL) &#123;            if (depth &gt; maxDepth) &#123;                maxDepth &#x3D; depth;                result &#x3D; root-&gt;val;            &#125;            return;        &#125;        if (root-&gt;left) &#123;            depth++;            traversal(root-&gt;left, depth);            depth--; &#x2F;&#x2F; 回溯        &#125;        if (root-&gt;right) &#123;            depth++;            traversal(root-&gt;right, depth);            depth--; &#x2F;&#x2F; 回溯        &#125;        return;    &#125;    int findBottomLeftValue(TreeNode* root) &#123;        traversal(root, 0);        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>迭代法</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    int findBottomLeftValue(TreeNode* root) &#123;        queue&lt;TreeNode*&gt; que;        if (root !&#x3D; NULL) que.push(root);        int result &#x3D; 0;        while (!que.empty()) &#123;            int size &#x3D; que.size();            for (int i &#x3D; 0; i &lt; size; i++) &#123;                TreeNode* node &#x3D; que.front();                que.pop();                if (i &#x3D;&#x3D; 0) result &#x3D; node-&gt;val; &#x2F;&#x2F; 记录最后一行第一个元素                if (node-&gt;left) que.push(node-&gt;left);                if (node-&gt;right) que.push(node-&gt;right);            &#125;        &#125;        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a>路径总和</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230324143621222.png"></p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    bool hasPathSum(TreeNode* root, int sum) &#123;        if (root&#x3D;&#x3D;nullptr) return false;        if (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; sum &#x3D;&#x3D; root-&gt;val) &#123;            return true;        &#125;        return hasPathSum(root-&gt;left, sum - root-&gt;val) || hasPathSum(root-&gt;right, sum - root-&gt;val);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="路径总和II"><a href="#路径总和II" class="headerlink" title="路径总和II"></a>路径总和II</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230324144315974.png"></p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;private:    vector&lt;vector&lt;int&gt;&gt; result;    vector&lt;int&gt; path;    &#x2F;&#x2F; 递归函数不需要返回值，因为我们要遍历整个树    void traversal(TreeNode* cur, int count) &#123;        if (!cur-&gt;left &amp;&amp; !cur-&gt;right &amp;&amp; count &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 遇到了叶子节点且找到了和为sum的路径            result.push_back(path);            return;        &#125;        if (!cur-&gt;left &amp;&amp; !cur-&gt;right) return ; &#x2F;&#x2F; 遇到叶子节点而没有找到合适的边，直接返回        if (cur-&gt;left) &#123; &#x2F;&#x2F; 左 （空节点不遍历）            path.push_back(cur-&gt;left-&gt;val);            traversal(cur-&gt;left, count-cur-&gt;left-&gt;val);    &#x2F;&#x2F; 递归            path.pop_back();                &#x2F;&#x2F; 回溯        &#125;        if (cur-&gt;right) &#123; &#x2F;&#x2F; 右 （空节点不遍历）            path.push_back(cur-&gt;right-&gt;val);            traversal(cur-&gt;right, count-cur-&gt;right-&gt;val);   &#x2F;&#x2F; 递归            path.pop_back();                &#x2F;&#x2F; 回溯        &#125;        return ;    &#125;public:    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) &#123;        if (root &#x3D;&#x3D; nullptr) return result;        path.push_back(root-&gt;val); &#x2F;&#x2F; 把根节点放进路径        traversal(root, sum - root-&gt;val);        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="从中序与后序遍历序列构造二叉树"><a href="#从中序与后序遍历序列构造二叉树" class="headerlink" title="从中序与后序遍历序列构造二叉树"></a>从中序与后序遍历序列构造二叉树</h2><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;private:    TreeNode* traversal (vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123;        if (postorder.size() &#x3D;&#x3D; 0) return NULL;        &#x2F;&#x2F; 后序遍历数组最后一个元素，就是当前的中间节点        int rootValue &#x3D; postorder[postorder.size() - 1];        TreeNode* root &#x3D; new TreeNode(rootValue);        &#x2F;&#x2F; 叶子节点        if (postorder.size() &#x3D;&#x3D; 1) return root;        &#x2F;&#x2F; 找到中序遍历的切割点        int delimiterIndex;        for (delimiterIndex &#x3D; 0; delimiterIndex &lt; inorder.size(); delimiterIndex++) &#123;            if (inorder[delimiterIndex] &#x3D;&#x3D; rootValue) break;        &#125;        &#x2F;&#x2F; 切割中序数组        &#x2F;&#x2F; 左闭右开区间：[0, delimiterIndex)        vector&lt;int&gt; leftInorder(inorder.begin(), inorder.begin() + delimiterIndex);        &#x2F;&#x2F; [delimiterIndex + 1, end)        vector&lt;int&gt; rightInorder(inorder.begin() + delimiterIndex + 1, inorder.end() );        &#x2F;&#x2F; postorder 舍弃末尾元素        postorder.resize(postorder.size() - 1);        &#x2F;&#x2F; 切割后序数组        &#x2F;&#x2F; 依然左闭右开，注意这里使用了左中序数组大小作为切割点        &#x2F;&#x2F; [0, leftInorder.size)        vector&lt;int&gt; leftPostorder(postorder.begin(), postorder.begin() + leftInorder.size());        &#x2F;&#x2F; [leftInorder.size(), end)        vector&lt;int&gt; rightPostorder(postorder.begin() + leftInorder.size(), postorder.end());        root-&gt;left &#x3D; traversal(leftInorder, leftPostorder);        root-&gt;right &#x3D; traversal(rightInorder, rightPostorder);        return root;    &#125;public:    TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123;        if (inorder.size() &#x3D;&#x3D; 0 || postorder.size() &#x3D;&#x3D; 0) return NULL;        return traversal(inorder, postorder);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="最大二叉树"><a href="#最大二叉树" class="headerlink" title="最大二叉树"></a>最大二叉树</h2><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;private:    &#x2F;&#x2F; 在左闭右开区间[left, right)，构造二叉树    TreeNode* traversal(vector&lt;int&gt;&amp; nums, int left, int right) &#123;        if (left &gt;&#x3D; right) return nullptr;        &#x2F;&#x2F; 分割点下标：maxValueIndex        int maxValueIndex &#x3D; left;        for (int i &#x3D; left + 1; i &lt; right; ++i) &#123;            if (nums[i] &gt; nums[maxValueIndex]) maxValueIndex &#x3D; i;        &#125;        TreeNode* root &#x3D; new TreeNode(nums[maxValueIndex]);        &#x2F;&#x2F; 左闭右开：[left, maxValueIndex)        root-&gt;left &#x3D; traversal(nums, left, maxValueIndex);        &#x2F;&#x2F; 左闭右开：[maxValueIndex + 1, right)        root-&gt;right &#x3D; traversal(nums, maxValueIndex + 1, right);        return root;    &#125;public:    TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) &#123;        return traversal(nums, 0, nums.size());    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h2><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) &#123;        if (t1 &#x3D;&#x3D; NULL) return t2;        if (t2 &#x3D;&#x3D; NULL) return t1;        &#x2F;&#x2F; 重新定义新的节点，不修改原有两个树的结构        TreeNode* root &#x3D; new TreeNode(0);        root-&gt;val &#x3D; t1-&gt;val + t2-&gt;val;        root-&gt;left &#x3D; mergeTrees(t1-&gt;left, t2-&gt;left);        root-&gt;right &#x3D; mergeTrees(t1-&gt;right, t2-&gt;right);        return root;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我的shitmountain</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) &#123;        if(!root1 &amp;&amp; !root2)return nullptr;        if(root1&#x3D;&#x3D;nullptr)root1&#x3D;node;        if(root2&#x3D;&#x3D;nullptr)root2&#x3D;node;        TreeNode* root &#x3D; new TreeNode(root1-&gt;val+root2-&gt;val);         if(root1-&gt;left &amp;&amp; root2-&gt;left)&#123;            root-&gt;left&#x3D;mergeTrees(root1-&gt;left,root2-&gt;left);            &#125;        if(root1-&gt;left  &amp;&amp; !root2-&gt;left)&#123;            root-&gt;left&#x3D;mergeTrees(root1-&gt;left,node);        &#125;        if(!root1-&gt;left  &amp;&amp; root2-&gt;left)&#123;            root-&gt;left&#x3D;mergeTrees(node,root2-&gt;left);        &#125;        if(root1-&gt;right &amp;&amp; root2-&gt;right)&#123;            root-&gt;right&#x3D;mergeTrees(root1-&gt;right,root2-&gt;right);        &#125;        if(root1-&gt;right  &amp;&amp; !root2-&gt;right)&#123;            root-&gt;right&#x3D;mergeTrees(root1-&gt;right,node);        &#125;        if(!root1-&gt;right  &amp;&amp; root2-&gt;right)&#123;            root-&gt;right&#x3D;mergeTrees(node,root2-&gt;right);        &#125;        return root;    &#125;private:    TreeNode* node &#x3D; new TreeNode(0);&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二叉搜索树中的搜索"><a href="#二叉搜索树中的搜索" class="headerlink" title="二叉搜索树中的搜索"></a>二叉搜索树中的搜索</h2><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    TreeNode* searchBST(TreeNode* root, int val) &#123;        if (root &#x3D;&#x3D; NULL || root-&gt;val &#x3D;&#x3D; val) return root;        cout&lt;&lt;root-&gt;val&lt;&lt;&#39; &#39;;        TreeNode* result &#x3D; NULL;        if (root-&gt;val &gt; val) result &#x3D; searchBST(root-&gt;left, val);        if (root-&gt;val &lt; val) result &#x3D; searchBST(root-&gt;right, val);        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h2><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;private:    vector&lt;int&gt; vec;    void traversal(TreeNode* root) &#123;        if (root &#x3D;&#x3D; NULL) return;        traversal(root-&gt;left);        vec.push_back(root-&gt;val); &#x2F;&#x2F; 将二叉搜索树转换为有序数组        traversal(root-&gt;right);    &#125;public:    bool isValidBST(TreeNode* root) &#123;        vec.clear(); &#x2F;&#x2F; 不加这句在leetcode上也可以过，但最好加上        traversal(root);        for (int i &#x3D; 1; i &lt; vec.size(); i++) &#123;            &#x2F;&#x2F; 注意要小于等于，搜索树里不能有相同元素            if (vec[i] &lt;&#x3D; vec[i - 1]) return false;        &#125;        return true;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二叉搜索树的最小绝对差"><a href="#二叉搜索树的最小绝对差" class="headerlink" title="二叉搜索树的最小绝对差"></a>二叉搜索树的最小绝对差</h2><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;private:vector&lt;int&gt; vec;void traversal(TreeNode* root) &#123;    if (root &#x3D;&#x3D; NULL) return;    traversal(root-&gt;left);    vec.push_back(root-&gt;val); &#x2F;&#x2F; 将二叉搜索树转换为有序数组    traversal(root-&gt;right);&#125;public:    int getMinimumDifference(TreeNode* root) &#123;        vec.clear();        traversal(root);        if (vec.size() &lt; 2) return 0;        int result &#x3D; INT_MAX;        for (int i &#x3D; 1; i &lt; vec.size(); i++) &#123; &#x2F;&#x2F; 统计有序数组的最小差值            result &#x3D; min(result, vec[i] - vec[i-1]);        &#125;        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二叉搜索树中的众数"><a href="#二叉搜索树中的众数" class="headerlink" title="二叉搜索树中的众数"></a>二叉搜索树中的众数</h2><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    void traversal(TreeNode* root)&#123;        if(root)&#123;            traversal(root-&gt;left);            vec.push_back(root-&gt;val);            traversal(root-&gt;right);        &#125;    &#125;    vector&lt;int&gt; findMode(TreeNode* root) &#123;        if(root&#x3D;&#x3D;nullptr)return res;        traversal(root);        unordered_map&lt;int,int&gt; mp;        for(auto v:vec)&#123;            mp[v]++;        &#125;        for(auto [key,value]:mp)&#123;            maxRes &#x3D; max(maxRes,value);        &#125;        for(auto [key,value]:mp)&#123;            if(value&#x3D;&#x3D;maxRes)res.push_back(key);        &#125;                return res;    &#125;private:    vector&lt;int&gt; vec;    vector&lt;int&gt; res;    int maxRes;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h2><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;        if (root &#x3D;&#x3D; q || root &#x3D;&#x3D; p || root &#x3D;&#x3D; NULL) return root;        TreeNode* left &#x3D; lowestCommonAncestor(root-&gt;left, p, q);        TreeNode* right &#x3D; lowestCommonAncestor(root-&gt;right, p, q);        if (left !&#x3D; NULL &amp;&amp; right !&#x3D; NULL) return root;        if (left &#x3D;&#x3D; NULL &amp;&amp; right !&#x3D; NULL) return right;        else if (left !&#x3D; NULL &amp;&amp; right &#x3D;&#x3D; NULL) return left;        else  &#123; &#x2F;&#x2F;  (left &#x3D;&#x3D; NULL &amp;&amp; right &#x3D;&#x3D; NULL)            return NULL;        &#125;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码随想录_栈与队列</title>
      <link href="/2023/03/22/Learn/LeetCode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
      <url>/2023/03/22/Learn/LeetCode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h1><h2 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230322152512657.png"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>在push数据的时候，只要数据放进输入栈就好，<strong>但在pop的时候，操作就复杂一些，输出栈如果为空，就把进栈数据全部导入进来（注意是全部导入）</strong>，再从出栈弹出数据，如果输出栈不为空，则直接从出栈弹出数据就可以了。</p><p>最后如何判断队列为空呢？<strong>如果进栈和出栈都为空的话，说明模拟的队列为空了。</strong></p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class MyQueue &#123;public:    stack&lt;int&gt; stIn;    stack&lt;int&gt; stOut;    MyQueue() &#123;    &#125;        void push(int x) &#123;        stIn.push(x);    &#125;        int pop() &#123;        if(stOut.empty())&#123;            while(!stIn.empty())&#123;                stOut.push(stIn.top());                stIn.pop();            &#125;        &#125;        int result &#x3D; stOut.top();        stOut.pop();        return result;    &#125;        int peek() &#123;        int res &#x3D; this-&gt;pop();        stOut.push(res);        return res;    &#125;        bool empty() &#123;        return stIn.empty() &amp;&amp; stOut.empty();    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230322152701852.png"></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p><strong>用两个队列que1和que2实现队列的功能，que2其实完全就是一个备份的作用</strong>，把que1最后面的元素以外的元素都备份到que2，然后弹出最后面的元素，再把其他元素从que2导回que1。</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class MyStack &#123;public:    queue&lt;int&gt; que1;    queue&lt;int&gt; que2;    MyStack() &#123;    &#125;        void push(int x) &#123;        que1.push(x);    &#125;        int pop() &#123;        int size &#x3D; que1.size();        size--;        while(size--)&#123;            que2.push(que1.front());            que1.pop();        &#125;        int result &#x3D; que1.front();        que1.pop();        que1 &#x3D; que2;        while(!que2.empty())&#123;            que2.pop();        &#125;        return result;    &#125;        int top() &#123;        return que1.back();    &#125;        bool empty() &#123;        return que1.empty();    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只是用一个队列</p><pre class="line-numbers language-none"><code class="language-none">class MyStack &#123;public:    queue&lt;int&gt; que;    &#x2F;** Initialize your data structure here. *&#x2F;    MyStack() &#123;    &#125;    &#x2F;** Push element x onto stack. *&#x2F;    void push(int x) &#123;        que.push(x);    &#125;    &#x2F;** Removes the element on top of the stack and returns that element. *&#x2F;    int pop() &#123;        int size &#x3D; que.size();        size--;        while (size--) &#123; &#x2F;&#x2F; 将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部            que.push(que.front());            que.pop();        &#125;        int result &#x3D; que.front(); &#x2F;&#x2F; 此时弹出的元素顺序就是栈的顺序了        que.pop();        return result;    &#125;    &#x2F;** Get the top element. *&#x2F;    int top() &#123;        return que.back();    &#125;    &#x2F;** Returns whether the stack is empty. *&#x2F;    bool empty() &#123;        return que.empty();    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230322160335345.png"></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>第一种情况：已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return false</p><p>第二种情况：遍历字符串匹配的过程中，发现栈里没有要匹配的字符。所以return false</p><p>第三种情况：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号return false</p><p>那么什么时候说明左括号和右括号全都匹配了呢，就是字符串遍历完之后，栈是空的，就说明全都匹配了。</p><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    bool isValid(string s) &#123;        if (s.size() % 2 !&#x3D; 0) return false; &#x2F;&#x2F; 如果s的长度为奇数，一定不符合要求        stack&lt;char&gt; st;        for (int i &#x3D; 0; i &lt; s.size(); i++) &#123;            if (s[i] &#x3D;&#x3D; &#39;(&#39;) st.push(&#39;)&#39;);            else if (s[i] &#x3D;&#x3D; &#39;&#123;&#39;) st.push(&#39;&#125;&#39;);            else if (s[i] &#x3D;&#x3D; &#39;[&#39;) st.push(&#39;]&#39;);            &#x2F;&#x2F; 第三种情况：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号 return false            &#x2F;&#x2F; 第二种情况：遍历字符串匹配的过程中，发现栈里没有我们要匹配的字符。所以return false            else if (st.empty() || st.top() !&#x3D; s[i]) return false;            else st.pop(); &#x2F;&#x2F; st.top() 与 s[i]相等，栈弹出元素        &#125;        &#x2F;&#x2F; 第一种情况：此时我们已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return false，否则就return true        return st.empty();    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="删除字符串中的所有相邻重复项"><a href="#删除字符串中的所有相邻重复项" class="headerlink" title="删除字符串中的所有相邻重复项"></a>删除字符串中的所有相邻重复项</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230322162132433.png"></p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>用栈解决</p><h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><p>此处我犯了一个错误，把st.empty() || s[i] !&#x3D; st.top()颠倒过来写了，编译器报错。因为栈为空的情况下去找top值是异常的。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    string removeDuplicates(string s) &#123;        stack&lt;char&gt; st;        for(int i&#x3D;0;i&lt;s.size();i++)&#123;            if(st.empty() || s[i] !&#x3D; st.top())&#123;                st.push(s[i]);            &#125;            else&#123;                st.pop();            &#125;        &#125;        string ans &#x3D; &quot;&quot;;        while(!st.empty())&#123;            ans +&#x3D; st.top();            st.pop();        &#125;        reverse(ans.begin() , ans.end());        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="逆波兰表达式求值"><a href="#逆波兰表达式求值" class="headerlink" title="逆波兰表达式求值"></a>逆波兰表达式求值</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230322164109975.png"></p><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>相信看完动画大家应该知道，这和删除字符串中的所有相邻重复项是差不错的，只不过本题不要相邻元素做消除了，而是做运算。</p><h3 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;        &#x2F;&#x2F; 力扣修改了后台测试数据，需要用longlong        stack&lt;long long&gt; st;         for (int i &#x3D; 0; i &lt; tokens.size(); i++) &#123;            if (tokens[i] &#x3D;&#x3D; &quot;+&quot; || tokens[i] &#x3D;&#x3D; &quot;-&quot; || tokens[i] &#x3D;&#x3D; &quot;*&quot; || tokens[i] &#x3D;&#x3D; &quot;&#x2F;&quot;) &#123;                long long num1 &#x3D; st.top();                st.pop();                long long num2 &#x3D; st.top();                st.pop();                if (tokens[i] &#x3D;&#x3D; &quot;+&quot;) st.push(num2 + num1);                if (tokens[i] &#x3D;&#x3D; &quot;-&quot;) st.push(num2 - num1);                if (tokens[i] &#x3D;&#x3D; &quot;*&quot;) st.push(num2 * num1);                if (tokens[i] &#x3D;&#x3D; &quot;&#x2F;&quot;) st.push(num2 &#x2F; num1);            &#125; else &#123;                st.push(stoll(tokens[i]));            &#125;        &#125;        int result &#x3D; st.top();        st.pop(); &#x2F;&#x2F; 把栈里最后一个元素弹出（其实不弹出也没事）        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a>滑动窗口最大值</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230322165724171.png"></p><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>单调队列</p><h3 id="Code-5"><a href="#Code-5" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;        int n &#x3D; nums.size();        deque&lt;int&gt; q;        for (int i &#x3D; 0; i &lt; k; ++i) &#123;            while (!q.empty() &amp;&amp; nums[i] &gt;&#x3D; nums[q.back()]) &#123;                q.pop_back();            &#125;            q.push_back(i);        &#125;        vector&lt;int&gt; ans &#x3D; &#123;nums[q.front()]&#125;;        for (int i &#x3D; k; i &lt; n; ++i) &#123;            while (!q.empty() &amp;&amp; nums[i] &gt;&#x3D; nums[q.back()]) &#123;                q.pop_back();            &#125;            q.push_back(i);            while (q.front() &lt;&#x3D; i - k) &#123;                q.pop_front();            &#125;            ans.push_back(nums[q.front()]);        &#125;        return ans;    &#125;&#125;;、<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="前K个高频元素"><a href="#前K个高频元素" class="headerlink" title="前K个高频元素"></a>前K个高频元素</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230322173057450.png"></p><h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>用小顶堆，因为要统计最大前k个元素，只有小顶堆每次将最小的元素弹出，最后小顶堆里积累的才是前k个最大元素。</p><h3 id="Code-6"><a href="#Code-6" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 时间复杂度：O(nlogk)&#x2F;&#x2F; 空间复杂度：O(n)class Solution &#123;public:    &#x2F;&#x2F; 小顶堆    class mycomparison &#123;    public:        bool operator()(const pair&lt;int, int&gt;&amp; lhs, const pair&lt;int, int&gt;&amp; rhs) &#123;            return lhs.second &gt; rhs.second;        &#125;    &#125;;    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;        &#x2F;&#x2F; 要统计元素出现频率        unordered_map&lt;int, int&gt; map; &#x2F;&#x2F; map&lt;nums[i],对应出现的次数&gt;        for (int i &#x3D; 0; i &lt; nums.size(); i++) &#123;            map[nums[i]]++;        &#125;        &#x2F;&#x2F; 对频率排序        &#x2F;&#x2F; 定义一个小顶堆，大小为k        priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, mycomparison&gt; pri_que;        &#x2F;&#x2F; 用固定大小为k的小顶堆，扫面所有频率的数值        for (unordered_map&lt;int, int&gt;::iterator it &#x3D; map.begin(); it !&#x3D; map.end(); it++) &#123;            pri_que.push(*it);            if (pri_que.size() &gt; k) &#123; &#x2F;&#x2F; 如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k                pri_que.pop();            &#125;        &#125;        &#x2F;&#x2F; 找出前K个高频元素，因为小顶堆先弹出的是最小的，所以倒序来输出到数组        vector&lt;int&gt; result(k);        for (int i &#x3D; k - 1; i &gt;&#x3D; 0; i--) &#123;            result[i] &#x3D; pri_que.top().first;            pri_que.pop();        &#125;        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码随想录_字符串</title>
      <link href="/2023/03/21/Learn/LeetCode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2023/03/21/Learn/LeetCode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230321120539106.png"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>反转字符串依然是使用双指针的方法</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    void reverseString(vector&lt;char&gt;&amp; s) &#123;        for (int i &#x3D; 0, j &#x3D; s.size() - 1; i &lt; s.size()&#x2F;2; i++, j--) &#123;            swap(s[i],s[j]);        &#125;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="反转字符串II"><a href="#反转字符串II" class="headerlink" title="反转字符串II"></a>反转字符串II</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230321120702337.png"></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>在遍历字符串的过程中，只要让 i +&#x3D; (2 * k)，i 每次移动 2 * k 就可以了，然后判断是否需要有反转的区间。</p><p>因为要找的也就是每2 * k 区间的起点，这样写，程序会高效很多。</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    string reverseStr(string s, int k) &#123;        for (int i &#x3D; 0; i &lt; s.size(); i +&#x3D; (2 * k)) &#123;            &#x2F;&#x2F; 1. 每隔 2k 个字符的前 k 个字符进行反转            &#x2F;&#x2F; 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符            if (i + k &lt;&#x3D; s.size()) &#123;                reverse(s.begin() + i, s.begin() + i + k );            &#125; else &#123;                &#x2F;&#x2F; 3. 剩余字符少于 k 个，则将剩余字符全部反转。                reverse(s.begin() + i, s.end());            &#125;        &#125;        return s;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230321121133151.png"></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>首先扩充数组到每个空格替换成”%20”之后的大小。然后从后向前替换空格，也就是双指针法。</p><p><strong>其实很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。</strong></p><p>这么做有两个好处：</p><ol><li>不用申请新数组。</li><li>从后向前填充元素，避免了从前向后填充元素时，每次添加元素都要将添加元素之后的所有元素向后移动的问题。</li></ol><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    string replaceSpace(string s) &#123;        int count &#x3D; 0; &#x2F;&#x2F; 统计空格的个数        int sOldSize &#x3D; s.size();        for (int i &#x3D; 0; i &lt; s.size(); i++) &#123;            if (s[i] &#x3D;&#x3D; &#39; &#39;) &#123;                count++;            &#125;        &#125;        &#x2F;&#x2F; 扩充字符串s的大小，也就是每个空格替换成&quot;%20&quot;之后的大小        s.resize(s.size() + count * 2);        int sNewSize &#x3D; s.size();        &#x2F;&#x2F; 从后先前将空格替换为&quot;%20&quot;        for (int i &#x3D; sNewSize - 1, j &#x3D; sOldSize - 1; j &lt; i; i--, j--) &#123;            if (s[j] !&#x3D; &#39; &#39;) &#123;                s[i] &#x3D; s[j];            &#125; else &#123;                s[i] &#x3D; &#39;0&#39;;                s[i - 1] &#x3D; &#39;2&#39;;                s[i - 2] &#x3D; &#39;%&#39;;                i -&#x3D; 2;            &#125;        &#125;        return s;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="翻转字符串里的单词"><a href="#翻转字符串里的单词" class="headerlink" title="翻转字符串里的单词"></a>翻转字符串里的单词</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230321121905747.png"></p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>将整个字符串都反转过来，那么单词的顺序指定是倒序了，只不过单词本身也倒序了，那么再把单词反转一下，单词不就正过来了。</p><h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    void reverse(string&amp; s, int start, int end)&#123; &#x2F;&#x2F;翻转，区间写法：左闭右闭 []        for (int i &#x3D; start, j &#x3D; end; i &lt; j; i++, j--) &#123;            swap(s[i], s[j]);        &#125;    &#125;    void removeExtraSpaces(string&amp; s) &#123;&#x2F;&#x2F;去除所有空格并在相邻单词之间添加空格, 快慢指针。        int slow &#x3D; 0;   &#x2F;&#x2F;整体思想参考https:&#x2F;&#x2F;programmercarl.com&#x2F;0027.移除元素.html        for (int i &#x3D; 0; i &lt; s.size(); ++i) &#123; &#x2F;&#x2F;            if (s[i] !&#x3D; &#39; &#39;) &#123; &#x2F;&#x2F;遇到非空格就处理，即删除所有空格。                if (slow !&#x3D; 0) s[slow++] &#x3D; &#39; &#39;; &#x2F;&#x2F;手动控制空格，给单词之间添加空格。slow !&#x3D; 0说明不是第一个单词，需要在单词前添加空格。                while (i &lt; s.size() &amp;&amp; s[i] !&#x3D; &#39; &#39;) &#123; &#x2F;&#x2F;补上该单词，遇到空格说明单词结束。                    s[slow++] &#x3D; s[i++];                &#125;            &#125;        &#125;        s.resize(slow); &#x2F;&#x2F;slow的大小即为去除多余空格后的大小。    &#125;    string reverseWords(string s) &#123;        removeExtraSpaces(s); &#x2F;&#x2F;去除多余空格，保证单词之间之只有一个空格，且字符串首尾没空格。        reverse(s, 0, s.size() - 1);        int start &#x3D; 0; &#x2F;&#x2F;removeExtraSpaces后保证第一个单词的开始下标一定是0。        for (int i &#x3D; 0; i &lt;&#x3D; s.size(); ++i) &#123;            if (i &#x3D;&#x3D; s.size() || s[i] &#x3D;&#x3D; &#39; &#39;) &#123; &#x2F;&#x2F;到达空格或者串尾，说明一个单词结束。进行翻转。                reverse(s, start, i - 1); &#x2F;&#x2F;翻转，注意是左闭右闭 []的翻转。                start &#x3D; i + 1; &#x2F;&#x2F;更新下一个单词的开始下标start            &#125;        &#125;        return s;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a>左旋转字符串</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230321145905358.png"></p><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><ol><li>反转区间为前n的子串</li><li>反转区间为n到末尾的子串</li><li>反转整个字符串</li></ol><h3 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    string reverseLeftWords(string s, int n) &#123;        reverse(s.begin(),s.begin()+n);        reverse(s.begin()+n,s.end());        reverse(s.begin(),s.end());        return s;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="实现strStr"><a href="#实现strStr" class="headerlink" title="实现strStr()"></a>实现strStr()</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230321150814153.png"></p><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>KMP：<a href="https://www.bilibili.com/video/BV1PD4y1o7nd/">帮你把KMP算法学个通透！（理论篇）_哔哩哔哩_bilibili</a></p><h3 id="Code-5"><a href="#Code-5" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    void getNext(int* next, const string&amp; s) &#123;        int j &#x3D; 0;        next[0] &#x3D; 0;        for(int i &#x3D; 1; i &lt; s.size(); i++) &#123;            while (j &gt; 0 &amp;&amp; s[i] !&#x3D; s[j]) &#123;                j &#x3D; next[j - 1];            &#125;            if (s[i] &#x3D;&#x3D; s[j]) &#123;                j++;            &#125;            next[i] &#x3D; j;        &#125;    &#125;    int strStr(string haystack, string needle) &#123;        if (needle.size() &#x3D;&#x3D; 0) &#123;            return 0;        &#125;        int next[needle.size()];        getNext(next, needle);        int j &#x3D; 0;        for (int i &#x3D; 0; i &lt; haystack.size(); i++) &#123;            while(j &gt; 0 &amp;&amp; haystack[i] !&#x3D; needle[j]) &#123;                j &#x3D; next[j - 1];            &#125;            if (haystack[i] &#x3D;&#x3D; needle[j]) &#123;                j++;            &#125;            if (j &#x3D;&#x3D; needle.size() ) &#123;                return (i - needle.size() + 1);            &#125;        &#125;        return -1;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="重复的子字符串"><a href="#重复的子字符串" class="headerlink" title="重复的子字符串"></a>重复的子字符串</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230321164639189.png"></p><h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p><strong>动态匹配</strong>：</p><p>判断字符串s是否由重复子串组成，只要两个s拼接在一起，里面还出现一个s的话，就说明是由重复子串组成。</p><p>当然，我们在判断 s + s 拼接的字符串里是否出现一个s的的时候，<strong>要刨除 s + s 的首字符和尾字符</strong>，这样避免在s+s中搜索出原来的s，我们要搜索的是中间拼接出来的s。</p><p><strong>KMP：</strong></p><p>数组长度减去最长相同前后缀的长度相当于是第一个周期的长度，也就是一个周期的长度，如果这个周期可以被整除，就说明整个数组就是这个周期的循环。</p><h3 id="Code-6"><a href="#Code-6" class="headerlink" title="Code"></a>Code</h3><h4 id="动态匹配"><a href="#动态匹配" class="headerlink" title="动态匹配"></a>动态匹配</h4><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    bool repeatedSubstringPattern(string s) &#123;        string t &#x3D; s + s;        t.erase(t.begin()); t.erase(t.end() - 1); &#x2F;&#x2F; 掐头去尾        if (t.find(s) !&#x3D; std::string::npos) return true; &#x2F;&#x2F; r        return false;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h4><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    void getNext (int* next, const string&amp; s)&#123;        next[0] &#x3D; 0;        int j &#x3D; 0;        for(int i &#x3D; 1;i &lt; s.size(); i++)&#123;            while(j &gt; 0 &amp;&amp; s[i] !&#x3D; s[j]) &#123;                j &#x3D; next[j - 1];            &#125;            if(s[i] &#x3D;&#x3D; s[j]) &#123;                j++;            &#125;            next[i] &#x3D; j;        &#125;    &#125;    bool repeatedSubstringPattern (string s) &#123;        if (s.size() &#x3D;&#x3D; 0) &#123;            return false;        &#125;        int next[s.size()];        getNext(next, s);        int len &#x3D; s.size();        if (next[len - 1] !&#x3D; 0 &amp;&amp; len % (len - (next[len - 1] )) &#x3D;&#x3D; 0) &#123;            return true;        &#125;        return false;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码随想录_哈希表</title>
      <link href="/2023/03/21/Learn/LeetCode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
      <url>/2023/03/21/Learn/LeetCode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h2 id="有效的字母异位词"><a href="#有效的字母异位词" class="headerlink" title="有效的字母异位词"></a>有效的字母异位词</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230321095508202.png"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>26个字母定义一个数组大小为26，每个字母对应的索引号位置+1，如果最后遍历完为0，则true</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    bool isAnagram(string s, string t) &#123;        int record[26]&#x3D;&#123;0&#125;;        for(int i&#x3D;0;i&lt;s.size();i++)&#123;            record[s[i]-&#39;a&#39;]++;        &#125;        for(int i&#x3D;0;i&lt;t.size();i++)&#123;            record[t[i]-&#39;a&#39;]--;            &#125;        for(int i&#x3D;0;i&lt;26;i++)&#123;            if(record[i]!&#x3D;0)&#123;                return false;            &#125;        &#125;        return true;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="两个数组的交集"><a href="#两个数组的交集" class="headerlink" title="两个数组的交集"></a>两个数组的交集</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230321101028340.png"></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>但是要注意，使用数组来做哈希的题目，是因为题目都限制了数值的大小。而这道题目没有限制数值的大小，就无法使用数组来做哈希表了。而且如果哈希值<strong>比较少、特别分散、跨度非常大</strong>，使用数组就<strong>造成空间的极大浪费</strong>。std::set和std::multiset底层实现都是红黑树，std::unordered_set的底层实现是哈希表， 使用<strong>unordered_set</strong>读写效率是最高的，并不需要对数据进行排序，而且还不要让数据重复，所以选择unordered_set。</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        unordered_set&lt;int&gt; result_set;        unordered_set&lt;int&gt; nums_set(nums1.begin(),nums1.end());        for(auto num:nums2)&#123;            if(nums_set.find(num) !&#x3D; nums_set.end())&#123;                result_set.insert(num);            &#125;        &#125;        return vector&lt;int&gt;(result_set.begin(),result_set.end());    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="快乐数"><a href="#快乐数" class="headerlink" title="快乐数"></a>快乐数</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230321101046455.png"></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>这道题目使用哈希法，来判断这个sum是否重复出现，如果重复了就是return false， 否则一直找到sum为1为止。</p><p>判断sum是否重复出现就可以使用unordered_set。</p><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    &#x2F;&#x2F; 取数值各个位上的单数之和    int getSum(int n) &#123;        int sum &#x3D; 0;        while (n) &#123;            sum +&#x3D; (n % 10) * (n % 10);            n &#x2F;&#x3D; 10;        &#125;        return sum;    &#125;    bool isHappy(int n) &#123;        unordered_set&lt;int&gt; set;        while(1) &#123;            int sum &#x3D; getSum(n);            if (sum &#x3D;&#x3D; 1) &#123;                return true;            &#125;            &#x2F;&#x2F; 如果这个sum曾经出现过，说明已经陷入了无限循环了，立刻return false            if (set.find(sum) !&#x3D; set.end()) &#123;                return false;            &#125; else &#123;                set.insert(sum);            &#125;            n &#x3D; sum;        &#125;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230321101829814.png"></p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>在遍历数组的时候，只需要向map去查询是否有和目前遍历元素匹配的数值，如果有，就找到的匹配对，如果没有，就把目前遍历的元素放进map中，因为map存放的就是我们访问过的元素。</p><h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;        unordered_map&lt;int,int&gt; map;        for(int i&#x3D;0;i&lt;nums.size();i++)&#123;            auto iter &#x3D; map.find(target-nums[i]);            if(iter  !&#x3D; map.end())&#123;                return &#123;iter-&gt;second,i&#125;;            &#125;            map.insert(pair&lt;int,int&gt;(nums[i],i));        &#125;        return &#123;&#125;;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四数相加II"><a href="#四数相加II" class="headerlink" title="四数相加II"></a>四数相加II</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230321102853225.png"></p><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><ol><li>首先定义 一个unordered_map，key放a和b两数之和，value 放a和b两数之和出现的次数。</li><li>遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中。</li><li>定义int变量count，用来统计 a+b+c+d &#x3D; 0 出现的次数。</li><li>在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。</li><li>最后返回统计值 count 就可以了</li></ol><h3 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    int fourSumCount(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B, vector&lt;int&gt;&amp; C, vector&lt;int&gt;&amp; D) &#123;        unordered_map&lt;int, int&gt; umap; &#x2F;&#x2F;key:a+b的数值，value:a+b数值出现的次数        &#x2F;&#x2F; 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中        for (int a : A) &#123;            for (int b : B) &#123;                umap[a + b]++;            &#125;        &#125;        int count &#x3D; 0; &#x2F;&#x2F; 统计a+b+c+d &#x3D; 0 出现的次数        &#x2F;&#x2F; 在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就把map中key对应的value也就是出现次数统计出来。        for (int c : C) &#123;            for (int d : D) &#123;                if (umap.find(0 - (c + d)) !&#x3D; umap.end()) &#123;                    count +&#x3D; umap[0 - (c + d)];                &#125;            &#125;        &#125;        return count;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="赎金信"><a href="#赎金信" class="headerlink" title="赎金信"></a>赎金信</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230321103717657.png"></p><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>因为题目所只有小写字母，那可以采用空间换取时间的哈希策略， 用一个长度为26的数组还记录magazine里字母出现的次数。</p><p>然后再用ransomNote去验证这个数组是否包含了ransomNote所需要的所有字母。</p><p><strong>在本题的情况下，使用map的空间消耗要比数组大一些的，因为map要维护红黑树或者哈希表，而且还要做哈希函数，是费时的！数据量大的话就能体现出来差别了。 所以数组更加简单直接有效！</strong></p><h3 id="Code-5"><a href="#Code-5" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    bool canConstruct(string ransomNote, string magazine) &#123;        int record[26] &#x3D; &#123;0&#125;;        if (ransomNote.size() &gt; magazine.size()) &#123;            return false;        &#125;        for (int i &#x3D; 0; i &lt; magazine.length(); i++) &#123;            &#x2F;&#x2F; 通过recode数据记录 magazine里各个字符出现次数            record[magazine[i]-&#39;a&#39;] ++;        &#125;        for (int j &#x3D; 0; j &lt; ransomNote.length(); j++) &#123;            &#x2F;&#x2F; 遍历ransomNote，在record里对应的字符个数做--操作            record[ransomNote[j]-&#39;a&#39;]--;            &#x2F;&#x2F; 如果小于零说明ransomNote里出现的字符，magazine没有            if(record[ransomNote[j]-&#39;a&#39;] &lt; 0) &#123;                return false;            &#125;        &#125;        return true;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230321105224787.png"></p><h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>哈希法比较麻烦，这道题用双指针会好一一点。</p><p>首先将数组排序，然后有一层for循环，i从下标0的地方开始，同时定一个下标left 定义在i+1的位置上，定义下标right 在数组结尾的位置上。</p><p>依然还是在数组中找到 abc 使得a + b +c &#x3D;0，我们这里相当于 a &#x3D; nums[i]，b &#x3D; nums[left]，c &#x3D; nums[right]。</p><p>接下来如何移动left 和right呢， 如果nums[i] + nums[left] + nums[right] &gt; 0 就说明 此时三数之和大了，因为数组是排序后了，所以right下标就应该向左移动，这样才能让三数之和小一些。</p><p>如果 nums[i] + nums[left] + nums[right] &lt; 0 说明 此时 三数之和小了，left 就向右移动，才能让三数之和大一些，直到left与right相遇为止。</p><h3 id="Code-6"><a href="#Code-6" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;vector&lt;int&gt;&gt; result;        sort(nums.begin(), nums.end());        &#x2F;&#x2F; 找出a + b + c &#x3D; 0        &#x2F;&#x2F; a &#x3D; nums[i], b &#x3D; nums[left], c &#x3D; nums[right]        for (int i &#x3D; 0; i &lt; nums.size(); i++) &#123;            &#x2F;&#x2F; 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了            if (nums[i] &gt; 0) &#123;                return result;            &#125;            &#x2F;&#x2F; 错误去重a方法，将会漏掉-1,-1,2 这种情况            &#x2F;*            if (nums[i] &#x3D;&#x3D; nums[i + 1]) &#123;                continue;            &#125;            *&#x2F;            &#x2F;&#x2F; 正确去重a方法            if (i &gt; 0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1]) &#123;                continue;            &#125;            int left &#x3D; i + 1;            int right &#x3D; nums.size() - 1;            while (right &gt; left) &#123;                &#x2F;&#x2F; 去重复逻辑如果放在这里，0，0，0 的情况，可能直接导致 right&lt;&#x3D;left 了，从而漏掉了 0,0,0 这种三元组                &#x2F;*                while (right &gt; left &amp;&amp; nums[right] &#x3D;&#x3D; nums[right - 1]) right--;                while (right &gt; left &amp;&amp; nums[left] &#x3D;&#x3D; nums[left + 1]) left++;                *&#x2F;                if (nums[i] + nums[left] + nums[right] &gt; 0) right--;                else if (nums[i] + nums[left] + nums[right] &lt; 0) left++;                else &#123;                    result.push_back(vector&lt;int&gt;&#123;nums[i], nums[left], nums[right]&#125;);                    &#x2F;&#x2F; 去重逻辑应该放在找到一个三元组之后，对b 和 c去重                    while (right &gt; left &amp;&amp; nums[right] &#x3D;&#x3D; nums[right - 1]) right--;                    while (right &gt; left &amp;&amp; nums[left] &#x3D;&#x3D; nums[left + 1]) left++;                    &#x2F;&#x2F; 找到答案时，双指针同时收缩                    right--;                    left++;                &#125;            &#125;        &#125;        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230321112545409.png"></p><h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><p><a href="https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html">15.三数之和 (opens new window)</a>的双指针解法是一层for循环num[i]为确定值，然后循环内有left和right下标作为双指针，找到nums[i] + nums[left] + nums[right] &#x3D;&#x3D; 0。</p><p>四数之和的双指针解法是两层for循环nums[k] + nums[i]为确定值，依然是循环内有left和right下标作为双指针，找出nums[k] + nums[i] + nums[left] + nums[right] &#x3D;&#x3D; target的情况。</p><h3 id="Code-7"><a href="#Code-7" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123;        vector&lt;vector&lt;int&gt;&gt; result;        sort(nums.begin(), nums.end());        for (int k &#x3D; 0; k &lt; nums.size(); k++) &#123;            &#x2F;&#x2F; 剪枝处理            if (nums[k] &gt; target &amp;&amp; nums[k] &gt;&#x3D; 0) &#123;            break; &#x2F;&#x2F; 这里使用break，统一通过最后的return返回            &#125;            &#x2F;&#x2F; 对nums[k]去重            if (k &gt; 0 &amp;&amp; nums[k] &#x3D;&#x3D; nums[k - 1]) &#123;                continue;            &#125;            for (int i &#x3D; k + 1; i &lt; nums.size(); i++) &#123;                &#x2F;&#x2F; 2级剪枝处理                if (nums[k] + nums[i] &gt; target &amp;&amp; nums[k] + nums[i] &gt;&#x3D; 0) &#123;                    break;                &#125;                &#x2F;&#x2F; 对nums[i]去重                if (i &gt; k + 1 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1]) &#123;                    continue;                &#125;                int left &#x3D; i + 1;                int right &#x3D; nums.size() - 1;                while (right &gt; left) &#123;                    &#x2F;&#x2F; nums[k] + nums[i] + nums[left] + nums[right] &gt; target 会溢出                    if ((long) nums[k] + nums[i] + nums[left] + nums[right] &gt; target) &#123;                        right--;                    &#x2F;&#x2F; nums[k] + nums[i] + nums[left] + nums[right] &lt; target 会溢出                    &#125; else if ((long) nums[k] + nums[i] + nums[left] + nums[right]  &lt; target) &#123;                        left++;                    &#125; else &#123;                        result.push_back(vector&lt;int&gt;&#123;nums[k], nums[i], nums[left], nums[right]&#125;);                        &#x2F;&#x2F; 对nums[left]和nums[right]去重                        while (right &gt; left &amp;&amp; nums[right] &#x3D;&#x3D; nums[right - 1]) right--;                        while (right &gt; left &amp;&amp; nums[left] &#x3D;&#x3D; nums[left + 1]) left++;                        &#x2F;&#x2F; 找到答案时，双指针同时收缩                        right--;                        left++;                    &#125;                &#125;            &#125;        &#125;        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT_TCP</title>
      <link href="/2023/03/20/Learn/QT/QT_TCP/"/>
      <url>/2023/03/20/Learn/QT/QT_TCP/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="QT-TCP"><a href="#QT-TCP" class="headerlink" title="QT_TCP"></a>QT_TCP</h1><p>尝试使用QT做了一下TCP通信，挺有意思的。</p><p>参考：<a href="https://blog.csdn.net/gongjianbo1992/article/details/107743780">(80条消息) Qt网络编程（1）：QTcpSocket和QTcpServer的基本使用_qt qtcpsocket_龚建波的博客-CSDN博客</a></p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230320221551107.png"></p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><h4 id="widget-cpp"><a href="#widget-cpp" class="headerlink" title="widget.cpp"></a>widget.cpp</h4><pre class="line-numbers language-none"><code class="language-none">#include &quot;widget.h&quot;#include &quot;ui_widget.h&quot;#include &lt;QHostAddress&gt;Widget::Widget(QWidget *parent)    : QWidget(parent)    , ui(new Ui::Widget)&#123;    ui-&gt;setupUi(this);    setWindowTitle(&quot;Server&quot;);    initServer();&#125;Widget::~Widget()&#123;    &#x2F;&#x2F;关闭server    closeServer();    delete ui;&#125;void Widget::initServer()&#123;    &#x2F;&#x2F;创建Server对象    server &#x3D; new QTcpServer(this);    &#x2F;&#x2F;点击监听按钮，开始监听    connect(ui-&gt;btnListen,&amp;QPushButton::clicked,[this]&#123;        &#x2F;&#x2F;判断当前是否已开启，是则close，否则listen        if(server-&gt;isListening())&#123;            &#x2F;&#x2F;server-&gt;close();            closeServer();            &#x2F;&#x2F;关闭server后恢复界面状态            ui-&gt;btnListen-&gt;setText(&quot;Listen&quot;);            ui-&gt;editAddress-&gt;setEnabled(true);            ui-&gt;editPort-&gt;setEnabled(true);        &#125;else&#123;            &#x2F;&#x2F;从界面上读取ip和端口            &#x2F;&#x2F;可以使用 QHostAddress::Any 监听所有地址的对应端口            const QString address_text&#x3D;ui-&gt;editAddress-&gt;text();            const QHostAddress address&#x3D;(address_text&#x3D;&#x3D;&quot;Any&quot;)                    ?QHostAddress::Any                   :QHostAddress(address_text);            const unsigned short port&#x3D;ui-&gt;editPort-&gt;text().toUShort();            &#x2F;&#x2F;开始监听，并判断是否成功            if(server-&gt;listen(address,port))&#123;                &#x2F;&#x2F;连接成功就修改界面按钮提示，以及地址栏不可编辑                ui-&gt;btnListen-&gt;setText(&quot;Close&quot;);                ui-&gt;editAddress-&gt;setEnabled(false);                ui-&gt;editPort-&gt;setEnabled(false);            &#125;        &#125;        updateState();    &#125;);    &#x2F;&#x2F;监听到新的客户端连接请求    connect(server,&amp;QTcpServer::newConnection,this,[this]&#123;        &#x2F;&#x2F;如果有新的连接就取出        while(server-&gt;hasPendingConnections())        &#123;            &#x2F;&#x2F;nextPendingConnection返回下一个挂起的连接作为已连接的QTcpSocket对象            &#x2F;&#x2F;套接字是作为服务器的子级创建的，这意味着销毁QTcpServer对象时会自动删除该套接字。            &#x2F;&#x2F;最好在完成处理后显式删除该对象，以避免浪费内存。            &#x2F;&#x2F;返回的QTcpSocket对象不能从另一个线程使用，如有需要可重写incomingConnection().            QTcpSocket *socket&#x3D;server-&gt;nextPendingConnection();            clientList.append(socket);            ui-&gt;textRecv-&gt;append(QString(&quot;[%1:%2] Soket Connected&quot;)                                 .arg(socket-&gt;peerAddress().toString())                                 .arg(socket-&gt;peerPort()));            &#x2F;&#x2F;关联相关操作的信号槽            &#x2F;&#x2F;收到数据，触发readyRead            connect(socket,&amp;QTcpSocket::readyRead,[this,socket]&#123;                &#x2F;&#x2F;没有可读的数据就返回                if(socket-&gt;bytesAvailable()&lt;&#x3D;0)                    return;                &#x2F;&#x2F;注意收发两端文本要使用对应的编解码                const QString recv_text&#x3D;QString::fromUtf8(socket-&gt;readAll());                ui-&gt;textRecv-&gt;append(QString(&quot;[%1:%2]&quot;)                                     .arg(socket-&gt;peerAddress().toString())                                     .arg(socket-&gt;peerPort()));                ui-&gt;textRecv-&gt;append(recv_text);            &#125;);            &#x2F;&#x2F;error信号在5.15换了名字#if QT_VERSION &lt; QT_VERSION_CHECK(5, 15, 0)            &#x2F;&#x2F;错误信息            connect(socket, static_cast&lt;void(QAbstractSocket::*)(QAbstractSocket::SocketError)&gt;(&amp;QAbstractSocket::error),                    [this,socket](QAbstractSocket::SocketError)&#123;                ui-&gt;textRecv-&gt;append(QString(&quot;[%1:%2] Soket Error:%3&quot;)                                     .arg(socket-&gt;peerAddress().toString())                                     .arg(socket-&gt;peerPort())                                     .arg(socket-&gt;errorString()));            &#125;);#else            &#x2F;&#x2F;错误信息            connect(socket,&amp;QAbstractSocket::errorOccurred,[this,socket](QAbstractSocket::SocketError)&#123;                ui-&gt;textRecv-&gt;append(QString(&quot;[%1:%2] Soket Error:%3&quot;)                                     .arg(socket-&gt;peerAddress().toString())                                     .arg(socket-&gt;peerPort())                                     .arg(socket-&gt;errorString()));            &#125;);#endif            &#x2F;&#x2F;连接断开，销毁socket对象，这是为了开关server时socket正确释放            connect(socket,&amp;QTcpSocket::disconnected,[this,socket]&#123;                socket-&gt;deleteLater();                clientList.removeOne(socket);                ui-&gt;textRecv-&gt;append(QString(&quot;[%1:%2] Soket Disonnected&quot;)                                     .arg(socket-&gt;peerAddress().toString())                                     .arg(socket-&gt;peerPort()));                updateState();            &#125;);        &#125;        updateState();    &#125;);    &#x2F;&#x2F;server向client发送内容    connect(ui-&gt;btnSend,&amp;QPushButton::clicked,[this]&#123;        &#x2F;&#x2F;判断是否开启了server        if(!server-&gt;isListening())            return;        &#x2F;&#x2F;将发送区文本发送给客户端        const QByteArray send_data&#x3D;ui-&gt;textSend-&gt;toPlainText().toUtf8();        &#x2F;&#x2F;数据为空就返回        if(send_data.isEmpty())            return;        for(QTcpSocket *socket:clientList)        &#123;            socket-&gt;write(send_data);            &#x2F;&#x2F;socket-&gt;waitForBytesWritten();        &#125;    &#125;);    &#x2F;&#x2F;server的错误信息    &#x2F;&#x2F;如果发生错误，则serverError()返回错误的类型，    &#x2F;&#x2F;并且可以调用errorString()以获取对所发生事件的易于理解的描述    connect(server,&amp;QTcpServer::acceptError,[this](QAbstractSocket::SocketError)&#123;        ui-&gt;textRecv-&gt;append(&quot;Server Error:&quot;+server-&gt;errorString());    &#125;);&#125;void Widget::closeServer()&#123;    &#x2F;&#x2F;停止服务    server-&gt;close();    for(QTcpSocket * socket:clientList)    &#123;        &#x2F;&#x2F;断开与客户端的连接        socket-&gt;disconnectFromHost();        if(socket-&gt;state()!&#x3D;QAbstractSocket::UnconnectedState)&#123;            socket-&gt;abort();        &#125;    &#125;&#125;void Widget::updateState()&#123;    &#x2F;&#x2F;将当前server地址和端口、客户端连接数写在标题栏    if(server-&gt;isListening())&#123;        setWindowTitle(QString(&quot;Server[%1:%2] connections:%3&quot;)                       .arg(server-&gt;serverAddress().toString())                       .arg(server-&gt;serverPort())                       .arg(clientList.count()));    &#125;else&#123;        setWindowTitle(&quot;Server&quot;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="widget-h"><a href="#widget-h" class="headerlink" title="widget.h"></a>widget.h</h4><pre class="line-numbers language-none"><code class="language-none">#ifndef WIDGET_H#define WIDGET_H#include &lt;QWidget&gt;#include &lt;QTcpServer&gt;#include &lt;QTcpSocket&gt;QT_BEGIN_NAMESPACEnamespace Ui &#123; class Widget; &#125;QT_END_NAMESPACEclass Widget : public QWidget&#123;    Q_OBJECTpublic:    Widget(QWidget *parent &#x3D; nullptr);    ~Widget();private:    &#x2F;&#x2F;初始化server操作    void initServer();    &#x2F;&#x2F;close server    void closeServer();    &#x2F;&#x2F;更新当前状态    void updateState();private:    Ui::Widget *ui;    &#x2F;&#x2F;server用于监听端口，获取新的tcp连接的描述符    QTcpServer *server;    &#x2F;&#x2F;存储已连接的socket对象    QList&lt;QTcpSocket*&gt; clientList;&#125;;#endif &#x2F;&#x2F; WIDGET_H<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h3><h4 id="widget-cpp-1"><a href="#widget-cpp-1" class="headerlink" title="widget.cpp"></a>widget.cpp</h4><pre class="line-numbers language-none"><code class="language-none">#include &quot;widget.h&quot;#include &quot;ui_widget.h&quot;#include &lt;QHostAddress&gt;Widget::Widget(QWidget *parent)    : QWidget(parent)    , ui(new Ui::Widget)&#123;    ui-&gt;setupUi(this);    setWindowTitle(&quot;Client&quot;);    initClient();&#125;Widget::~Widget()&#123;    &#x2F;&#x2F;析构关闭连接    &#x2F;&#x2F;client-&gt;disconnectFromHost();    &#x2F;&#x2F;if(client-&gt;state()!&#x3D;QAbstractSocket::UnconnectedState)&#123;    &#x2F;&#x2F;    client-&gt;waitForDisconnected();    &#x2F;&#x2F;&#125;    &#x2F;&#x2F;关闭套接字的I&#x2F;O设备，并调用disconnectFromHost()关闭套接字的连接。    &#x2F;&#x2F;client-&gt;close();    &#x2F;&#x2F;中止当前连接并重置套接字。与disconnectFromHost()不同，    &#x2F;&#x2F;此函数立即关闭套接字，并丢弃写缓冲区中的所有待处理数据。    client-&gt;abort();    delete ui;&#125;void Widget::initClient()&#123;    &#x2F;&#x2F;创建client对象    client &#x3D; new QTcpSocket(this);    &#x2F;&#x2F;点击连接，根据ui设置的服务器地址进行连接    connect(ui-&gt;btnConnect,&amp;QPushButton::clicked,[this]&#123;        &#x2F;&#x2F;判断当前是否已连接，连接了就断开        if(client-&gt;state()&#x3D;&#x3D;QAbstractSocket::ConnectedState)&#123;            &#x2F;&#x2F;如果使用disconnectFromHost()不会重置套接字，isValid还是会为true            client-&gt;abort();        &#125;else if(client-&gt;state()&#x3D;&#x3D;QAbstractSocket::UnconnectedState)&#123;            &#x2F;&#x2F;从界面上读取ip和端口            const QHostAddress address&#x3D;QHostAddress(ui-&gt;editAddress-&gt;text());            const unsigned short port&#x3D;ui-&gt;editPort-&gt;text().toUShort();            &#x2F;&#x2F;连接服务器            client-&gt;connectToHost(address,port);        &#125;else&#123;            ui-&gt;textRecv-&gt;append(&quot;It is not ConnectedState or UnconnectedState&quot;);        &#125;    &#125;);    &#x2F;&#x2F;连接状态    connect(client,&amp;QTcpSocket::connected,[this]&#123;        &#x2F;&#x2F;已连接就设置为不可编辑        ui-&gt;btnConnect-&gt;setText(&quot;Disconnect&quot;);        ui-&gt;editAddress-&gt;setEnabled(false);        ui-&gt;editPort-&gt;setEnabled(false);        updateState();    &#125;);    connect(client,&amp;QTcpSocket::disconnected,[this]&#123;        &#x2F;&#x2F;断开连接还原状态        ui-&gt;btnConnect-&gt;setText(&quot;Connect&quot;);        ui-&gt;editAddress-&gt;setEnabled(true);        ui-&gt;editPort-&gt;setEnabled(true);        updateState();    &#125;);    &#x2F;&#x2F;发送数据    connect(ui-&gt;btnSend,&amp;QPushButton::clicked,[this]&#123;        &#x2F;&#x2F;判断是可操作，isValid表示准备好读写        if(!client-&gt;isValid())            return;        &#x2F;&#x2F;将发送区文本发送给客户端        const QByteArray send_data&#x3D;ui-&gt;textSend-&gt;toPlainText().toUtf8();        &#x2F;&#x2F;数据为空就返回        if(send_data.isEmpty())            return;        client-&gt;write(send_data);        &#x2F;&#x2F;client-&gt;waitForBytesWritten();    &#125;);    &#x2F;&#x2F;收到数据，触发readyRead    connect(client,&amp;QTcpSocket::readyRead,[this]&#123;        &#x2F;&#x2F;没有可读的数据就返回        if(client-&gt;bytesAvailable()&lt;&#x3D;0)            return;        &#x2F;&#x2F;注意收发两端文本要使用对应的编解码        const QString recv_text&#x3D;QString::fromUtf8(client-&gt;readAll());        ui-&gt;textRecv-&gt;append(QString(&quot;[%1:%2]&quot;)                             .arg(client-&gt;peerAddress().toString())                             .arg(client-&gt;peerPort()));        ui-&gt;textRecv-&gt;append(recv_text);    &#125;);    &#x2F;&#x2F;error信号在5.15换了名字#if QT_VERSION &lt; QT_VERSION_CHECK(5, 15, 0)    &#x2F;&#x2F;错误信息    connect(client, static_cast&lt;void(QAbstractSocket::*)(QAbstractSocket::SocketError)&gt;(&amp;QAbstractSocket::error),            [this](QAbstractSocket::SocketError)&#123;        ui-&gt;textRecv-&gt;append(&quot;Socket Error:&quot;+client-&gt;errorString());    &#125;);#else    &#x2F;&#x2F;错误信息    connect(client,&amp;QAbstractSocket::errorOccurred,[this](QAbstractSocket::SocketError)&#123;        ui-&gt;textRecv-&gt;append(&quot;Socket Error:&quot;+client-&gt;errorString());    &#125;);#endif&#125;void Widget::updateState()&#123;    &#x2F;&#x2F;将当前client地址和端口写在标题栏    if(client-&gt;state()&#x3D;&#x3D;QAbstractSocket::ConnectedState)&#123;        setWindowTitle(QString(&quot;Client[%1:%2]&quot;)                       .arg(client-&gt;localAddress().toString())                       .arg(client-&gt;localPort()));    &#125;else&#123;        setWindowTitle(&quot;Client&quot;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="widget-h-1"><a href="#widget-h-1" class="headerlink" title="widget.h"></a>widget.h</h4><pre class="line-numbers language-none"><code class="language-none">#ifndef WIDGET_H#define WIDGET_H#include &lt;QWidget&gt;#include &lt;QTcpSocket&gt;QT_BEGIN_NAMESPACEnamespace Ui &#123; class Widget; &#125;QT_END_NAMESPACE&#x2F;&#x2F;simple Tcp 客户端class Widget : public QWidget&#123;    Q_OBJECTpublic:    Widget(QWidget *parent &#x3D; nullptr);    ~Widget();private:    &#x2F;&#x2F;初始化client操作    void initClient();    &#x2F;&#x2F;更新当前状态    void updateState();private:    Ui::Widget *ui;    &#x2F;&#x2F;socket对象    QTcpSocket *client;&#125;;#endif &#x2F;&#x2F; WIDGET_H<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码随想录_链表</title>
      <link href="/2023/03/20/Learn/LeetCode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E9%93%BE%E8%A1%A8/"/>
      <url>/2023/03/20/Learn/LeetCode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="移除链表元素"><a href="#移除链表元素" class="headerlink" title="移除链表元素"></a>移除链表元素</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230320085706838.png"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>创建一个虚拟头节点，之后头节点跟其他节点处理方式一样。最后再把虚拟头节点删除。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    ListNode* removeElements(ListNode* head, int val) &#123;        ListNode* dummyHead &#x3D; new ListNode(0);&#x2F;&#x2F;设置一个虚拟头节点        dummyHead-&gt;next &#x3D; head;&#x2F;&#x2F;头节点为虚拟节点下一个        ListNode* cur &#x3D; dummyHead;        while(cur-&gt;next !&#x3D; nullptr)&#123;            if(cur-&gt;next-&gt;val &#x3D;&#x3D; val)&#123;                ListNode* tmp &#x3D; cur-&gt;next;                cur-&gt;next &#x3D; cur-&gt;next-&gt;next;                delete tmp;&#x2F;&#x2F;删除节点，释放内存            &#125;            else&#123;                cur &#x3D; cur-&gt;next;            &#125;        &#125;        head &#x3D; dummyHead-&gt;next;        delete dummyHead;        return head;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230320131817279.png"></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>设置一个虚拟头节点再进行操作。</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class MyLinkedList &#123;public:    struct LinkedNode&#123;        int val;        LinkedNode* next;        LinkedNode(int val):val(val),next(nullptr)&#123;&#125;    &#125;;    MyLinkedList() &#123;        dummynode &#x3D; new LinkedNode(0);        dummynode-&gt;next &#x3D; nullptr;        _size &#x3D; 0;    &#125;        int get(int index) &#123;        if(index&gt;(_size-1) || index&lt;0)&#123;            return -1;        &#125;        LinkedNode* cur &#x3D; dummynode-&gt;next;        while(index)&#123;            cur &#x3D; cur-&gt;next;            index--;        &#125;        return cur-&gt;val;    &#125;        void addAtHead(int val) &#123;        LinkedNode* newNode &#x3D; new LinkedNode(val);        newNode-&gt;next &#x3D; dummynode-&gt;next;        dummynode-&gt;next &#x3D; newNode;        _size++;    &#125;        void addAtTail(int val) &#123;        LinkedNode* newNode &#x3D; new LinkedNode(val);        LinkedNode* cur &#x3D; dummynode;        while(cur-&gt;next!&#x3D;nullptr)&#123;            cur &#x3D; cur-&gt;next;        &#125;        cur-&gt;next &#x3D; newNode;        _size++;    &#125;        void addAtIndex(int index, int val) &#123;        if(index&gt;_size)&#123;return;&#125;        if(index&lt;0)&#123;index&#x3D;0;&#125;        LinkedNode* newNode &#x3D; new LinkedNode(val);        LinkedNode* cur &#x3D; dummynode;        while(index)&#123;            cur &#x3D; cur-&gt;next;            index--;        &#125;        newNode-&gt;next&#x3D;cur -&gt; next;        cur-&gt;next &#x3D; newNode;        _size++;    &#125;        void deleteAtIndex(int index) &#123;        if(index&gt;&#x3D;_size || index&lt;0)&#123;            return;        &#125;        LinkedNode* cur &#x3D; dummynode;        while(index)&#123;            cur &#x3D; cur-&gt;next;            index--;        &#125;        cur-&gt;next &#x3D; cur-&gt;next-&gt;next;        _size--;            &#125;private:    int _size &#x3D; 0;    LinkedNode* dummynode;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="翻转链表"><a href="#翻转链表" class="headerlink" title="翻转链表"></a>翻转链表</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230320131831889.png"></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>双指针法和递归法</p><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    ListNode* reverseList(ListNode* head) &#123;        ListNode* cur &#x3D; head;        ListNode* pre &#x3D; nullptr;        ListNode* tmp &#x3D; nullptr;        while(cur !&#x3D; nullptr)&#123;            tmp &#x3D; cur-&gt;next;            cur-&gt;next &#x3D; pre;            pre &#x3D; cur;            cur &#x3D; tmp;        &#125;        return pre;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><pre class="line-numbers language-none"><code class="language-none">lass Solution &#123;public:    ListNode* reverse(ListNode* pre,ListNode* cur)&#123;        if(cur &#x3D;&#x3D; NULL) return pre;        ListNode* temp &#x3D; cur-&gt;next;        cur-&gt;next &#x3D; pre;        &#x2F;&#x2F; 可以和双指针法的代码进行对比，如下递归的写法，其实就是做了这两步        &#x2F;&#x2F; pre &#x3D; cur;        &#x2F;&#x2F; cur &#x3D; temp;        return reverse(cur,temp);    &#125;    ListNode* reverseList(ListNode* head) &#123;        &#x2F;&#x2F; 和双指针法初始化是一样的逻辑        &#x2F;&#x2F; ListNode* cur &#x3D; head;        &#x2F;&#x2F; ListNode* pre &#x3D; NULL;        return reverse(NULL, head);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230320131846848.png"></p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230320133635175.png"></p><h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    ListNode* swapPairs(ListNode* head) &#123;        ListNode* dummyNode &#x3D; new ListNode(0);        ListNode* cur &#x3D; head;        ListNode* tmp;        ListNode* pre;        dummyNode-&gt;next &#x3D; cur;        pre &#x3D; dummyNode;        while( pre-&gt;next !&#x3D; nullptr &amp;&amp; pre-&gt;next-&gt;next !&#x3D; nullptr)&#123;            tmp &#x3D; pre-&gt;next-&gt;next-&gt;next;            pre-&gt;next &#x3D; cur-&gt;next;            pre &#x3D; cur;            cur-&gt;next-&gt;next &#x3D; cur;            cur-&gt;next &#x3D; tmp;            cur &#x3D; tmp;        &#125;        return dummyNode-&gt;next;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="删除链表的倒数第N个节点"><a href="#删除链表的倒数第N个节点" class="headerlink" title="删除链表的倒数第N个节点"></a>删除链表的倒数第N个节点</h2><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>双指针的经典应用，如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了。</p><h3 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;        ListNode* dummyNode &#x3D; new ListNode(0);        ListNode* fast &#x3D; dummyNode;        ListNode* slow &#x3D; dummyNode;        dummyNode-&gt;next &#x3D; head;        while(n--)&#123;            fast &#x3D; fast-&gt;next;        &#125;        fast &#x3D; fast-&gt;next;&#x2F;&#x2F;多走一步，便于slow删除        while(fast!&#x3D;nullptr)&#123;            fast &#x3D; fast-&gt;next;            slow &#x3D; slow-&gt;next;        &#125;        slow-&gt;next &#x3D; slow-&gt;next-&gt;next;        return dummyNode-&gt;next;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交"></a>链表相交</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230320141329764.png"></p><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>交点不是数值相等，而是指针相等。</p><h3 id="Code-5"><a href="#Code-5" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;        ListNode* curA &#x3D; headA;        ListNode* curB &#x3D; headB;        int lenA &#x3D; 0, lenB &#x3D; 0;        while (curA !&#x3D; NULL) &#123; &#x2F;&#x2F; 求链表A的长度            lenA++;            curA &#x3D; curA-&gt;next;        &#125;        while (curB !&#x3D; NULL) &#123; &#x2F;&#x2F; 求链表B的长度            lenB++;            curB &#x3D; curB-&gt;next;        &#125;        curA &#x3D; headA;        curB &#x3D; headB;        &#x2F;&#x2F; 让curA为最长链表的头，lenA为其长度        if (lenB &gt; lenA) &#123;            swap (lenA, lenB);            swap (curA, curB);        &#125;        &#x2F;&#x2F; 求长度差        int gap &#x3D; lenA - lenB;        &#x2F;&#x2F; 让curA和curB在同一起点上（末尾位置对齐）        while (gap--) &#123;            curA &#x3D; curA-&gt;next;        &#125;        &#x2F;&#x2F; 遍历curA 和 curB，遇到相同则直接返回        while (curA !&#x3D; NULL) &#123;            if (curA &#x3D;&#x3D; curB) &#123;                return curA;            &#125;            curA &#x3D; curA-&gt;next;            curB &#x3D; curB-&gt;next;        &#125;        return NULL;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="环形链表II"><a href="#环形链表II" class="headerlink" title="环形链表II"></a>环形链表II</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230320150646135.png"></p><h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>！！很有意思的一个题目</p><p><a href="https://www.programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html#%E6%80%9D%E8%B7%AF">代码随想录 (programmercarl.com)</a></p><h3 id="Code-6"><a href="#Code-6" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    ListNode <span class="token operator">*</span><span class="token function">detectCycle</span><span class="token punctuation">(</span>ListNode <span class="token operator">*</span>head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        ListNode<span class="token operator">*</span> fast <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> slow <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>fast <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> fast<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            slow <span class="token operator">=</span> slow<span class="token operator">-></span>next<span class="token punctuation">;</span>            fast <span class="token operator">=</span> fast<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span>            <span class="token comment">// 快慢指针相遇，此时从head 和 相遇点，同时查找直至相遇</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>slow <span class="token operator">==</span> fast<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                ListNode<span class="token operator">*</span> index1 <span class="token operator">=</span> fast<span class="token punctuation">;</span>                ListNode<span class="token operator">*</span> index2 <span class="token operator">=</span> head<span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>index1 <span class="token operator">!=</span> index2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    index1 <span class="token operator">=</span> index1<span class="token operator">-></span>next<span class="token punctuation">;</span>                    index2 <span class="token operator">=</span> index2<span class="token operator">-></span>next<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">return</span> index2<span class="token punctuation">;</span> <span class="token comment">// 返回环的入口</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码随想录_数组</title>
      <link href="/2023/03/19/Learn/LeetCode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E6%95%B0%E7%BB%84/"/>
      <url>/2023/03/19/Learn/LeetCode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230319102940430.png"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>我们定义 target 是在一个在左闭右闭的区间里，<strong>也就是[left, right] （这个很重要非常重要）</strong>。</p><p>区间的定义这就决定了二分法的代码应该如何写，<strong>因为定义target在[left, right]区间，所以有如下两点：</strong></p><ul><li>while (left &lt;&#x3D; right) 要使用 &lt;&#x3D; ，因为left &#x3D;&#x3D; right是有意义的，所以使用 &lt;&#x3D;</li><li>if (nums[middle] &gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1</li></ul><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    int search(vector&lt;int&gt;&amp; nums, int target) &#123;        int left &#x3D; 0,right&#x3D;nums.size()-1;        int mid &#x3D; 0;        while(left&lt;&#x3D;right)&#123;            mid&#x3D;left+(right-left)&#x2F;2;            if(nums[mid]&gt;target)&#123;                right &#x3D; mid-1;            &#125;            else if(nums[mid]&lt;target)&#123;                left &#x3D; mid+1;            &#125;            else&#123;                return mid;            &#125;        &#125;        return -1;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：O(log n)</li><li>空间复杂度：O(1)</li></ul><h2 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230319142739184.png"></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>双指针法（快慢指针法）： <strong>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</strong></p><p>定义快慢指针</p><ul><li>快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组</li><li>慢指针：指向更新 新数组下标的位置</li></ul><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><h4 id="法1"><a href="#法1" class="headerlink" title="法1"></a>法1</h4><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;        int slowIndex &#x3D; 0;        for(int fastIndex &#x3D; 0;fastIndex &lt; nums.size();fastIndex++)&#123;            if(nums[fastIndex]!&#x3D;val)&#123;                nums[slowIndex] &#x3D; nums[fastIndex];                slowIndex++;            &#125;        &#125;        return slowIndex;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="法2"><a href="#法2" class="headerlink" title="法2"></a>法2</h4><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;        int left &#x3D; 0, right &#x3D; nums.size();        while (left &lt; right) &#123;            if (nums[left] &#x3D;&#x3D; val) &#123;                nums[left] &#x3D; nums[right - 1];                right--;            &#125; else &#123;                left++;            &#125;        &#125;        return left;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="有序数组的平方"><a href="#有序数组的平方" class="headerlink" title="有序数组的平方"></a>有序数组的平方</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230319142720710.png"></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>暴力解法：每个数平方之后，排个序</p><p>双指针法：数组其实是有序的， 只不过负数平方之后可能成为最大数了。</p><p>那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。</p><p>此时可以考虑双指针法了，i指向起始位置，j指向终止位置。</p><p>定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。</p><p>如果<code>A[i] * A[i] &lt; A[j] * A[j]</code> 那么<code>result[k--] = A[j] * A[j];</code> 。</p><p>如果<code>A[i] * A[i] &gt;= A[j] * A[j]</code> 那么<code>result[k--] = A[i] * A[i];</code> 。</p><h4 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h4><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; A) &#123;        for (int i &#x3D; 0; i &lt; A.size(); i++) &#123;            A[i] *&#x3D; A[i];        &#125;        sort(A.begin(), A.end()); &#x2F;&#x2F; 快速排序        return A;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h4><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; A) &#123;        vector&lt;int&gt; result(A.size(),0);        int k &#x3D; A.size()-1;        int l &#x3D; k;        int j &#x3D; 0;        while(j&lt;&#x3D;k)&#123;            if(A[j]*A[j] &lt; A[k]*A[k])&#123;                result[l] &#x3D; A[k]*A[k];                l--;                k--;             &#125;            else&#123;                result[l] &#x3D; A[j]*A[j];                l--;                j++;             &#125;        &#125;        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h2><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>滑动窗口</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230319135321762.png"></p><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) &#123;        int sum &#x3D; 0;        int j &#x3D; 0;        int length &#x3D; 0;        int ans &#x3D; nums.size()+1;        for(int i&#x3D;0;i&lt;nums.size();i++)&#123;            sum +&#x3D; nums[i];            while(sum&gt;&#x3D;target)&#123;                length &#x3D; i-j+1;                ans &#x3D; length&lt;ans?length:ans;                sum-&#x3D;nums[j++];            &#125;        &#125;        if(ans &#x3D;&#x3D; nums.size()+1 )&#123;            return 0;        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230319142656893.png"></p><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>左闭右开。</p><p>这里一圈下来，我们要画每四条边，这四条边怎么画，每画一条边都要坚持一致的左闭右开，或者左开右闭的原则，这样这一圈才能按照统一的规则画下来。那么我按照左闭右开的原则，来画一圈，看一下：</p><p>n为奇数分开考虑。其他都是n&#x2F;2圈。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230319151504797.png"></p><h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123;        vector&lt;vector&lt;int&gt;&gt; ans(n,vector&lt;int&gt;(n,0));        int offset &#x3D; 1;        int startx &#x3D; 0;        int starty &#x3D; 0;        int count &#x3D; 1;        int loop &#x3D; n&#x2F;2;        int i &#x3D; 0;        int j &#x3D; 0;        while(loop)&#123;            for(i&#x3D;startx; i&lt;n-offset; i++)&#123;                ans[starty][i] &#x3D; count++;            &#125;            for(j&#x3D;starty; j&lt;n-offset; j++)&#123;                ans[j][i] &#x3D; count++;            &#125;            for(;i&gt;startx;i--)&#123;                ans[j][i] &#x3D; count++;            &#125;            for(;j&gt;starty;j--)&#123;                ans[j][startx] &#x3D; count++;            &#125;            startx++;            starty++;            offset++;            loop--;        &#125;         if(n%2)&#123;            ans[n&#x2F;2][n&#x2F;2] &#x3D; n*n;        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023.3.19 LeetCode</title>
      <link href="/2023/03/19/Learn/LeetCode/2023.3.19-LeetCode/"/>
      <url>/2023/03/19/Learn/LeetCode/2023.3.19-LeetCode/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="2023-3-19"><a href="#2023-3-19" class="headerlink" title="2023.3.19"></a>2023.3.19</h1><h2 id="1625-执行操作后字典序最小的字符串"><a href="#1625-执行操作后字典序最小的字符串" class="headerlink" title="1625. 执行操作后字典序最小的字符串"></a>1625. 执行操作后字典序最小的字符串</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230319092711448.png"></p><h3 id="My-Code"><a href="#My-Code" class="headerlink" title="My Code"></a>My Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    string findLexSmallestString(string s, int a, int b) &#123;        string anw &#x3D; s;        for(int i &#x3D; 0; i &lt;&#x3D; s.size(); i++) &#123;            &#x2F;&#x2F; 轮转            s &#x3D; s.substr(b, s.size()) + s.substr(0, b);            &#x2F;&#x2F; 修改奇数位置            for(int j &#x3D; 0; j &lt; 10; j++) &#123;                for(int k &#x3D; 1; k &lt; s.size(); k +&#x3D; 2) &#123;                    s[k] +&#x3D; a;                    if(s[k] &gt; &#39;9&#39;) &#123;                        s[k] &#x3D; &#39;0&#39; + (s[k]-&#39;9&#39;-1);                    &#125;                &#125;                if(b%2) &#123;                    &#x2F;&#x2F; b为奇数，此时通过轮转，也能修改偶数位置                    for(int m &#x3D; 0; m &lt; 10; m++) &#123;                        for(int k &#x3D; 0; k &lt; s.size(); k +&#x3D; 2) &#123;                            s[k] +&#x3D; a;                            if(s[k] &gt; &#39;9&#39;) &#123;                                s[k] &#x3D; &#39;0&#39; + (s[k]-&#39;9&#39;-1);                            &#125;                        &#125;                           anw &#x3D; min(anw, s);                    &#125;                &#125; else &#123;                    anw &#x3D; min(anw, s);                &#125;            &#125;        &#125;        return anw;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023.3.18 Note</title>
      <link href="/2023/03/18/Note/2023.3.18%E8%AE%B0/"/>
      <url>/2023/03/18/Note/2023.3.18%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>近期把Freertos、通信协议重新学习了一遍，收获颇多。</p><p>找个时间把几个通信协议总结归纳一下！</p><p>牛客有点简单，味道都差不多，换成每天一道LeetCode，分题型学！</p><p>看了雷殿生写的徒步中国，深深的震撼。</p><p>小飞机bug也解决了很多，能飞拍视频了。</p><p>心情很好，干劲十足，继续保持。</p>]]></content>
      
      
      <categories>
          
          <category> Diary </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2023.3.18 LeetCode</title>
      <link href="/2023/03/18/Learn/LeetCode/2023.3.18-LeetCode/"/>
      <url>/2023/03/18/Learn/LeetCode/2023.3.18-LeetCode/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="2023-3-18"><a href="#2023-3-18" class="headerlink" title="2023.3.18"></a>2023.3.18</h1><h2 id="1616-分割两个字符串得到回文串"><a href="#1616-分割两个字符串得到回文串" class="headerlink" title="1616.分割两个字符串得到回文串"></a>1616.分割两个字符串得到回文串</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230318142727587.png" alt="image-20230318142727587"></p><h2 id="My-Code"><a href="#My-Code" class="headerlink" title="My Code"></a>My Code</h2><p>思路：我们可以使用双指针，其中一个指针 i 从字符串 a 的头部开始，另一个指针 j 从字符串 b的尾部开始，如果两个指针指向的字符相等，那么两个指针同时往中间移动，直到遇到不同的字符或两指针交叉。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    bool checkPalindromeFormation(string a, string b) &#123;        return check1(a, b) || check1(b, a);    &#125;private:    bool check1(string &amp;a, string &amp;b) &#123;        int i &#x3D; 0, j &#x3D; b.size() - 1;        while (i &lt; j &amp;&amp; a[i] &#x3D;&#x3D; b[j]) &#123;            ++i;            --j;        &#125;        return i &gt;&#x3D; j || check2(a, i, j) || check2(b, i, j);    &#125;    bool check2(string &amp;a, int i, int j) &#123;        while (i &lt;&#x3D; j &amp;&amp; a[i] &#x3D;&#x3D; a[j]) &#123;            ++i;            --j;        &#125;        return i &gt;&#x3D; j;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信念·十年徒步中国</title>
      <link href="/2023/03/18/Books/%E4%BF%A1%E5%BF%B5%C2%B7%E5%8D%81%E5%B9%B4%E5%BE%92%E6%AD%A5%E4%B8%AD%E5%9B%BD/"/>
      <url>/2023/03/18/Books/%E4%BF%A1%E5%BF%B5%C2%B7%E5%8D%81%E5%B9%B4%E5%BE%92%E6%AD%A5%E4%B8%AD%E5%9B%BD/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="信念·十年徒步中国"><a href="#信念·十年徒步中国" class="headerlink" title="信念·十年徒步中国"></a>信念·十年徒步中国</h1><p>by 雷殿生</p><p>读万卷书，行万里路。既然还在读书，就看别人行路。</p><p>人人都有梦想的权利，但真的要把梦想变为现实，那可不是一件容易的事。作者用十年时间精心准备，又用十年实现梦想，纵然路上危险重重，也决不退缩。苦吗？看到了别人看不到的美景，感受到了别人感受不到的东西，乐大于苦。人和人之间的差别，除了对于每天时间的利用之外，更重要的是对于自己理想和目标的执着，有了这样的决心和魄力，还有什么可以阻挡我们前进的步伐。</p>]]></content>
      
      
      <categories>
          
          <category> Book </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2023.3.17 LeetCode</title>
      <link href="/2023/03/17/Learn/LeetCode/2023.3.17-LeetCode/"/>
      <url>/2023/03/17/Learn/LeetCode/2023.3.17-LeetCode/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="2023-3-17"><a href="#2023-3-17" class="headerlink" title="2023.3.17"></a>2023.3.17</h1><h2 id="2389-和有限的最长子序列"><a href="#2389-和有限的最长子序列" class="headerlink" title="2389.和有限的最长子序列"></a>2389.和有限的最长子序列</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230317130141012.png"></p><h2 id="My-Code"><a href="#My-Code" class="headerlink" title="My Code"></a>My Code</h2><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    vector&lt;int&gt; answerQueries(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; queries) &#123;        sort(nums.begin(), nums.end());        for (int i &#x3D; 1; i &lt; nums.size(); i++) &#123;            nums[i] +&#x3D; nums[i - 1];        &#125;        vector&lt;int&gt; ans;        for (auto&amp; q : queries) &#123;            ans.push_back(upper_bound(nums.begin(), nums.end(), q) - nums.begin());&#x2F;&#x2F;返回地址后减去首地址        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Freertos</title>
      <link href="/2023/03/16/Learn/Freertos/FreeRTOS%E7%B3%BB%E7%BB%9F%E5%AD%A6/"/>
      <url>/2023/03/16/Learn/Freertos/FreeRTOS%E7%B3%BB%E7%BB%9F%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>强推韦东山rtos教程</p><p><a href="https://zhuanlan.zhihu.com/p/439059278">韦东山freeRTOS系列教程：入门文档教程+进阶视频教程(全部免费的freeRTOS系列教程、freeRTOS学习路线) - 知乎 (zhihu.com)</a></p><h1 id="2-内存管理"><a href="#2-内存管理" class="headerlink" title="2.内存管理"></a>2.内存管理</h1><h2 id="2-1-为什么要自己实现内存管理"><a href="#2-1-为什么要自己实现内存管理" class="headerlink" title="2.1 为什么要自己实现内存管理"></a>2.1 为什么要自己实现内存管理</h2><p>后续的章节涉及这些内核对象：task、queue、semaphores和event group等。为了让FreeRTOS更容易使用，这些内核对象一般都是动态分配：用到时分配，不使用时释放。使用内存的动态管理功能，简化了程序设计：不再需要小心翼翼地提前规划各类对象，简化API函数的涉及，甚至可以减少内存的使用。</p><p>内存的动态管理是C程序的知识范畴，并不属于FreeRTOS的知识范畴，但是它跟FreeRTOS关系是如此紧密，所以我们先讲解它。</p><p>在C语言的库函数中，有mallc、free等函数，但是在FreeRTOS中，它们不适用：</p><ul><li>不适合用在资源紧缺的嵌入式系统中</li><li>这些函数的实现过于复杂、占据的代码空间太大</li><li>并非线程安全的(thread-safe)</li><li>运行有不确定性：每次调用这些函数时花费的时间可能都不相同</li><li>内存碎片化</li><li>使用不同的编译器时，需要进行复杂的配置</li><li>有时候难以调试</li></ul><p>注意：我们经常”堆栈”混合着说，其实它们不是同一个东西：</p><ul><li>堆，heap，就是一块空闲的内存，需要提供管理函数<ul><li>malloc：从堆里划出一块空间给程序使用</li><li>free：用完后，再把它标记为”空闲”的，可以再次使用</li></ul></li><li>栈，stack，函数调用时局部变量保存在栈中，当前程序的环境也是保存在栈中<ul><li>可以从堆中分配一块空间用作栈</li></ul></li></ul><p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/01_heap_stack.png"></p><h2 id="2-2-FreeRTOS的5种内存管理方法"><a href="#2-2-FreeRTOS的5种内存管理方法" class="headerlink" title="2.2 FreeRTOS的5种内存管理方法"></a>2.2 FreeRTOS的5种内存管理方法</h2><p>FreeRTOS中内存管理的接口函数为：pvPortMalloc 、vPortFree，对应于C库的malloc、free。</p><p>文件在<code>FreeRTOS/Source/portable/MemMang</code>下，它也是放在<code>portable</code>目录下，表示你可以提供自己的函数。</p><p>源码中默认提供了5个文件，对应内存管理的5种方法。</p><p>参考文章：<a href="https://blog.csdn.net/qq_43212092/article/details/104845158">FreeRTOS说明书吐血整理【适合新手+入门】</a></p><table><thead><tr><th>文件</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>heap_1.c</td><td>分配简单，时间确定</td><td>只分配、不回收</td></tr><tr><td>heap_2.c</td><td>动态分配、最佳匹配</td><td>碎片、时间不定</td></tr><tr><td>heap_3.c</td><td>调用标准库函数</td><td>速度慢、时间不定</td></tr><tr><td>heap_4.c</td><td>相邻空闲内存可合并</td><td>可解决碎片问题、时间不定</td></tr><tr><td>heap_5.c</td><td>在heap_4基础上支持分隔的内存块</td><td>可解决碎片问题、时间不定</td></tr></tbody></table><h3 id="2-2-1-Heap-1"><a href="#2-2-1-Heap-1" class="headerlink" title="2.2.1 Heap_1"></a>2.2.1 Heap_1</h3><p>它只实现了pvPortMalloc，没有实现vPortFree。</p><p>如果你的程序不需要删除内核对象，那么可以使用heap_1：</p><ul><li>实现最简单</li><li>没有碎片问题</li><li>一些要求非常严格的系统里，不允许使用动态内存，就可以使用heap_1</li></ul><p>它的实现原理很简单，首先定义一个大数组：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;* Allocate the memory for the heap. *&#x2F;#if ( configAPPLICATION_ALLOCATED_HEAP &#x3D;&#x3D; 1 )&#x2F;* The application writer has already defined the array used for the RTOS* heap - probably so it can be placed in a special segment or address. *&#x2F;    extern uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];#else    static uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];#endif &#x2F;* configAPPLICATION_ALLOCATED_HEAP *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后，对于pvPortMalloc调用时，从这个数组中分配空间。</p><p>FreeRTOS在创建任务时，需要2个内核对象：task control block(TCB)、stack。</p><p>使用heap_1时，内存分配过程如下图所示：</p><ul><li>A：创建任务之前整个数组都是空闲的</li><li>B：创建第1个任务之后，蓝色区域被分配出去了</li><li>C：创建3个任务之后的数组使用情况</li></ul><p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/02_heap_1.png"></p><h3 id="2-2-2-Heap-2"><a href="#2-2-2-Heap-2" class="headerlink" title="2.2.2 Heap_2"></a>2.2.2 Heap_2</h3><p>Heap_2之所以还保留，只是为了兼容以前的代码。新设计中不再推荐使用Heap_2。建议使用Heap_4来替代Heap_2，更加高效。</p><p>Heap_2也是在数组上分配内存，跟Heap_1不一样的地方在于：</p><ul><li>Heap_2使用<strong>最佳匹配算法</strong>(best fit)来分配内存</li><li>它支持vPortFree</li></ul><p>最佳匹配算法：</p><ul><li>假设heap有3块空闲内存：5字节、25字节、100字节</li><li>pvPortMalloc想申请20字节</li><li>找出最小的、能满足pvPortMalloc的内存：25字节</li><li>把它划分为20字节、5字节<ul><li>返回这20字节的地址</li><li>剩下的5字节仍然是空闲状态，留给后续的pvPortMalloc使用</li></ul></li></ul><p>与Heap_4相比，Heap_2不会合并相邻的空闲内存，所以Heap_2会导致严重的”碎片化”问题。</p><p>但是，如果申请、分配内存时大小总是相同的，这类场景下Heap_2没有碎片化的问题。所以它适合这种场景：频繁地创建、删除任务，但是任务的栈大小都是相同的(创建任务时，需要分配TCB和栈，TCB总是一样的)。</p><p>虽然不再推荐使用heap_2，但是它的效率还是远高于malloc、free。</p><p>使用heap_2时，内存分配过程如下图所示：</p><ul><li>A：创建了3个任务</li><li>B：删除了一个任务，空闲内存有3部分：顶层的、被删除任务的TCB空间、被删除任务的Stack空间</li><li>C：创建了一个新任务，因为TCB、栈大小跟前面被删除任务的TCB、栈大小一致，所以刚好分配到原来的内存</li></ul><p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/03_heap_2.png"></p><h3 id="2-2-3-Heap-3"><a href="#2-2-3-Heap-3" class="headerlink" title="2.2.3 Heap_3"></a>2.2.3 Heap_3</h3><p>Heap_3使用标准C库里的malloc、free函数，所以堆大小由链接器的配置决定，配置项configTOTAL_HEAP_SIZE不再起作用。</p><p>C库里的malloc、free函数并非线程安全的，Heap_3中先暂停FreeRTOS的调度器，再去调用这些函数，使用这种方法实现了线程安全。</p><h3 id="2-2-4-Heap-4"><a href="#2-2-4-Heap-4" class="headerlink" title="2.2.4 Heap_4"></a>2.2.4 Heap_4</h3><p>跟Heap_1、Heap_2一样，Heap_4也是使用大数组来分配内存。</p><p>Heap_4使用<strong>首次适应算法</strong>(first fit)来分配内存。它还会把相邻的空闲内存合并为一个更大的空闲内存，这有助于较少内存的碎片问题。</p><p>首次适应算法：</p><ul><li>假设堆中有3块空闲内存：5字节、200字节、100字节</li><li>pvPortMalloc想申请20字节</li><li>找出第1个能满足pvPortMalloc的内存：200字节</li><li>把它划分为20字节、180字节<ul><li>返回这20字节的地址</li><li>剩下的180字节仍然是空闲状态，留给后续的pvPortMalloc使用</li></ul></li></ul><p>Heap_4会把相邻空闲内存合并为一个大的空闲内存，可以较少内存的碎片化问题。适用于这种场景：频繁地分配、释放不同大小的内存。</p><p>Heap_4的使用过程举例如下：</p><ul><li>A：创建了3个任务</li><li>B：删除了一个任务，空闲内存有2部分：<ul><li>顶层的</li><li>被删除任务的TCB空间、被删除任务的Stack空间合并起来的</li></ul></li><li>C：分配了一个Queue，从第1个空闲块中分配空间</li><li>D：分配了一个User数据，从Queue之后的空闲块中分配</li><li>E：释放的Queue，User前后都有一块空闲内存</li><li>F：释放了User数据，User前后的内存、User本身占据的内存，合并为一个大的空闲内存</li></ul><p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/04_heap_4.png"></p><p>Heap_4执行的时间是不确定的，但是它的效率高于标准库的malloc、free。</p><h3 id="2-2-5-Heap-5"><a href="#2-2-5-Heap-5" class="headerlink" title="2.2.5 Heap_5"></a>2.2.5 Heap_5</h3><p>Heap_5分配内存、释放内存的算法跟Heap_4是一样的。</p><p>相比于Heap_4，Heap_5并不局限于管理一个大数组：它可以管理多块、分隔开的内存。</p><p>在嵌入式系统中，内存的地址可能并不连续，这种场景下可以使用Heap_5。</p><p>既然内存是分隔开的，那么就需要进行初始化：确定这些内存块在哪、多大：</p><ul><li>在使用pvPortMalloc之前，必须先指定内存块的信息</li><li>使用vPortDefineHeapRegions来指定这些信息</li></ul><p>怎么指定一块内存？使用如下结构体：</p><pre class="line-numbers language-none"><code class="language-none">typedef struct HeapRegion&#123;    uint8_t * pucStartAddress; &#x2F;&#x2F; 起始地址    size_t xSizeInBytes;       &#x2F;&#x2F; 大小&#125; HeapRegion_t;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>怎么指定多块内存？使用一个HeapRegion_t数组，在这个数组中，低地址在前、高地址在后。</p><p>比如：</p><pre class="line-numbers language-none"><code class="language-none">HeapRegion_t xHeapRegions[] &#x3D;&#123;  &#123; ( uint8_t * ) 0x80000000UL, 0x10000 &#125;, &#x2F;&#x2F; 起始地址0x80000000，大小0x10000  &#123; ( uint8_t * ) 0x90000000UL, 0xa0000 &#125;, &#x2F;&#x2F; 起始地址0x90000000，大小0xa0000  &#123; NULL, 0 &#125; &#x2F;&#x2F; 表示数组结束 &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>vPortDefineHeapRegions函数原型如下：</p><pre class="line-numbers language-none"><code class="language-none">void vPortDefineHeapRegions( const HeapRegion_t * const pxHeapRegions );<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>把xHeapRegions数组传给vPortDefineHeapRegions函数，即可初始化Heap_5。</p><h2 id="2-3-Heap相关的函数"><a href="#2-3-Heap相关的函数" class="headerlink" title="2.3 Heap相关的函数"></a>2.3 Heap相关的函数</h2><h3 id="2-3-1-pvPortMalloc-x2F-vPortFree"><a href="#2-3-1-pvPortMalloc-x2F-vPortFree" class="headerlink" title="2.3.1 pvPortMalloc&#x2F;vPortFree"></a>2.3.1 pvPortMalloc&#x2F;vPortFree</h3><p>函数原型：</p><pre class="line-numbers language-none"><code class="language-none">void * pvPortMalloc( size_t xWantedSize );&#x2F;&#x2F; 分配内存，如果分配内存不成功，则返回值为NULL。void vPortFree( void * pv );&#x2F;&#x2F; 释放内存<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>作用：分配内存、释放内存。</p><p>如果分配内存不成功，则返回值为NULL。</p><h3 id="2-3-2-xPortGetFreeHeapSize"><a href="#2-3-2-xPortGetFreeHeapSize" class="headerlink" title="2.3.2 xPortGetFreeHeapSize"></a>2.3.2 xPortGetFreeHeapSize</h3><p>函数原型：</p><pre class="line-numbers language-none"><code class="language-none">size_t xPortGetFreeHeapSize( void );<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当前还有多少空闲内存，这函数可以用来优化内存的使用情况。比如当所有内核对象都分配好后，执行此函数返回2000，那么configTOTAL_HEAP_SIZE就可减小2000。</p><p>注意：在heap_3中无法使用。</p><h3 id="2-3-3-xPortGetMinimumEverFreeHeapSize"><a href="#2-3-3-xPortGetMinimumEverFreeHeapSize" class="headerlink" title="2.3.3 xPortGetMinimumEverFreeHeapSize"></a>2.3.3 xPortGetMinimumEverFreeHeapSize</h3><p>函数原型：</p><pre class="line-numbers language-none"><code class="language-none">size_t xPortGetMinimumEverFreeHeapSize( void );<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回：程序运行过程中，空闲内存容量的最小值。</p><p>注意：只有heap_4、heap_5支持此函数。</p><h3 id="2-3-4-malloc失败的钩子函数"><a href="#2-3-4-malloc失败的钩子函数" class="headerlink" title="2.3.4 malloc失败的钩子函数"></a>2.3.4 malloc失败的钩子函数</h3><p>在pvPortMalloc函数内部：</p><pre class="line-numbers language-none"><code class="language-none">void * pvPortMalloc( size_t xWantedSize )&#123;    ......    #if ( configUSE_MALLOC_FAILED_HOOK &#x3D;&#x3D; 1 )        &#123;            if( pvReturn &#x3D;&#x3D; NULL )            &#123;                extern void vApplicationMallocFailedHook( void );                vApplicationMallocFailedHook();            &#125;        &#125;    #endif        return pvReturn;        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以，如果想使用这个钩子函数：</p><ul><li>在FreeRTOSConfig.h中，把configUSE_MALLOC_FAILED_HOOK定义为1</li><li>提供vApplicationMallocFailedHook函数</li><li>pvPortMalloc失败时，才会调用此函数</li></ul><h1 id="3-任务管理"><a href="#3-任务管理" class="headerlink" title="3.任务管理"></a>3.任务管理</h1><h2 id="3-1-基本概念"><a href="#3-1-基本概念" class="headerlink" title="3.1 基本概念"></a>3.1 基本概念</h2><p>对于整个单片机程序，我们称之为application，应用程序。</p><p>使用FreeRTOS时，我们可以在application中创建多个任务(task)，有些文档把任务也称为线程(thread)。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/01_mother_do_jobs.png" alt="../../_images/01_mother_do_jobs.png"></p><p>以日常生活为例，比如这个母亲要同时做两件事：</p><ul><li>喂饭：这是一个任务</li><li>回信息：这是另一个任务</li></ul><p>这可以引入很多概念：</p><ul><li>任务状态(State)：<ul><li>当前正在喂饭，它是running状态；另一个”回信息”的任务就是”not running”状态</li><li>“not running”状态还可以细分：<ul><li>ready：就绪，随时可以运行</li><li>blocked：阻塞，卡住了，母亲在等待同事回信息</li><li>suspended：挂起，同事废话太多，不管他了</li></ul></li></ul></li><li>优先级(Priority)<ul><li>我工作生活兼顾：喂饭、回信息优先级一样，轮流做</li><li>我忙里偷闲：还有空闲任务，休息一下</li><li>厨房着火了，什么都别说了，先灭火：优先级更高</li></ul></li><li>栈(Stack)<ul><li>喂小孩时，我要记得上一口喂了米饭，这口要喂青菜了</li><li>回信息时，我要记得刚才聊的是啥</li><li>做不同的任务，这些细节不一样</li><li>对于人来说，当然是记在脑子里</li><li>对于程序，是记在栈里</li><li>每个任务有自己的栈</li></ul></li><li>事件驱动<ul><li>孩子吃饭太慢：先休息一会，等他咽下去了、等他提醒我了，再喂下一口</li></ul></li><li>协助式调度(Co-operative Scheduling)<ul><li>你在给同事回信息<ul><li>同事说：好了，你先去给小孩喂一口饭吧，你才能离开</li><li>同事不放你走，即使孩子哭了你也不能走</li></ul></li><li>你好不容易可以给孩子喂饭了<ul><li>孩子说：好了，妈妈你去处理一下工作吧，你才能离开</li><li>孩子不放你走，即使同事连发信息你也不能走</li></ul></li></ul></li></ul><p>这涉及很多概念，后续章节详细分析。</p><h2 id="3-2-任务创建与删除"><a href="#3-2-任务创建与删除" class="headerlink" title="3.2 任务创建与删除"></a>3.2 任务创建与删除</h2><h3 id="3-2-1-什么是任务"><a href="#3-2-1-什么是任务" class="headerlink" title="3.2.1 什么是任务"></a>3.2.1 什么是任务</h3><p>在FreeRTOS中，任务就是一个函数，原型如下：</p><pre class="line-numbers language-none"><code class="language-none">void ATaskFunction( void *pvParameters );<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>要注意的是：</p><ul><li>这个函数不能返回</li><li>同一个函数，可以用来创建多个任务；换句话说，多个任务可以运行同一个函数</li><li>函数内部，尽量使用局部变量：<ul><li>每个任务都有自己的栈</li><li>每个任务运行这个函数时<ul><li>任务A的局部变量放在任务A的栈里、任务B的局部变量放在任务B的栈里</li><li>不同任务的局部变量，有自己的副本</li></ul></li><li>函数使用全局变量、静态变量的话<ul><li>只有一个副本：多个任务使用的是同一个副本</li><li>要防止冲突(后续会讲)</li></ul></li></ul></li></ul><p>下面是一个示例：</p><pre class="line-numbers language-none"><code class="language-none">void ATaskFunction( void *pvParameters )&#123;&#x2F;* 对于不同的任务，局部变量放在任务的栈里，有各自的副本 *&#x2F;int32_t lVariableExample &#x3D; 0;    &#x2F;* 任务函数通常实现为一个无限循环 *&#x2F;for( ;; )&#123;&#x2F;* 任务的代码 *&#x2F;&#125;    &#x2F;* 如果程序从循环中退出，一定要使用vTaskDelete删除自己     * NULL表示删除的是自己     *&#x2F;vTaskDelete( NULL );        &#x2F;* 程序不会执行到这里, 如果执行到这里就出错了 *&#x2F;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-2-创建任务"><a href="#3-2-2-创建任务" class="headerlink" title="3.2.2 创建任务"></a>3.2.2 创建任务</h3><p>创建任务时使用的函数如下：</p><pre class="line-numbers language-none"><code class="language-none">BaseType_t xTaskCreate( TaskFunction_t pxTaskCode, &#x2F;&#x2F; 函数指针, 任务函数                        const char * const pcName, &#x2F;&#x2F; 任务的名字                        const configSTACK_DEPTH_TYPE usStackDepth, &#x2F;&#x2F; 栈大小,单位为word,10表示40字节                        void * const pvParameters, &#x2F;&#x2F; 调用任务函数时传入的参数                        UBaseType_t uxPriority,    &#x2F;&#x2F; 优先级                        TaskHandle_t * const pxCreatedTask ); &#x2F;&#x2F; 任务句柄, 以后使用它来操作这个任务<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参数说明：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>pvTaskCode</td><td>函数指针，可以简单地认为任务就是一个C函数。 它稍微特殊一点：永远不退出，或者退出时要调用”vTaskDelete(NULL)”</td></tr><tr><td>pcName</td><td>任务的名字，FreeRTOS内部不使用它，仅仅起调试作用。 长度为：configMAX_TASK_NAME_LEN</td></tr><tr><td>usStackDepth</td><td>每个任务都有自己的栈，这里指定栈大小。 单位是word，比如传入100，表示栈大小为100 word，也就是400字节。 最大值为uint16_t的最大值。 怎么确定栈的大小，并不容易，很多时候是估计。 精确的办法是看反汇编码。</td></tr><tr><td>pvParameters</td><td>调用pvTaskCode函数指针时用到：pvTaskCode(pvParameters)</td></tr><tr><td>uxPriority</td><td>优先级范围：0~(configMAX_PRIORITIES – 1) 数值越小优先级越低， 如果传入过大的值，xTaskCreate会把它调整为(configMAX_PRIORITIES – 1)</td></tr><tr><td>pxCreatedTask</td><td>用来保存xTaskCreate的输出结果：task handle。 以后如果想操作这个任务，比如修改它的优先级，就需要这个handle。 如果不想使用该handle，可以传入NULL。</td></tr><tr><td>返回值</td><td>成功：pdPASS； 失败：errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY(失败原因只有内存不足) 注意：文档里都说失败时返回值是pdFAIL，这不对。 pdFAIL是0，errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY是-1。</td></tr></tbody></table><h3 id="3-2-3-示例1-创建任务"><a href="#3-2-3-示例1-创建任务" class="headerlink" title="3.2.3 示例1: 创建任务"></a>3.2.3 示例1: 创建任务</h3><p>代码为：<code>FreeRTOS_01_create_task</code></p><p>使用2个函数分别创建2个任务。</p><p>任务1的代码：</p><pre class="line-numbers language-none"><code class="language-none">void vTask1( void *pvParameters )&#123;const char *pcTaskName &#x3D; &quot;T1 run\r\n&quot;;volatile uint32_t ul; &#x2F;* volatile用来避免被优化掉 *&#x2F;&#x2F;* 任务函数的主体一般都是无限循环 *&#x2F;for( ;; )&#123;&#x2F;* 打印任务1的信息 *&#x2F;printf( pcTaskName );&#x2F;* 延迟一会(比较简单粗暴) *&#x2F;for( ul &#x3D; 0; ul &lt; mainDELAY_LOOP_COUNT; ul++ )&#123;&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>任务2的代码：</p><pre class="line-numbers language-none"><code class="language-none">void vTask2( void *pvParameters )&#123;const char *pcTaskName &#x3D; &quot;T2 run\r\n&quot;;volatile uint32_t ul; &#x2F;* volatile用来避免被优化掉 *&#x2F;&#x2F;* 任务函数的主体一般都是无限循环 *&#x2F;for( ;; )&#123;&#x2F;* 打印任务1的信息 *&#x2F;printf( pcTaskName );&#x2F;* 延迟一会(比较简单粗暴) *&#x2F;for( ul &#x3D; 0; ul &lt; mainDELAY_LOOP_COUNT; ul++ )&#123;&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>main函数：</p><pre class="line-numbers language-none"><code class="language-none">int main( void )&#123;prvSetupHardware();xTaskCreate(vTask1, &quot;Task 1&quot;, 1000, NULL, 1, NULL);xTaskCreate(vTask2, &quot;Task 2&quot;, 1000, NULL, 1, NULL);&#x2F;* 启动调度器 *&#x2F;vTaskStartScheduler();&#x2F;* 如果程序运行到了这里就表示出错了, 一般是内存不足 *&#x2F;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果如下：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/04_create_two_task.png"></p><p>注意：</p><ul><li>task 2先运行！</li><li>要分析xTaskCreate的代码才能知道原因：更高优先级的、或者后面创建的任务先运行。</li></ul><p>任务运行图：</p><ul><li>在t1：Task2进入运行态，一直运行直到t2</li><li>在t2：Task1进入运行态，一直运行直到t3；在t3，Task2重新进入运行态</li></ul><p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/05_task_schedul.png"></p><h3 id="3-2-4-示例2-使用任务参数"><a href="#3-2-4-示例2-使用任务参数" class="headerlink" title="3.2.4 示例2: 使用任务参数"></a>3.2.4 示例2: 使用任务参数</h3><p>代码为：<code>FreeRTOS_02_create_task_use_params</code></p><p>我们说过，多个任务可以使用同一个函数，怎么体现它们的差别？</p><ul><li>栈不同</li><li>创建任务时可以传入不同的参数</li></ul><p>我们创建2个任务，使用同一个函数，代码如下：</p><pre class="line-numbers language-none"><code class="language-none">void vTaskFunction( void *pvParameters )&#123;const char *pcTaskText &#x3D; pvParameters;volatile uint32_t ul; &#x2F;* volatile用来避免被优化掉 *&#x2F;&#x2F;* 任务函数的主体一般都是无限循环 *&#x2F;for( ;; )&#123;&#x2F;* 打印任务的信息 *&#x2F;printf(pcTaskText);&#x2F;* 延迟一会(比较简单粗暴) *&#x2F;for( ul &#x3D; 0; ul &lt; mainDELAY_LOOP_COUNT; ul++ )&#123;&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码中的<code>pcTaskText</code>来自参数<code>pvParameters</code>，<code>pvParameters</code>来自哪里？创建任务时传入的。</p><p>代码如下：</p><ul><li>使用xTaskCreate创建2个任务时，第4个参数就是pvParameters</li><li>不同的任务，pvParameters不一样</li></ul><pre class="line-numbers language-none"><code class="language-none">static const char *pcTextForTask1 &#x3D; &quot;T1 run\r\n&quot;;static const char *pcTextForTask2 &#x3D; &quot;T2 run\r\n&quot;;int main( void )&#123;prvSetupHardware();xTaskCreate(vTaskFunction, &quot;Task 1&quot;, 1000, (void *)pcTextForTask1, 1, NULL);xTaskCreate(vTaskFunction, &quot;Task 2&quot;, 1000, (void *)pcTextForTask2, 1, NULL);&#x2F;* 启动调度器 *&#x2F;vTaskStartScheduler();&#x2F;* 如果程序运行到了这里就表示出错了, 一般是内存不足 *&#x2F;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-5-任务的删除"><a href="#3-2-5-任务的删除" class="headerlink" title="3.2.5 任务的删除"></a>3.2.5 任务的删除</h3><p>删除任务时使用的函数如下：</p><pre class="line-numbers language-none"><code class="language-none">void vTaskDelete( TaskHandle_t xTaskToDelete );<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参数说明：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>pvTaskCode</td><td>任务句柄，使用xTaskCreate创建任务时可以得到一个句柄。 也可传入NULL，这表示删除自己。</td></tr></tbody></table><p>怎么删除任务？举个不好的例子：</p><ul><li>自杀：<code>vTaskDelete(NULL)</code></li><li>被杀：别的任务执行<code>vTaskDelete(pvTaskCode)</code>，pvTaskCode是自己的句柄</li><li>杀人：执行<code>vTaskDelete(pvTaskCode)</code>，pvTaskCode是别的任务的句柄</li></ul><h3 id="3-2-6-示例3-删除任务"><a href="#3-2-6-示例3-删除任务" class="headerlink" title="3.2.6 示例3: 删除任务"></a>3.2.6 示例3: 删除任务</h3><p>代码为：<code>FreeRTOS_03_delete_task</code></p><p>本节代码会涉及优先级的知识，可以只看vTaskDelete的用法，忽略优先级的讲解。</p><p>我们要做这些事情：</p><ul><li>创建任务1：任务1的大循环里，创建任务2，然后休眠一段时间</li><li>任务2：打印一句话，然后就删除自己</li></ul><p>任务1的代码如下：</p><pre class="line-numbers language-none"><code class="language-none">void vTask1( void *pvParameters )&#123;const TickType_t xDelay100ms &#x3D; pdMS_TO_TICKS( 100UL );BaseType_t ret;&#x2F;* 任务函数的主体一般都是无限循环 *&#x2F;for( ;; )&#123;&#x2F;* 打印任务的信息 *&#x2F;printf(&quot;Task1 is running\r\n&quot;);ret &#x3D; xTaskCreate( vTask2, &quot;Task 2&quot;, 1000, NULL, 2, &amp;xTask2Handle );if (ret !&#x3D; pdPASS)printf(&quot;Create Task2 Failed\r\n&quot;);&#x2F;&#x2F; 如果不休眠的话, Idle任务无法得到执行&#x2F;&#x2F; Idel任务会清理任务2使用的内存&#x2F;&#x2F; 如果不休眠则Idle任务无法执行, 最后内存耗尽vTaskDelay( xDelay100ms );&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>任务2的代码如下：</p><pre class="line-numbers language-none"><code class="language-none">void vTask2( void *pvParameters )&#123;&#x2F;* 打印任务的信息 *&#x2F;printf(&quot;Task2 is running and about to delete itself\r\n&quot;);&#x2F;&#x2F; 可以直接传入参数NULL, 这里只是为了演示函数用法vTaskDelete(xTask2Handle);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>main函数代码如下：</p><pre class="line-numbers language-none"><code class="language-none">int main( void )&#123;prvSetupHardware();xTaskCreate(vTask1, &quot;Task 1&quot;, 1000, NULL, 1, NULL);&#x2F;* 启动调度器 *&#x2F;vTaskStartScheduler();&#x2F;* 如果程序运行到了这里就表示出错了, 一般是内存不足 *&#x2F;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果如下：</p><p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/04_delete_task.png"></p><p>任务运行图：</p><ul><li>main函数中创建任务1，优先级为1。任务1运行时，它创建任务2，任务2的优先级是2。</li><li>任务2的优先级最高，它马上执行。</li><li>任务2打印一句话后，就删除了自己。</li><li>任务2被删除后，任务1的优先级最高，轮到任务1继续运行，它调用<code>vTaskDelay() </code>进入Block状态</li><li>任务1 Block期间，轮到Idle任务执行：它释放任务2的内存(TCB、栈)</li><li>时间到后，任务1变为最高优先级的任务继续执行。</li><li>如此循环。</li></ul><p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/06_task_schedul_for_delete.png"></p><p>在任务1的函数中，如果不调用vTaskDelay，则Idle任务用于没有机会执行，它就无法释放创建任务2是分配的内存。</p><p>而任务1在不断地创建任务，不断地消耗内存，最终内存耗尽再也无法创建新的任务。</p><p>现象如下：</p><p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/07_create_task_fail.png"></p><p>任务1的代码中，需要注意的是：xTaskCreate的返回值。</p><ul><li>很多手册里说它失败时返回值是pdFAIL，这个宏是0</li><li>其实失败时返回值是errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY，这个宏是-1</li><li>为了避免混淆，我们使用返回值跟pdPASS来比较，这个宏是1</li></ul><h2 id="3-3-任务优先级和Tick"><a href="#3-3-任务优先级和Tick" class="headerlink" title="3.3 任务优先级和Tick"></a>3.3 任务优先级和Tick</h2><h3 id="3-3-1-任务优先级"><a href="#3-3-1-任务优先级" class="headerlink" title="3.3.1 任务优先级"></a>3.3.1 任务优先级</h3><p>在上个示例中我们体验过优先级的使用：高优先级的任务先运行。</p><p>优先级的取值范围是：0~(configMAX_PRIORITIES – 1)，数值越大优先级越高。</p><p>FreeRTOS的调度器可以使用2种方法来快速找出优先级最高的、可以运行的任务。使用不同的方法时，configMAX_PRIORITIES 的取值有所不同。</p><ul><li>通用方法 使用C函数实现，对所有的架构都是同样的代码。对configMAX_PRIORITIES的取值没有限制。但是configMAX_PRIORITIES的取值还是尽量小，因为取值越大越浪费内存，也浪费时间。 configUSE_PORT_OPTIMISED_TASK_SELECTION被定义为0、或者未定义时，使用此方法。</li><li>架构相关的优化的方法 架构相关的汇编指令，可以从一个32位的数里快速地找出为1的最高位。使用这些指令，可以快速找出优先级最高的、可以运行的任务。 使用这种方法时，configMAX_PRIORITIES的取值不能超过32。 configUSE_PORT_OPTIMISED_TASK_SELECTION被定义为1时，使用此方法。</li></ul><p>在学习调度方法之前，你只要初略地知道：</p><ul><li>FreeRTOS会确保最高优先级的、可运行的任务，马上就能执行</li><li>对于相同优先级的、可运行的任务，轮流执行</li></ul><p>这无需记忆，就像我们举的例子：</p><ul><li>厨房着火了，当然优先灭火</li><li>喂饭、回复信息同样重要，轮流做</li></ul><h3 id="3-3-2-Tick"><a href="#3-3-2-Tick" class="headerlink" title="3.3.2 Tick"></a>3.3.2 Tick</h3><p>对于同优先级的任务，它们“轮流”执行。怎么轮流？你执行一会，我执行一会。</p><p>“一会”怎么定义？</p><p>人有心跳，心跳间隔基本恒定。</p><p>FreeRTOS中也有心跳，它使用定时器产生固定间隔的中断。这叫Tick、滴答，比如每10ms发生一次时钟中断。</p><p>如下图：</p><ul><li>假设t1、t2、t3发生时钟中断</li><li>两次中断之间的时间被称为时间片(time slice、tick period)</li><li>时间片的长度由configTICK_RATE_HZ 决定，假设configTICK_RATE_HZ为100，那么时间片长度就是10ms</li></ul><p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/08_time_tick.png"></p><p>相同优先级的任务怎么切换呢？请看下图：</p><ul><li>任务2从t1执行到t2</li><li>在t2发生tick中断，进入tick中断处理函数：<ul><li>选择下一个要运行的任务</li><li>执行完中断处理函数后，切换到新的任务：任务1</li></ul></li><li>任务1从t2执行到t3</li><li>从下图中可以看出，任务运行的时间并不是严格从t1,t2,t3哪里开始</li></ul><p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/09_tick_interrtups.png"></p><p>有了Tick的概念后，我们就可以使用Tick来衡量时间了，比如：</p><pre class="line-numbers language-none"><code class="language-none">vTaskDelay(2);  &#x2F;&#x2F; 等待2个Tick，假设configTICK_RATE_HZ&#x3D;100, Tick周期时10ms, 等待20ms&#x2F;&#x2F; 还可以使用pdMS_TO_TICKS宏把ms转换为tickvTaskDelay(pdMS_TO_TICKS(100)); &#x2F;&#x2F; 等待100ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注意，基于Tick实现的延时并不精确，比如<code>vTaskDelay(2)</code>的本意是延迟2个Tick周期，有可能经过1个Tick多一点就返回了。</p><p>如下图：</p><p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/10_taskdelay.png"></p><p>使用vTaskDelay函数时，建议以ms为单位，使用pdMS_TO_TICKS把时间转换为Tick。</p><p>这样的代码就与configTICK_RATE_HZ无关，即使配置项configTICK_RATE_HZ改变了，我们也不用去修改代码。</p><h3 id="3-3-3-示例4-优先级实验"><a href="#3-3-3-示例4-优先级实验" class="headerlink" title="3.3.3 示例4: 优先级实验"></a>3.3.3 示例4: 优先级实验</h3><p>代码为：<code>FreeRTOS_04_task_priority</code></p><p>本程序会创建3个任务：</p><ul><li>任务1、任务2：优先级相同，都是1</li><li>任务3：优先级最高，是2</li></ul><p>任务1、2代码如下：</p><pre class="line-numbers language-none"><code class="language-none">void vTask1( void *pvParameters )&#123;&#x2F;* 任务函数的主体一般都是无限循环 *&#x2F;for( ;; )&#123;&#x2F;* 打印任务的信息 *&#x2F;printf(&quot;T1\r\n&quot;);&#125;&#125;void vTask2( void *pvParameters )&#123;&#x2F;* 任务函数的主体一般都是无限循环 *&#x2F;for( ;; )&#123;&#x2F;* 打印任务的信息 *&#x2F;printf(&quot;T2\r\n&quot;);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>任务3代码如下：</p><pre class="line-numbers language-none"><code class="language-none">void vTask3( void *pvParameters )&#123;const TickType_t xDelay3000ms &#x3D; pdMS_TO_TICKS( 3000UL );&#x2F;* 任务函数的主体一般都是无限循环 *&#x2F;for( ;; )&#123;&#x2F;* 打印任务的信息 *&#x2F;printf(&quot;T3\r\n&quot;);&#x2F;&#x2F; 如果不休眠的话, 其他任务无法得到执行vTaskDelay( xDelay3000ms );&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>main函数代码如下：</p><pre class="line-numbers language-none"><code class="language-none">&#123;prvSetupHardware();xTaskCreate(vTask1, &quot;Task 1&quot;, 1000, NULL, 1, NULL);xTaskCreate(vTask2, &quot;Task 2&quot;, 1000, NULL, 1, NULL);xTaskCreate(vTask3, &quot;Task 3&quot;, 1000, NULL, 2, NULL);&#x2F;* 启动调度器 *&#x2F;vTaskStartScheduler();&#x2F;* 如果程序运行到了这里就表示出错了, 一般是内存不足 *&#x2F;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行情况如下图所示：</p><ul><li>任务3优先执行，直到它调用vTaskDelay主动放弃运行</li><li>任务1、任务2：轮流执行</li></ul><p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/11_priority_result.png"></p><p>调度情况如下图所示：</p><p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/12_priority_scheduler.png"></p><h3 id="3-3-4-示例5-修改优先级"><a href="#3-3-4-示例5-修改优先级" class="headerlink" title="3.3.4 示例5: 修改优先级"></a>3.3.4 示例5: 修改优先级</h3><p>本节代码为：<code>FreeRTOS_05_change_priority</code>。</p><p>使用uxTaskPriorityGet来获得任务的优先级：</p><pre class="line-numbers language-none"><code class="language-none">UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask );<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用参数xTask来指定任务，设置为NULL表示获取自己的优先级。</p><p>使用vTaskPrioritySet 来设置任务的优先级：</p><pre class="line-numbers language-none"><code class="language-none">void vTaskPrioritySet( TaskHandle_t xTask,                       UBaseType_t uxNewPriority );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使用参数xTask来指定任务，设置为NULL表示设置自己的优先级； 参数uxNewPriority表示新的优先级，取值范围是0~(configMAX_PRIORITIES – 1)。</p><p>main函数的代码如下，它创建了2个任务：任务1的优先级更高，它先执行：</p><pre class="line-numbers language-none"><code class="language-none">int main( void )&#123;prvSetupHardware();&#x2F;* Task1的优先级更高, Task1先执行 *&#x2F;xTaskCreate( vTask1, &quot;Task 1&quot;, 1000, NULL, 2, NULL );xTaskCreate( vTask2, &quot;Task 2&quot;, 1000, NULL, 1, &amp;xTask2Handle );&#x2F;* 启动调度器 *&#x2F;vTaskStartScheduler();&#x2F;* 如果程序运行到了这里就表示出错了, 一般是内存不足 *&#x2F;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>任务1的代码如下：</p><pre class="line-numbers language-none"><code class="language-none">void vTask1( void *pvParameters )&#123;UBaseType_t uxPriority;&#x2F;* Task1,Task2都不会进入阻塞或者暂停状态 * 根据优先级决定谁能运行 *&#x2F;&#x2F;* 得到Task1自己的优先级 *&#x2F;uxPriority &#x3D; uxTaskPriorityGet( NULL );for( ;; )&#123;printf( &quot;Task 1 is running\r\n&quot; );printf(&quot;About to raise the Task 2 priority\r\n&quot; );&#x2F;* 提升Task2的优先级高于Task1 * Task2会即刻执行  *&#x2F;vTaskPrioritySet( xTask2Handle, ( uxPriority + 1 ) );&#x2F;* 如果Task1能运行到这里，表示它的优先级比Task2高* 那就表示Task2肯定把自己的优先级降低了  *&#x2F;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>任务2的代码如下：</p><pre class="line-numbers language-none"><code class="language-none">void vTask2( void *pvParameters )&#123;UBaseType_t uxPriority;&#x2F;* Task1,Task2都不会进入阻塞或者暂停状态 * 根据优先级决定谁能运行 *&#x2F;&#x2F;* 得到Task2自己的优先级 *&#x2F;uxPriority &#x3D; uxTaskPriorityGet( NULL );for( ;; )&#123;&#x2F;* 能运行到这里表示Task2的优先级高于Task1 * Task1提高了Task2的优先级 *&#x2F;printf( &quot;Task 2 is running\r\n&quot; );printf( &quot;About to lower the Task 2 priority\r\n&quot; );&#x2F;* 降低Task2自己的优先级，让它小于Task1 * Task1得以运行  *&#x2F;vTaskPrioritySet( NULL, ( uxPriority - 2 ) );&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调度情况如下图所示：</p><ul><li>1：一开始Task1优先级最高，它先执行。它提升了Task2的优先级。</li><li>2：Task2的优先级最高，它执行。它把自己的优先级降低了。</li><li>3：Task1的优先级最高，再次执行。它提升了Task2的优先级。</li><li>如此循环。</li><li>注意：Task1的优先级一直是2，Task2的优先级是3或1，都大于0。所以Idel任务没有机会执行。</li></ul><p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/15_change_priority.png"></p><h2 id="3-4-任务状态"><a href="#3-4-任务状态" class="headerlink" title="3.4 任务状态"></a>3.4 任务状态</h2><p>以前我们很简单地把任务的状态分为2中：运行(Runing)、非运行(Not Running)。</p><p>对于非运行的状态，还可以继续细分，比如前面的<code>FreeRTOS_04_task_priority</code>中：</p><ul><li>Task3执行vTaskDelay后：处于非运行状态，要过3秒种才能再次运行</li><li>Task3运行期间，Task1、Task2也处于非运行状态，但是它们<strong>随时可以运行</strong></li><li>这两种”非运行”状态就不一样，可以细分为：<ul><li>阻塞状态(Blocked)</li><li>暂停状态(Suspended)</li><li>就绪状态(Ready)</li></ul></li></ul><h3 id="3-4-1-阻塞状态-Blocked"><a href="#3-4-1-阻塞状态-Blocked" class="headerlink" title="3.4.1 阻塞状态(Blocked)"></a>3.4.1 阻塞状态(Blocked)</h3><p>在日常生活的例子中，母亲在电脑前跟同事沟通时，如果同事一直没回复，那么母亲的工作就被卡住了、被堵住了、处于阻塞状态(Blocked)。重点在于：母亲在<strong>等待</strong>。</p><p>在<code>FreeRTOS_04_task_priority</code>实验中，如果把任务3中的vTaskDelay调用注释掉，那么任务1、任务2根本没有执行的机会，任务1、任务2被”饿死”了(starve)。</p><p>在实际产品中，我们不会让一个任务一直运行，而是使用”事件驱动”的方法让它运行：</p><ul><li>任务要等待某个事件，事件发生后它才能运行</li><li>在等待事件过程中，它不消耗CPU资源</li><li>在等待事件的过程中，这个任务就处于阻塞状态(Blocked)</li></ul><p>在阻塞状态的任务，它可以等待两种类型的事件：</p><ul><li>时间相关的事件<ul><li>可以等待一段时间：我等2分钟</li><li>也可以一直等待，直到某个绝对时间：我等到下午3点</li></ul></li><li>同步事件：这事件由别的任务，或者是中断程序产生<ul><li>例子1：任务A等待任务B给它发送数据</li><li>例子2：任务A等待用户按下按键</li><li>同步事件的来源有很多(这些概念在后面会细讲)：<ul><li>队列(queue)</li><li>二进制信号量(binary semaphores)</li><li>计数信号量(counting semaphores)</li><li>互斥量(mutexes)</li><li>递归互斥量、递归锁(recursive mutexes)</li><li>事件组(event groups)</li><li>任务通知(task notifications)</li></ul></li></ul></li></ul><p>在等待一个同步事件时，可以加上超时时间。比如等待队里数据，超时时间设为10ms：</p><ul><li>10ms之内有数据到来：成功返回</li><li>10ms到了，还是没有数据：超时返回</li></ul><h3 id="3-4-2-暂停状态-Suspended"><a href="#3-4-2-暂停状态-Suspended" class="headerlink" title="3.4.2 暂停状态(Suspended)"></a>3.4.2 暂停状态(Suspended)</h3><p>在日常生活的例子中，母亲正在电脑前跟同事沟通，母亲可以暂停：</p><ul><li>好烦啊，我暂停一会</li><li>领导说：你暂停一下</li></ul><p>FreeRTOS中的任务也可以进入暂停状态，唯一的方法是通过vTaskSuspend函数。函数原型如下：</p><pre class="line-numbers language-none"><code class="language-none">void vTaskSuspend( TaskHandle_t xTaskToSuspend );<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参数xTaskToSuspend表示要暂停的任务，如果为NULL，表示暂停自己。</p><p>要退出暂停状态，只能由<strong>别人</strong>来操作：</p><ul><li>别的任务调用：vTaskResume</li><li>中断程序调用：xTaskResumeFromISR</li></ul><p>实际开发中，暂停状态用得不多。</p><h3 id="3-4-3-就绪状态-Ready"><a href="#3-4-3-就绪状态-Ready" class="headerlink" title="3.4.3 就绪状态(Ready)"></a>3.4.3 就绪状态(Ready)</h3><p>这个任务完全准备好了，随时可以运行：只是还轮不到它。这时，它就处于就绪态(Ready)。</p><h3 id="3-4-4-完整的状态转换图"><a href="#3-4-4-完整的状态转换图" class="headerlink" title="3.4.4 完整的状态转换图"></a>3.4.4 完整的状态转换图</h3><p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/13_full_task_state_machine.png"></p><h2 id="3-5-Delay函数"><a href="#3-5-Delay函数" class="headerlink" title="3.5 Delay函数"></a>3.5 Delay函数</h2><h3 id="3-5-1-两个Delay函数"><a href="#3-5-1-两个Delay函数" class="headerlink" title="3.5.1 两个Delay函数"></a>3.5.1 两个Delay函数</h3><p>有两个Delay函数：</p><ul><li>vTaskDelay：至少等待指定个数的Tick Interrupt才能变为就绪状态</li><li>vTaskDelayUntil：等待到指定的绝对时刻，才能变为就绪态。</li></ul><p>这2个函数原型如下：</p><pre class="line-numbers language-none"><code class="language-none">void vTaskDelay( const TickType_t xTicksToDelay ); &#x2F;* xTicksToDelay: 等待多少给Tick *&#x2F;&#x2F;* pxPreviousWakeTime: 上一次被唤醒的时间 * xTimeIncrement: 要阻塞到(pxPreviousWakeTime + xTimeIncrement) * 单位都是Tick Count *&#x2F;BaseType_t xTaskDelayUntil( TickType_t * const pxPreviousWakeTime,                            const TickType_t xTimeIncrement );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面画图说明：</p><ul><li>使用vTaskDelay(n)时，进入、退出vTaskDelay的时间间隔至少是n个Tick中断</li><li>使用xTaskDelayUntil(&amp;Pre, n)时，前后两次退出xTaskDelayUntil的时间至少是n个Tick中断<ul><li>退出xTaskDelayUntil时任务就进入的就绪状态，一般都能得到执行机会</li><li>所以可以使用xTaskDelayUntil来让任务周期性地运行</li></ul></li></ul><p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/14_delay_functions.png"></p><h3 id="3-5-2-示例6-Delay"><a href="#3-5-2-示例6-Delay" class="headerlink" title="3.5.2 示例6: Delay"></a>3.5.2 示例6: Delay</h3><p>本节代码为：<code>FreeRTOS_06_taskdelay</code>。</p><p>本程序会创建2个任务：</p><ul><li>Task1：<ul><li>高优先级</li><li>设置变量flag为1，然后调用<code>vTaskDelay(xDelay50ms);</code>或<code>vTaskDelayUntil(&amp;xLastWakeTime, xDelay50ms);</code></li></ul></li><li>Task2：<ul><li>低优先级</li><li>设置变量flag为0</li></ul></li></ul><p>main函数代码如下：</p><pre class="line-numbers language-none"><code class="language-none">int main( void )&#123;prvSetupHardware();&#x2F;* Task1的优先级更高, Task1先执行 *&#x2F;xTaskCreate( vTask1, &quot;Task 1&quot;, 1000, NULL, 2, NULL );xTaskCreate( vTask2, &quot;Task 2&quot;, 1000, NULL, 1, NULL );&#x2F;* 启动调度器 *&#x2F;vTaskStartScheduler();&#x2F;* 如果程序运行到了这里就表示出错了, 一般是内存不足 *&#x2F;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Task1的代码中使用条件开关来选择Delay函数，把<code>#if 1</code>改为<code>#if 0</code>就可以使用<code>vTaskDelayUntil</code>，代码如下：</p><pre class="line-numbers language-none"><code class="language-none">void vTask1( void *pvParameters )&#123;const TickType_t xDelay50ms &#x3D; pdMS_TO_TICKS( 50UL );TickType_t xLastWakeTime;int i;&#x2F;* 获得当前的Tick Count *&#x2F;xLastWakeTime &#x3D; xTaskGetTickCount();for( ;; )&#123;flag &#x3D; 1;&#x2F;* 故意加入多个循环，让程序运行时间长一点 *&#x2F;for (i &#x3D; 0; i &lt;5; i++)printf( &quot;Task 1 is running\r\n&quot; );#if 1vTaskDelay(xDelay50ms);#elsevTaskDelayUntil(&amp;xLastWakeTime, xDelay50ms);#endif&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Task2的代码如下：</p><pre class="line-numbers language-none"><code class="language-none">void vTask2( void *pvParameters )&#123;for( ;; )&#123;flag &#x3D; 0;printf( &quot;Task 2 is running\r\n&quot; );&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用Keil的逻辑分析观察flag变量的bit波形，如下：</p><ul><li>flag为1时表示Task1在运行，flag为0时表示Task2在运行，也就是Task1处于阻塞状态</li><li>vTaskDelay：指定的是阻塞的时间</li><li>vTaskDelayUntil：指定的是任务执行的间隔、周期</li></ul><p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/16_delay_time.png"></p><h2 id="3-6-空闲任务及其钩子函数"><a href="#3-6-空闲任务及其钩子函数" class="headerlink" title="3.6 空闲任务及其钩子函数"></a>3.6 空闲任务及其钩子函数</h2><h3 id="3-6-1-介绍"><a href="#3-6-1-介绍" class="headerlink" title="3.6.1 介绍"></a>3.6.1 介绍</h3><p>在<code>FreeRTOS_03_delete_task</code>的实验里，我们体验过空闲任务(Idle任务)的作用：释放被删除的任务的内存。</p><p>除了上述目的之外，为什么必须要有空闲任务？一个良好的程序，它的任务都是事件驱动的：平时大部分时间处于阻塞状态。有可能我们自己创建的所有任务都无法执行，但是调度器必须能找到一个可以运行的任务：所以，我们要提供空闲任务。在使用<code>vTaskStartScheduler() </code>函数来创建、启动调度器时，这个函数内部会创建空闲任务：</p><ul><li>空闲任务优先级为0：它不能阻碍用户任务运行</li><li>空闲任务要么处于就绪态，要么处于运行态，永远不会阻塞</li></ul><p>空闲任务的优先级为0，这意味着一旦某个用户的任务变为就绪态，那么空闲任务马上被切换出去，让这个用户任务运行。在这种情况下，我们说用户任务”抢占”(pre-empt)了空闲任务，这是由调度器实现的。</p><p>要注意的是：如果使用<code>vTaskDelete() </code>来删除任务，那么你就要确保空闲任务有机会执行，否则就无法释放被删除任务的内存。</p><p>我们可以添加一个空闲任务的钩子函数(Idle Task Hook Functions)，空闲任务的循环每执行一次，就会调用一次钩子函数。钩子函数的作用有这些：</p><ul><li>执行一些低优先级的、后台的、需要连续执行的函数</li><li>测量系统的空闲时间：空闲任务能被执行就意味着所有的高优先级任务都停止了，所以测量空闲任务占据的时间，就可以算出处理器占用率。</li><li>让系统进入省电模式：空闲任务能被执行就意味着没有重要的事情要做，当然可以进入省电模式了。</li></ul><p>空闲任务的钩子函数的限制：</p><ul><li>不能导致空闲任务进入阻塞状态、暂停状态</li><li>如果你会使用<code>vTaskDelete() </code>来删除任务，那么钩子函数要非常高效地执行。如果空闲任务移植卡在钩子函数里的话，它就无法释放内存。</li></ul><h3 id="3-6-2-使用钩子函数的前提"><a href="#3-6-2-使用钩子函数的前提" class="headerlink" title="3.6.2 使用钩子函数的前提"></a>3.6.2 使用钩子函数的前提</h3><p>在<code>FreeRTOS\Source\tasks.c</code>中，可以看到如下代码，所以前提就是：</p><ul><li>把这个宏定义为1：configUSE_IDLE_HOOK</li><li>实现<code>vApplicationIdleHook</code>函数</li></ul><p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/17_idle_hook.png"></p><h2 id="3-7-调度算法"><a href="#3-7-调度算法" class="headerlink" title="3.7 调度算法"></a>3.7 调度算法</h2><h3 id="3-7-1-重要概念"><a href="#3-7-1-重要概念" class="headerlink" title="3.7.1 重要概念"></a>3.7.1 重要概念</h3><p>这些知识在前面都提到过了，这里总结一下。</p><p>正在运行的任务，被称为”正在使用处理器”，它处于运行状态。在单处理系统中，任何时间里只能有一个任务处于运行状态。</p><p>非运行状态的任务，它处于这3中状态之一：阻塞(Blocked)、暂停(Suspended)、就绪(Ready)。就绪态的任务，可以被调度器挑选出来切换为运行状态，调度器永远都是挑选最高优先级的就绪态任务并让它进入运行状态。</p><p>阻塞状态的任务，它在等待”事件”，当事件发生时任务就会进入就绪状态。事件分为两类：时间相关的事件、同步事件。所谓时间相关的事件，就是设置超时时间：在指定时间内阻塞，时间到了就进入就绪状态。使用时间相关的事件，可以实现周期性的功能、可以实现超时功能。同步事件就是：某个任务在等待某些信息，别的任务或者中断服务程序会给它发送信息。怎么”发送信息”？方法很多，有：任务通知(task notification)、队列(queue)、事件组(event group)、信号量(semaphoe)、互斥量(mutex)等。这些方法用来发送同步信息，比如表示某个外设得到了数据。</p><h3 id="3-7-2-配置调度算法"><a href="#3-7-2-配置调度算法" class="headerlink" title="3.7.2 配置调度算法"></a>3.7.2 配置调度算法</h3><p>所谓调度算法，就是怎么确定哪个就绪态的任务可以切换为运行状态。</p><p>通过配置文件FreeRTOSConfig.h的两个配置项来配置调度算法：configUSE_PREEMPTION、configUSE_TIME_SLICING。</p><p>还有第三个配置项：configUSE_TICKLESS_IDLE，它是一个高级选项，用于关闭Tick中断来实现省电，后续单独讲解。现在我们假设configUSE_TICKLESS_IDLE被设为0，先不使用这个功能。</p><p>调度算法的行为主要体现在两方面：高优先级的任务先运行、同优先级的就绪态任务如何被选中。调度算法要确保同优先级的就绪态任务，能”轮流”运行，策略是”轮转调度”(Round Robin Scheduling)。轮转调度并不保证任务的运行时间是公平分配的，我们还可以细化时间的分配方法。</p><p>从3个角度统一理解多种调度算法：</p><ul><li>可否抢占？高优先级的任务能否优先执行(配置项: configUSE_PREEMPTION)<ul><li>可以：被称作”可抢占调度”(Pre-emptive)，高优先级的就绪任务马上执行，下面再细化。</li><li>不可以：不能抢就只能协商了，被称作”合作调度模式”(Co-operative Scheduling)<ul><li>当前任务执行时，更高优先级的任务就绪了也不能马上运行，只能等待当前任务主动让出CPU资源。</li><li>其他同优先级的任务也只能等待：更高优先级的任务都不能抢占，平级的更应该老实点</li></ul></li></ul></li><li>可抢占的前提下，同优先级的任务是否轮流执行(配置项：configUSE_TIME_SLICING)<ul><li>轮流执行：被称为”时间片轮转”(Time Slicing)，同优先级的任务轮流执行，你执行一个时间片、我再执行一个时间片</li><li>不轮流执行：英文为”without Time Slicing”，当前任务会一直执行，直到主动放弃、或者被高优先级任务抢占</li></ul></li><li>在”可抢占”+”时间片轮转”的前提下，进一步细化：空闲任务是否让步于用户任务(配置项：configIDLE_SHOULD_YIELD)<ul><li>空闲任务低人一等，每执行一次循环，就看看是否主动让位给用户任务</li><li>空闲任务跟用户任务一样，大家轮流执行，没有谁更特殊</li></ul></li></ul><p>列表如下：</p><table><thead><tr><th>配置项</th><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th></tr></thead><tbody><tr><td>configUSE_PREEMPTION</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td></tr><tr><td>configUSE_TIME_SLICING</td><td>1</td><td>1</td><td>0</td><td>0</td><td>x</td></tr><tr><td>configIDLE_SHOULD_YIELD</td><td>1</td><td>0</td><td>1</td><td>0</td><td>x</td></tr><tr><td>说明</td><td>常用</td><td>很少用</td><td>很少用</td><td>很少用</td><td>几乎不用</td></tr></tbody></table><p>注：</p><ul><li>A：可抢占+时间片轮转+空闲任务让步</li><li>B：可抢占+时间片轮转+空闲任务不让步</li><li>C：可抢占+非时间片轮转+空闲任务让步</li><li>D：可抢占+非时间片轮转+空闲任务不让步</li><li>E：合作调度</li></ul><h3 id="3-7-3-示例7-调度"><a href="#3-7-3-示例7-调度" class="headerlink" title="3.7.3 示例7: 调度"></a>3.7.3 示例7: 调度</h3><p>本节代码为：<code>FreeRTOS_07_scheduler</code>。后续的实验都是基于这个程序，通过修改配置项来观察效果。</p><p>代码里创建了3个任务：Task1、Task2的优先级都是0，跟空闲任务一样，Task3优先级最高为2。程序里定义了4个全局变量，当某个的任务执行时，对应的变量就被设为1，可以通过Keil的逻辑分析仪查看任务切换情况：</p><pre class="line-numbers language-none"><code class="language-none">static volatile int flagIdleTaskrun &#x3D; 0;  &#x2F;&#x2F; 空闲任务运行时flagIdleTaskrun&#x3D;1static volatile int flagTask1run &#x3D; 0;     &#x2F;&#x2F; 任务1运行时flagTask1run&#x3D;1static volatile int flagTask2run &#x3D; 0;     &#x2F;&#x2F; 任务2运行时flagTask2run&#x3D;1static volatile int flagTask3run &#x3D; 0;     &#x2F;&#x2F; 任务3运行时flagTask3run&#x3D;1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>main函数代码如下：</p><pre class="line-numbers language-none"><code class="language-none">int main( void )&#123;prvSetupHardware();xTaskCreate(vTask1, &quot;Task 1&quot;, 1000, NULL, 0, NULL);xTaskCreate(vTask2, &quot;Task 2&quot;, 1000, NULL, 0, NULL);xTaskCreate(vTask3, &quot;Task 3&quot;, 1000, NULL, 2, NULL);&#x2F;* 启动调度器 *&#x2F;vTaskStartScheduler();&#x2F;* 如果程序运行到了这里就表示出错了, 一般是内存不足 *&#x2F;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>任务1、任务2代码如下，它们是”连续任务”(continuous task)：</p><pre class="line-numbers language-none"><code class="language-none">void vTask1( void *pvParameters )&#123;&#x2F;* 任务函数的主体一般都是无限循环 *&#x2F;for( ;; )&#123;flagIdleTaskrun &#x3D; 0;flagTask1run &#x3D; 1;flagTask2run &#x3D; 0;flagTask3run &#x3D; 0;&#x2F;* 打印任务的信息 *&#x2F;printf(&quot;T1\r\n&quot;);&#125;&#125;void vTask2( void *pvParameters )&#123;&#x2F;* 任务函数的主体一般都是无限循环 *&#x2F;for( ;; )&#123;flagIdleTaskrun &#x3D; 0;flagTask1run &#x3D; 0;flagTask2run &#x3D; 1;flagTask3run &#x3D; 0;&#x2F;* 打印任务的信息 *&#x2F;printf(&quot;T2\r\n&quot;);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>任务3代码如下，它会调用<code>vTaskDelay</code>，这样别的任务才可以运行：</p><pre class="line-numbers language-none"><code class="language-none">void vTask3( void *pvParameters )&#123;const TickType_t xDelay5ms &#x3D; pdMS_TO_TICKS( 5UL );&#x2F;* 任务函数的主体一般都是无限循环 *&#x2F;for( ;; )&#123;flagIdleTaskrun &#x3D; 0;flagTask1run &#x3D; 0;flagTask2run &#x3D; 0;flagTask3run &#x3D; 1;&#x2F;* 打印任务的信息 *&#x2F;printf(&quot;T3\r\n&quot;);&#x2F;&#x2F; 如果不休眠的话, 其他任务无法得到执行vTaskDelay( xDelay5ms );&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>提供了一个空闲任务的钩子函数：</p><pre class="line-numbers language-none"><code class="language-none">void vApplicationIdleHook(void)&#123;flagIdleTaskrun &#x3D; 1;flagTask1run &#x3D; 0;flagTask2run &#x3D; 0;flagTask3run &#x3D; 0;&#x2F;* 故意加入打印让flagIdleTaskrun变为1的时间维持长一点 *&#x2F;printf(&quot;Id\r\n&quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-7-4-对比效果-抢占与否"><a href="#3-7-4-对比效果-抢占与否" class="headerlink" title="3.7.4 对比效果: 抢占与否"></a>3.7.4 对比效果: 抢占与否</h3><p>在<code>FreeRTOSConfig.h</code>中，定义这样的宏，对比逻辑分析仪的效果：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 实验1：抢占#define configUSE_PREEMPTION1#define configUSE_TIME_SLICING      1#define configIDLE_SHOULD_YIELD1&#x2F;&#x2F; 实验2：不抢占#define configUSE_PREEMPTION0#define configUSE_TIME_SLICING      1#define configIDLE_SHOULD_YIELD1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从下面的对比图可以知道：</p><ul><li>抢占时：高优先级任务就绪时，就可以马上执行</li><li>不抢占时：优先级失去意义了，既然不能抢占就只能协商了，图中任务1一直在运行(一点都没有协商精神)，其他任务都无法执行。即使任务3的<code>vTaskDelay</code>已经超时、即使它的优先级更高，都没办法执行。</li></ul><p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/18_pre-emptive_or_not.png"></p><h3 id="3-7-5-对比效果-时间片轮转与否"><a href="#3-7-5-对比效果-时间片轮转与否" class="headerlink" title="3.7.5 对比效果: 时间片轮转与否"></a>3.7.5 对比效果: 时间片轮转与否</h3><p>在<code>FreeRTOSConfig.h</code>中，定义这样的宏，对比逻辑分析仪的效果：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 实验1：时间片轮转#define configUSE_PREEMPTION1#define configUSE_TIME_SLICING      1#define configIDLE_SHOULD_YIELD1&#x2F;&#x2F; 实验2：时间片不轮转#define configUSE_PREEMPTION1#define configUSE_TIME_SLICING      0#define configIDLE_SHOULD_YIELD1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从下面的对比图可以知道：</p><ul><li>时间片轮转：在Tick中断中会引起任务切换</li><li>时间片不轮转：高优先级任务就绪时会引起任务切换，高优先级任务不再运行时也会引起任务切换。可以看到任务3就绪后可以马上执行，它运行完毕后导致任务切换。其他时间没有任务切换，可以看到任务1、任务2都运行了很长时间。</li></ul><p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/19_time_slicing_or_not.png"></p><h3 id="3-7-6-对比效果-空闲任务让步"><a href="#3-7-6-对比效果-空闲任务让步" class="headerlink" title="3.7.6 对比效果: 空闲任务让步"></a>3.7.6 对比效果: 空闲任务让步</h3><p>在<code>FreeRTOSConfig.h</code>中，定义这样的宏，对比逻辑分析仪的效果：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 实验1：空闲任务让步#define configUSE_PREEMPTION1#define configUSE_TIME_SLICING      1#define configIDLE_SHOULD_YIELD1&#x2F;&#x2F; 实验2：空闲任务不让步#define configUSE_PREEMPTION1#define configUSE_TIME_SLICING      1#define configIDLE_SHOULD_YIELD0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从下面的对比图可以知道：</p><ul><li>让步时：在空闲任务的每个循环中，会主动让出处理器，从图中可以看到flagIdelTaskrun的波形很小</li><li>不让步时：空闲任务跟任务1、任务2同等待遇，它们的波形宽度是差不多的</li></ul><p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/20_yield_or_not.png"></p><h1 id="4-同步互斥与通信"><a href="#4-同步互斥与通信" class="headerlink" title="4.同步互斥与通信"></a>4.同步互斥与通信</h1><h2 id="4-1-同步与互斥的概念"><a href="#4-1-同步与互斥的概念" class="headerlink" title="4.1 同步与互斥的概念"></a>4.1 同步与互斥的概念</h2><p>一句话理解同步与互斥：我等你用完厕所，我再用厕所。 什么叫同步？就是：哎哎哎，我正在用厕所，你等会。 什么叫互斥？就是：哎哎哎，我正在用厕所，你不能进来。 同步与互斥经常放在一起讲，是因为它们之的关系很大，“互斥”操作可以使用“同步”来实现。我“等”你用完厕所，我再用厕所。这不就是用“同步”来实现“互斥”吗？</p><p>再举一个例子。在团队活动里，同事A先写完报表，经理B才能拿去向领导汇报。经理B必须等同事A完成报表，AB之间有依赖，B必须放慢脚步，被称为同步。在团队活动中，同事A已经使用会议室了，经理B也想使用，即使经理B是领导，他也得等着，这就叫互斥。经理B跟同事A说：你用完会议室就提醒我。这就是使用”同步”来实现”互斥”。</p><p>有时候看代码更容易理解，伪代码如下：</p><pre class="line-numbers language-none"><code class="language-none">01 void  抢厕所(void)02 &#123;03    if (有人在用) 我眯一会;04    用厕所;05    喂，醒醒，有人要用厕所吗;06 &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>假设有A、B两人早起抢厕所，A先行一步占用了；B慢了一步，于是就眯一会；当A用完后叫醒B，B也就愉快地上厕所了。 在这个过程中，A、B是互斥地访问“厕所”，“厕所”被称之为临界资源。我们使用了“休眠-唤醒”的同步机制实现了“临界资源”的“互斥访问”。</p><p>同一时间只能有一个人使用的资源，被称为临界资源。比如任务A、B都要使用串口来打印，串口就是临界资源。如果A、B同时使用串口，那么打印出来的信息就是A、B混杂，无法分辨。所以使用串口时，应该是这样：A用完，B再用；B用完，A再用。</p><h2 id="4-2-同步与互斥并不简单"><a href="#4-2-同步与互斥并不简单" class="headerlink" title="4.2 同步与互斥并不简单"></a>4.2 同步与互斥并不简单</h2><h2 id="4-3-各类方法的对比"><a href="#4-3-各类方法的对比" class="headerlink" title="4.3 各类方法的对比"></a>4.3 各类方法的对比</h2><p>能实现同步、互斥的内核方法有：任务通知(task notification)、队列(queue)、事件组(event group)、信号量(semaphoe)、互斥量(mutex)。</p><p>它们都有类似的操作方法：获取&#x2F;释放、阻塞&#x2F;唤醒、超时。比如：</p><ul><li>A获取资源，用完后A释放资源</li><li>A获取不到资源则阻塞，B释放资源并把A唤醒</li><li>A获取不到资源则阻塞，并定个闹钟；A要么超时返回，要么在这段时间内因为B释放资源而被唤醒。</li></ul><p>这些内核对象五花八门，记不住怎么办？我也记不住，通过对比的方法来区分它们。</p><ul><li>能否传信息？只能传递状态？</li><li>为众生？只为你？</li><li>我生产，你们消费？</li><li>我上锁，只能由我开锁</li></ul><table><thead><tr><th>内核对象</th><th>生产者</th><th>消费者</th><th>数据&#x2F;状态</th><th>说明</th></tr></thead><tbody><tr><td>队列</td><td>ALL</td><td>ALL</td><td>数据：若干个数据 谁都可以往队列里扔数据， 谁都可以从队列里读数据</td><td>用来传递数据， 发送者、接收者无限制， 一个数据只能唤醒一个接收者</td></tr><tr><td>事件组</td><td>ALL</td><td>ALL</td><td>多个位：或、与 谁都可以设置(生产)多个位， 谁都可以等待某个位、若干个位</td><td>用来传递事件， 可以是N个事件， 发送者、接受者无限制， 可以唤醒多个接收者：像广播</td></tr><tr><td>信号量</td><td>ALL</td><td>ALL</td><td>数量：0~n 谁都可以增加一个数量， 谁都可消耗一个数量</td><td>用来维持资源的个数， 生产者、消费者无限制， 1个资源只能唤醒1个接收者</td></tr><tr><td>任务通知</td><td>ALL</td><td>只有我</td><td>数据、状态都可以传输， 使用任务通知时， 必须指定接受者</td><td>N对1的关系： 发送者无限制， 接收者只能是这个任务</td></tr><tr><td>互斥量</td><td>只能A开锁</td><td>A上锁</td><td>位：0、1 我上锁：1变为0， 只能由我开锁：0变为1</td><td>就像一个空厕所， 谁使用谁上锁， 也只能由他开锁</td></tr></tbody></table><p>使用图形对比如下：</p><ul><li>队列：<ul><li>里面可以放任意数据，可以放多个数据</li><li>任务、ISR都可以放入数据；任务、ISR都可以从中读出数据</li></ul></li><li>事件组：<ul><li>一个事件用一bit表示，1表示事件发生了，0表示事件没发生</li><li>可以用来表示事件、事件的组合发生了，不能传递数据</li><li>有广播效果：事件或事件的组合发生了，等待它的多个任务都会被唤醒</li></ul></li><li>信号量：<ul><li>核心是”计数值”</li><li>任务、ISR释放信号量时让计数值加1</li><li>任务、ISR获得信号量时，让计数值减1</li></ul></li><li>任务通知：<ul><li>核心是任务的TCB里的数值</li><li>会被覆盖</li><li>发通知给谁？必须指定接收任务</li><li>只能由接收任务本身获取该通知</li></ul></li><li>互斥量：<ul><li>数值只有0或1</li><li>谁获得互斥量，就必须由谁释放同一个互斥量</li></ul></li></ul><p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/01_compare_sync_objects.png"></p><h1 id="5-队列"><a href="#5-队列" class="headerlink" title="5.队列"></a>5.队列</h1><h2 id="5-1-队列的特性"><a href="#5-1-队列的特性" class="headerlink" title="5.1 队列的特性"></a>5.1 队列的特性</h2><h3 id="5-1-1-常规操作"><a href="#5-1-1-常规操作" class="headerlink" title="5.1.1 常规操作"></a>5.1.1 常规操作</h3><p>队列的简化操如入下图所示，从此图可知：</p><ul><li>队列可以包含若干个数据：队列中有若干项，这被称为”长度”(length)</li><li>每个数据大小固定</li><li>创建队列时就要指定长度、数据大小</li><li>数据的操作采用先进先出的方法(FIFO，First In First Out)：写数据时放到尾部，读数据时从头部读</li><li>也可以强制写队列头部：覆盖头部数据</li></ul><p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/02_queue.png"></p><p>更详细的操作入下图所示：</p><p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/03_queue_detail.png"></p><h3 id="5-1-2-传输数据的两种方法"><a href="#5-1-2-传输数据的两种方法" class="headerlink" title="5.1.2 传输数据的两种方法"></a>5.1.2 传输数据的两种方法</h3><p>使用队列传输数据时有两种方法：</p><ul><li>拷贝：把数据、把变量的值复制进队列里</li><li>引用：把数据、把变量的地址复制进队列里</li></ul><p>FreeRTOS使用拷贝值的方法，这更简单：</p><ul><li>局部变量的值可以发送到队列中，后续即使函数退出、局部变量被回收，也不会影响队列中的数据</li><li>无需分配buffer来保存数据，队列中有buffer</li><li>局部变量可以马上再次使用</li><li>发送任务、接收任务解耦：接收任务不需要知道这数据是谁的、也不需要发送任务来释放数据</li><li>如果数据实在太大，你还是可以使用队列传输它的地址</li><li>队列的空间有FreeRTOS内核分配，无需任务操心</li><li>对于有内存保护功能的系统，如果队列使用引用方法，也就是使用地址，必须确保双方任务对这个地址都有访问权限。使用拷贝方法时，则无此限制：内核有足够的权限，把数据复制进队列、再把数据复制出队列。</li></ul><h3 id="5-1-3-队列的阻塞访问"><a href="#5-1-3-队列的阻塞访问" class="headerlink" title="5.1.3 队列的阻塞访问"></a>5.1.3 队列的阻塞访问</h3><p>只要知道队列的句柄，谁都可以读、写该队列。任务、ISR都可读、写队列。可以多个任务读写队列。</p><p>任务读写队列时，简单地说：如果读写不成功，则阻塞；可以指定超时时间。口语化地说，就是可以定个闹钟：如果能读写了就马上进入就绪态，否则就阻塞直到超时。</p><p>某个任务读队列时，如果队列没有数据，则该任务可以进入阻塞状态：还可以指定阻塞的时间。如果队列有数据了，则该阻塞的任务会变为就绪态。如果一直都没有数据，则时间到之后它也会进入就绪态。</p><p>既然读取队列的任务个数没有限制，那么当多个任务读取空队列时，这些任务都会进入阻塞状态：有多个任务在等待同一个队列的数据。当队列中有数据时，哪个任务会进入就绪态？</p><ul><li>优先级最高的任务</li><li>如果大家的优先级相同，那等待时间最久的任务会进入就绪态</li></ul><p>跟读队列类似，一个任务要写队列时，如果队列满了，该任务也可以进入阻塞状态：还可以指定阻塞的时间。如果队列有空间了，则该阻塞的任务会变为就绪态。如果一直都没有空间，则时间到之后它也会进入就绪态。</p><p>既然写队列的任务个数没有限制，那么当多个任务写”满队列”时，这些任务都会进入阻塞状态：有多个任务在等待同一个队列的空间。当队列中有空间时，哪个任务会进入就绪态？</p><ul><li>优先级最高的任务</li><li>如果大家的优先级相同，那等待时间最久的任务会进入就绪态</li></ul><h2 id="5-2-队列函数"><a href="#5-2-队列函数" class="headerlink" title="5.2 队列函数"></a>5.2 队列函数</h2><p>使用队列的流程：创建队列、写队列、读队列、删除队列。</p><h3 id="5-2-1-创建"><a href="#5-2-1-创建" class="headerlink" title="5.2.1 创建"></a>5.2.1 创建</h3><p>队列的创建有两种方法：动态分配内存、静态分配内存，</p><ul><li>动态分配内存：xQueueCreate，队列的内存在函数内部动态分配</li></ul><p>函数原型如下：</p><pre class="line-numbers language-none"><code class="language-none">QueueHandle_t xQueueCreate( UBaseType_t uxQueueLength, UBaseType_t uxItemSize );<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>uxQueueLength</td><td>队列长度，最多能存放多少个数据(item)</td></tr><tr><td>uxItemSize</td><td>每个数据(item)的大小：以字节为单位</td></tr><tr><td>返回值</td><td>非0：成功，返回句柄，以后使用句柄来操作队列 NULL：失败，因为内存不足</td></tr></tbody></table><ul><li>静态分配内存：xQueueCreateStatic，队列的内存要事先分配好</li></ul><p>函数原型如下：</p><pre class="line-numbers language-none"><code class="language-none">QueueHandle_t xQueueCreateStatic(                           UBaseType_t uxQueueLength,                           UBaseType_t uxItemSize,                           uint8_t *pucQueueStorageBuffer,                           StaticQueue_t *pxQueueBuffer                       );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>uxQueueLength</td><td>队列长度，最多能存放多少个数据(item)</td></tr><tr><td>uxItemSize</td><td>每个数据(item)的大小：以字节为单位</td></tr><tr><td>pucQueueStorageBuffer</td><td>如果uxItemSize非0，pucQueueStorageBuffer必须指向一个uint8_t数组， 此数组大小至少为”uxQueueLength * uxItemSize”</td></tr><tr><td>pxQueueBuffer</td><td>必须执行一个StaticQueue_t结构体，用来保存队列的数据结构</td></tr><tr><td>返回值</td><td>非0：成功，返回句柄，以后使用句柄来操作队列 NULL：失败，因为pxQueueBuffer为NULL</td></tr></tbody></table><p>示例代码：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 示例代码 #define QUEUE_LENGTH 10 #define ITEM_SIZE sizeof( uint32_t )  &#x2F;&#x2F; xQueueBuffer用来保存队列结构体 StaticQueue_t xQueueBuffer;  &#x2F;&#x2F; ucQueueStorage 用来保存队列的数据 &#x2F;&#x2F; 大小为：队列长度 * 数据大小 uint8_t ucQueueStorage[ QUEUE_LENGTH * ITEM_SIZE ];  void vATask( void *pvParameters ) &#123;QueueHandle_t xQueue1; &#x2F;&#x2F; 创建队列: 可以容纳QUEUE_LENGTH个数据，每个数据大小是ITEM_SIZExQueue1 &#x3D; xQueueCreateStatic( QUEUE_LENGTH,  ITEM_SIZE,  ucQueueStorage,  &amp;xQueueBuffer );  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-2-2-复位"><a href="#5-2-2-复位" class="headerlink" title="5.2.2 复位"></a>5.2.2 复位</h3><p>队列刚被创建时，里面没有数据；使用过程中可以调用<code>xQueueReset()</code>把队列恢复为初始状态，此函数原型为：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;* pxQueue : 复位哪个队列; * 返回值: pdPASS(必定成功) *&#x2F;BaseType_t xQueueReset( QueueHandle_t pxQueue);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-2-3-删除"><a href="#5-2-3-删除" class="headerlink" title="5.2.3 删除"></a>5.2.3 删除</h3><p>删除队列的函数为<code>vQueueDelete()</code>，只能删除使用动态方法创建的队列，它会释放内存。原型如下：</p><pre class="line-numbers language-none"><code class="language-none">void vQueueDelete( QueueHandle_t xQueue );<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="5-2-4-写队列"><a href="#5-2-4-写队列" class="headerlink" title="5.2.4 写队列"></a>5.2.4 写队列</h3><p>可以把数据写到队列头部，也可以写到尾部，这些函数有两个版本：在任务中使用、在ISR中使用。函数原型如下：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;* 等同于xQueueSendToBack * 往队列尾部写入数据，如果没有空间，阻塞时间为xTicksToWait *&#x2F;BaseType_t xQueueSend(                                QueueHandle_t    xQueue,                                const void       *pvItemToQueue,                                TickType_t       xTicksToWait                            );&#x2F;*  * 往队列尾部写入数据，如果没有空间，阻塞时间为xTicksToWait *&#x2F;BaseType_t xQueueSendToBack(                                QueueHandle_t    xQueue,                                const void       *pvItemToQueue,                                TickType_t       xTicksToWait                            );&#x2F;*  * 往队列尾部写入数据，此函数可以在中断函数中使用，不可阻塞 *&#x2F;BaseType_t xQueueSendToBackFromISR(                                      QueueHandle_t xQueue,                                      const void *pvItemToQueue,                                      BaseType_t *pxHigherPriorityTaskWoken                                   );&#x2F;*  * 往队列头部写入数据，如果没有空间，阻塞时间为xTicksToWait *&#x2F;BaseType_t xQueueSendToFront(                                QueueHandle_t    xQueue,                                const void       *pvItemToQueue,                                TickType_t       xTicksToWait                            );&#x2F;*  * 往队列头部写入数据，此函数可以在中断函数中使用，不可阻塞 *&#x2F;BaseType_t xQueueSendToFrontFromISR(                                      QueueHandle_t xQueue,                                      const void *pvItemToQueue,                                      BaseType_t *pxHigherPriorityTaskWoken                                   );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这些函数用到的参数是类似的，统一说明如下：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>xQueue</td><td>队列句柄，要写哪个队列</td></tr><tr><td>pvItemToQueue</td><td>数据指针，这个数据的值会被复制进队列， 复制多大的数据？在创建队列时已经指定了数据大小</td></tr><tr><td>xTicksToWait</td><td>如果队列满则无法写入新数据，可以让任务进入阻塞状态， xTicksToWait表示阻塞的最大时间(Tick Count)。 如果被设为0，无法写入数据时函数会立刻返回； 如果被设为portMAX_DELAY，则会一直阻塞直到有空间可写</td></tr><tr><td>返回值</td><td>pdPASS：数据成功写入了队列 errQUEUE_FULL：写入失败，因为队列满了。</td></tr></tbody></table><h3 id="5-2-5-读队列"><a href="#5-2-5-读队列" class="headerlink" title="5.2.5 读队列"></a>5.2.5 读队列</h3><p>使用<code>xQueueReceive()</code>函数读队列，读到一个数据后，队列中该数据会被移除。这个函数有两个版本：在任务中使用、在ISR中使用。函数原型如下：</p><pre class="line-numbers language-none"><code class="language-none">BaseType_t xQueueReceive( QueueHandle_t xQueue,                          void * const pvBuffer,                          TickType_t xTicksToWait );BaseType_t xQueueReceiveFromISR(                                    QueueHandle_t    xQueue,                                    void             *pvBuffer,                                    BaseType_t       *pxTaskWoken                                );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参数说明如下：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>xQueue</td><td>队列句柄，要读哪个队列</td></tr><tr><td>pvBuffer</td><td>bufer指针，队列的数据会被复制到这个buffer 复制多大的数据？在创建队列时已经指定了数据大小</td></tr><tr><td>xTicksToWait</td><td>果队列空则无法读出数据，可以让任务进入阻塞状态， xTicksToWait表示阻塞的最大时间(Tick Count)。 如果被设为0，无法读出数据时函数会立刻返回； 如果被设为portMAX_DELAY，则会一直阻塞直到有数据可写</td></tr><tr><td>返回值</td><td>pdPASS：从队列读出数据入 errQUEUE_EMPTY：读取失败，因为队列空了。</td></tr></tbody></table><h3 id="5-2-6-查询"><a href="#5-2-6-查询" class="headerlink" title="5.2.6 查询"></a>5.2.6 查询</h3><p>可以查询队列中有多少个数据、有多少空余空间。函数原型如下：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;* * 返回队列中可用数据的个数 *&#x2F;UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue );&#x2F;* * 返回队列中可用空间的个数 *&#x2F;UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-2-7-覆盖-x2F-偷看"><a href="#5-2-7-覆盖-x2F-偷看" class="headerlink" title="5.2.7 覆盖&#x2F;偷看"></a>5.2.7 覆盖&#x2F;偷看</h3><p>当队列长度为1时，可以使用<code>xQueueOverwrite()</code>或<code>xQueueOverwriteFromISR()</code>来覆盖数据。 注意，队列长度必须为1。当队列满时，这些函数会覆盖里面的数据，这也以为着这些函数不会被阻塞。 函数原型如下：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;* 覆盖队列 * xQueue: 写哪个队列 * pvItemToQueue: 数据地址 * 返回值: pdTRUE表示成功, pdFALSE表示失败 *&#x2F;BaseType_t xQueueOverwrite(                           QueueHandle_t xQueue,                           const void * pvItemToQueue                      );BaseType_t xQueueOverwriteFromISR(                           QueueHandle_t xQueue,                           const void * pvItemToQueue,                           BaseType_t *pxHigherPriorityTaskWoken                      );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果想让队列中的数据供多方读取，也就是说读取时不要移除数据，要留给后来人。那么可以使用”窥视”，也就是<code>xQueuePeek()</code>或<code>xQueuePeekFromISR()</code>。这些函数会从队列中复制出数据，但是不移除数据。这也意味着，如果队列中没有数据，那么”偷看”时会导致阻塞；一旦队列中有数据，以后每次”偷看”都会成功。 函数原型如下：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;* 偷看队列 * xQueue: 偷看哪个队列 * pvItemToQueue: 数据地址, 用来保存复制出来的数据 * xTicksToWait: 没有数据的话阻塞一会 * 返回值: pdTRUE表示成功, pdFALSE表示失败 *&#x2F;BaseType_t xQueuePeek(                          QueueHandle_t xQueue,                          void * const pvBuffer,                          TickType_t xTicksToWait                      );BaseType_t xQueuePeekFromISR(                                 QueueHandle_t xQueue,                                 void *pvBuffer,                             );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-3-示例8-队列的基本使用"><a href="#5-3-示例8-队列的基本使用" class="headerlink" title="5.3 示例8: 队列的基本使用"></a>5.3 示例8: 队列的基本使用</h2><p>本节代码为：<code>FreeRTOS_08_queue</code>。</p><p>本程序会创建一个队列，然后创建2个发送任务、1个接收任务：</p><ul><li>发送任务优先级为1，分别往队列中写入100、200</li><li>接收任务优先级为2，读队列、打印数值</li></ul><p>main函数中创建的队列、创建了发送任务、接收任务，代码如下：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;* 队列句柄, 创建队列时会设置这个变量 *&#x2F;QueueHandle_t xQueue;int main( void )&#123;prvSetupHardware();    &#x2F;* 创建队列: 长度为5，数据大小为4字节(存放一个整数) *&#x2F;    xQueue &#x3D; xQueueCreate( 5, sizeof( int32_t ) );if( xQueue !&#x3D; NULL )&#123;&#x2F;* 创建2个任务用于写队列, 传入的参数分别是100、200 * 任务函数会连续执行，向队列发送数值100、200 * 优先级为1 *&#x2F;xTaskCreate( vSenderTask, &quot;Sender1&quot;, 1000, ( void * ) 100, 1, NULL );xTaskCreate( vSenderTask, &quot;Sender2&quot;, 1000, ( void * ) 200, 1, NULL );&#x2F;* 创建1个任务用于读队列 * 优先级为2, 高于上面的两个任务 * 这意味着队列一有数据就会被读走 *&#x2F;xTaskCreate( vReceiverTask, &quot;Receiver&quot;, 1000, NULL, 2, NULL );&#x2F;* 启动调度器 *&#x2F;vTaskStartScheduler();&#125;else&#123;&#x2F;* 无法创建队列 *&#x2F;&#125;&#x2F;* 如果程序运行到了这里就表示出错了, 一般是内存不足 *&#x2F;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>发送任务的函数中，不断往队列中写入数值，代码如下：</p><pre class="line-numbers language-none"><code class="language-none">static void vSenderTask( void *pvParameters )&#123;int32_t lValueToSend;BaseType_t xStatus;&#x2F;* 我们会使用这个函数创建2个任务 * 这些任务的pvParameters不一样  *&#x2F;lValueToSend &#x3D; ( int32_t ) pvParameters;&#x2F;* 无限循环 *&#x2F;for( ;; )&#123;&#x2F;* 写队列 * xQueue: 写哪个队列 * &amp;lValueToSend: 写什么数据? 传入数据的地址, 会从这个地址把数据复制进队列 * 0: 不阻塞, 如果队列满的话, 写入失败, 立刻返回 *&#x2F;xStatus &#x3D; xQueueSendToBack( xQueue, &amp;lValueToSend, 0 );if( xStatus !&#x3D; pdPASS )&#123;printf( &quot;Could not send to the queue.\r\n&quot; );&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接收任务的函数中，读取队列、判断返回值、打印，代码如下：</p><pre class="line-numbers language-none"><code class="language-none">static void vReceiverTask( void *pvParameters )&#123;&#x2F;* 读取队列时, 用这个变量来存放数据 *&#x2F;int32_t lReceivedValue;BaseType_t xStatus;const TickType_t xTicksToWait &#x3D; pdMS_TO_TICKS( 100UL );&#x2F;* 无限循环 *&#x2F;for( ;; )&#123;&#x2F;* 读队列 * xQueue: 读哪个队列 * &amp;lReceivedValue: 读到的数据复制到这个地址 * xTicksToWait: 如果队列为空, 阻塞一会 *&#x2F;xStatus &#x3D; xQueueReceive( xQueue, &amp;lReceivedValue, xTicksToWait );if( xStatus &#x3D;&#x3D; pdPASS )&#123;&#x2F;* 读到了数据 *&#x2F;printf( &quot;Received &#x3D; %d\r\n&quot;, lReceivedValue );&#125;else&#123;&#x2F;* 没读到数据 *&#x2F;printf( &quot;Could not receive from the queue.\r\n&quot; );&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>程序运行结果如下：</p><p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/04_queue_read_example.png"></p><p>任务调度情况如下图所示：</p><p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/05_queue_read_schedule.png"></p><h2 id="5-4-示例9-分辨数据源"><a href="#5-4-示例9-分辨数据源" class="headerlink" title="5.4 示例9: 分辨数据源"></a>5.4 示例9: 分辨数据源</h2><p>本节代码为：<code>FreeRTOS_09_queue_datasource</code>。</p><p>当有多个发送任务，通过同一个队列发出数据，接收任务如何分辨数据来源？数据本身带有”来源”信息，比如写入队列的数据是一个结构体，结构体中的lDataSouceID用来表示数据来源：</p><pre class="line-numbers language-none"><code class="language-none">typedef struct &#123;    ID_t eDataID;    int32_t lDataValue;&#125;Data_t;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>不同的发送任务，先构造好结构体，填入自己的<code>eDataID</code>，再写队列；接收任务读出数据后，根据<code>eDataID</code>就可以知道数据来源了，如下图所示：</p><ul><li>CAN任务发送的数据：eDataID&#x3D;eMotorSpeed</li><li>HMI任务发送的数据：eDataID&#x3D;eSpeedSetPoint</li></ul><p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/06_data_contain_source.png"></p><p><code>FreeRTOS_09_queue_datasource</code>程序会创建一个队列，然后创建2个发送任务、1个接收任务：</p><ul><li>创建的队列，用来发送结构体：数据大小是结构体的大小</li><li>发送任务优先级为2，分别往队列中写入自己的结构体，结构体中会标明数据来源</li><li>接收任务优先级为1，读队列、根据数据来源打印信息</li></ul><p>main函数中创建了队列、创建了发送任务、接收任务，代码如下：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;* 定义2种数据来源(ID) *&#x2F;typedef enum&#123;eMotorSpeed,eSpeedSetPoint&#125; ID_t;&#x2F;* 定义在队列中传输的数据的格式 *&#x2F;typedef struct &#123;    ID_t eDataID;    int32_t lDataValue;&#125;Data_t;&#x2F;* 定义2个结构体 *&#x2F;static const Data_t xStructsToSend[ 2 ] &#x3D;&#123;&#123; eMotorSpeed,    10 &#125;, &#x2F;* CAN任务发送的数据 *&#x2F;&#123; eSpeedSetPoint, 5 &#125;   &#x2F;* HMI任务发送的数据 *&#x2F;&#125;;&#x2F;* vSenderTask被用来创建2个任务，用于写队列 * vReceiverTask被用来创建1个任务，用于读队列 *&#x2F;static void vSenderTask( void *pvParameters );static void vReceiverTask( void *pvParameters );&#x2F;*-----------------------------------------------------------*&#x2F;&#x2F;* 队列句柄, 创建队列时会设置这个变量 *&#x2F;QueueHandle_t xQueue;int main( void )&#123;prvSetupHardware();    &#x2F;* 创建队列: 长度为5，数据大小为4字节(存放一个整数) *&#x2F;    xQueue &#x3D; xQueueCreate( 5, sizeof( Data_t ) );if( xQueue !&#x3D; NULL )&#123;&#x2F;* 创建2个任务用于写队列, 传入的参数是不同的结构体地址 * 任务函数会连续执行，向队列发送结构体 * 优先级为2 *&#x2F;xTaskCreate(vSenderTask, &quot;CAN Task&quot;, 1000, (void *) &amp;(xStructsToSend[0]), 2, NULL);xTaskCreate(vSenderTask, &quot;HMI Task&quot;, 1000, (void *) &amp;( xStructsToSend[1]), 2, NULL);&#x2F;* 创建1个任务用于读队列 * 优先级为1, 低于上面的两个任务 * 这意味着发送任务优先写队列，队列常常是满的状态 *&#x2F;xTaskCreate( vReceiverTask, &quot;Receiver&quot;, 1000, NULL, 1, NULL );&#x2F;* 启动调度器 *&#x2F;vTaskStartScheduler();&#125;else&#123;&#x2F;* 无法创建队列 *&#x2F;&#125;&#x2F;* 如果程序运行到了这里就表示出错了, 一般是内存不足 *&#x2F;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>发送任务的函数中，不断往队列中写入数值，代码如下：</p><pre class="line-numbers language-none"><code class="language-none">static void vSenderTask( void *pvParameters )&#123;BaseType_t xStatus;const TickType_t xTicksToWait &#x3D; pdMS_TO_TICKS( 100UL );&#x2F;* 无限循环 *&#x2F;for( ;; )&#123;&#x2F;* 写队列 * xQueue: 写哪个队列 * pvParameters: 写什么数据? 传入数据的地址, 会从这个地址把数据复制进队列 * xTicksToWait: 如果队列满的话, 阻塞一会 *&#x2F;xStatus &#x3D; xQueueSendToBack( xQueue, pvParameters, xTicksToWait );if( xStatus !&#x3D; pdPASS )&#123;printf( &quot;Could not send to the queue.\r\n&quot; );&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接收任务的函数中，读取队列、判断返回值、打印，代码如下：</p><pre class="line-numbers language-none"><code class="language-none">static void vReceiverTask( void *pvParameters )&#123;&#x2F;* 读取队列时, 用这个变量来存放数据 *&#x2F;Data_t xReceivedStructure;BaseType_t xStatus;&#x2F;* 无限循环 *&#x2F;for( ;; )&#123;&#x2F;* 读队列 * xQueue: 读哪个队列 * &amp;xReceivedStructure: 读到的数据复制到这个地址 * 0: 没有数据就即刻返回，不阻塞 *&#x2F;xStatus &#x3D; xQueueReceive( xQueue, &amp;xReceivedStructure, 0 );if( xStatus &#x3D;&#x3D; pdPASS )&#123;&#x2F;* 读到了数据 *&#x2F;if( xReceivedStructure.eDataID &#x3D;&#x3D; eMotorSpeed )&#123;printf( &quot;From CAN, MotorSpeed &#x3D; %d\r\n&quot;, xReceivedStructure.lDataValue );&#125;else if( xReceivedStructure.eDataID &#x3D;&#x3D; eSpeedSetPoint )&#123;printf( &quot;From HMI, SpeedSetPoint &#x3D; %d\r\n&quot;, xReceivedStructure.lDataValue );&#125;&#125;else&#123;&#x2F;* 没读到数据 *&#x2F;printf( &quot;Could not receive from the queue.\r\n&quot; );&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果如下：</p><p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/07_queue_data_with_struct.png"></p><p>任务调度情况如下图所示：</p><ul><li>t1：HMI是最后创建的最高优先级任务，它先执行，一下子向队列写入5个数据，把队列都写满了</li><li>t2：队列已经满了，HMI任务再发起第6次写操作时，进入阻塞状态。这时CAN任务是最高优先级的就绪态任务，它开始执行</li><li>t3：CAN任务发现队列已经满了，进入阻塞状态；接收任务变为最高优先级的就绪态任务，它开始运行</li><li>t4：现在，HMI任务、CAN任务的优先级都比接收任务高，它们都在等待队列有空闲的空间；一旦接收任务读出1个数据，会马上被抢占。被谁抢占？谁等待最久？HMI任务！所以在t4时刻，切换到HMI任务。</li><li>t5：HMI任务向队列写入第6个数据，然后再次阻塞，这是CAN任务已经阻塞很久了。接收任务变为最高优先级的就绪态任务，开始执行。</li><li>t6：现在，HMI任务、CAN任务的优先级都比接收任务高，它们都在等待队列有空闲的空间；一旦接收任务读出1个数据，会马上被抢占。被谁抢占？谁等待最久？CAN任务！所以在t6时刻，切换到CAN任务。</li><li>t7：CAN任务向队列写入数据，因为仅仅有一个空间供写入，所以它马上再次进入阻塞状态。这时HMI任务、CAN任务都在等待空闲空间，只有接收任务可以继续执行。</li></ul><p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/08_queue_data_with_struct_schedule.png"></p><h2 id="5-5-示例10-传输大块数据"><a href="#5-5-示例10-传输大块数据" class="headerlink" title="5.5 示例10: 传输大块数据"></a>5.5 示例10: 传输大块数据</h2><p>本节代码为：<code>FreeRTOS_10_queue_bigtransfer</code>。</p><p>FreeRTOS的队列使用拷贝传输，也就是要传输uint32_t时，把4字节的数据拷贝进队列；要传输一个8字节的结构体时，把8字节的数据拷贝进队列。</p><p>如果要传输1000字节的结构体呢？写队列时拷贝1000字节，读队列时再拷贝1000字节？不建议这么做，影响效率！</p><p>这时候，我们要传输的是这个巨大结构体的地址：把它的地址写入队列，对方从队列得到这个地址，使用地址去访问那1000字节的数据。</p><p>使用地址来间接传输数据时，这些数据放在RAM里，对于这块RAM，要保证这几点：</p><ul><li>RAM的所有者、操作者，必须清晰明了 这块内存，就被称为”共享内存”。要确保不能同时修改RAM。比如，在写队列之前只有由发送者修改这块RAM，在读队列之后只能由接收者访问这块RAM。</li><li>RAM要保持可用 这块RAM应该是全局变量，或者是动态分配的内存。对于动然分配的内存，要确保它不能提前释放：要等到接收者用完后再释放。另外，不能是局部变量。</li></ul><p><code>FreeRTOS_10_queue_bigtransfer</code>程序会创建一个队列，然后创建1个发送任务、1个接收任务：</p><ul><li>创建的队列：长度为1，用来传输”char *”指针</li><li>发送任务优先级为1，在字符数组中写好数据后，把它的地址写入队列</li><li>接收任务优先级为2，读队列得到”char *”值，把它打印出来</li></ul><p>这个程序故意设置接收任务的优先级更高，在它访问数组的过程中，接收任务无法执行、无法写这个数组。</p><p>main函数中创建了队列、创建了发送任务、接收任务，代码如下：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;* 定义一个字符数组 *&#x2F;static char pcBuffer[100];&#x2F;* vSenderTask被用来创建2个任务，用于写队列 * vReceiverTask被用来创建1个任务，用于读队列 *&#x2F;static void vSenderTask( void *pvParameters );static void vReceiverTask( void *pvParameters );&#x2F;*-----------------------------------------------------------*&#x2F;&#x2F;* 队列句柄, 创建队列时会设置这个变量 *&#x2F;QueueHandle_t xQueue;int main( void )&#123;prvSetupHardware();    &#x2F;* 创建队列: 长度为1，数据大小为4字节(存放一个char指针) *&#x2F;    xQueue &#x3D; xQueueCreate( 1, sizeof(char *) );if( xQueue !&#x3D; NULL )&#123;&#x2F;* 创建1个任务用于写队列 * 任务函数会连续执行，构造buffer数据，把buffer地址写入队列 * 优先级为1 *&#x2F;xTaskCreate( vSenderTask, &quot;Sender&quot;, 1000, NULL, 1, NULL );&#x2F;* 创建1个任务用于读队列 * 优先级为2, 高于上面的两个任务 * 这意味着读队列得到buffer地址后，本任务使用buffer时不会被打断 *&#x2F;xTaskCreate( vReceiverTask, &quot;Receiver&quot;, 1000, NULL, 2, NULL );&#x2F;* 启动调度器 *&#x2F;vTaskStartScheduler();&#125;else&#123;&#x2F;* 无法创建队列 *&#x2F;&#125;&#x2F;* 如果程序运行到了这里就表示出错了, 一般是内存不足 *&#x2F;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>发送任务的函数中，现在全局大数组pcBuffer中构造数据，然后把它的地址写入队列，代码如下：</p><pre class="line-numbers language-none"><code class="language-none">static void vSenderTask( void *pvParameters )&#123;BaseType_t xStatus;static int cnt &#x3D; 0;char *buffer;&#x2F;* 无限循环 *&#x2F;for( ;; )&#123;sprintf(pcBuffer, &quot;www.100ask.net Msg %d\r\n&quot;, cnt++);buffer &#x3D; pcBuffer; &#x2F;&#x2F; buffer变量等于数组的地址, 下面要把这个地址写入队列&#x2F;* 写队列 * xQueue: 写哪个队列 * pvParameters: 写什么数据? 传入数据的地址, 会从这个地址把数据复制进队列 * 0: 如果队列满的话, 即刻返回 *&#x2F;xStatus &#x3D; xQueueSendToBack( xQueue, &amp;buffer, 0 ); &#x2F;* 只需要写入4字节, 无需写入整个buffer *&#x2F;if( xStatus !&#x3D; pdPASS )&#123;printf( &quot;Could not send to the queue.\r\n&quot; );&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接收任务的函数中，读取队列、得到buffer的地址、打印，代码如下：</p><pre class="line-numbers language-none"><code class="language-none">static void vReceiverTask( void *pvParameters )&#123;&#x2F;* 读取队列时, 用这个变量来存放数据 *&#x2F;char *buffer;const TickType_t xTicksToWait &#x3D; pdMS_TO_TICKS( 100UL );BaseType_t xStatus;&#x2F;* 无限循环 *&#x2F;for( ;; )&#123;&#x2F;* 读队列 * xQueue: 读哪个队列 * &amp;xReceivedStructure: 读到的数据复制到这个地址 * xTicksToWait: 没有数据就阻塞一会 *&#x2F;xStatus &#x3D; xQueueReceive( xQueue, &amp;buffer, xTicksToWait); &#x2F;* 得到buffer地址，只是4字节 *&#x2F;if( xStatus &#x3D;&#x3D; pdPASS )&#123;&#x2F;* 读到了数据 *&#x2F;printf(&quot;Get: %s&quot;, buffer);&#125;else&#123;&#x2F;* 没读到数据 *&#x2F;printf( &quot;Could not receive from the queue.\r\n&quot; );&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果如下图所示：</p><p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/09_queue_transfer_big_data.png"></p><h2 id="5-6-示例11-邮箱-Mailbox"><a href="#5-6-示例11-邮箱-Mailbox" class="headerlink" title="5.6 示例11: 邮箱(Mailbox)"></a>5.6 示例11: 邮箱(Mailbox)</h2><p>本节代码为：<code>FreeRTOS_11_queue_mailbox</code>。</p><p>FreeRTOS的邮箱概念跟别的RTOS不一样，这里的邮箱称为”橱窗”也许更恰当：</p><ul><li>它是一个队列，队列长度只有1</li><li>写邮箱：新数据覆盖旧数据，在任务中使用<code>xQueueOverwrite()</code>，在中断中使用<code>xQueueOverwriteFromISR()</code>。 既然是覆盖，那么无论邮箱中是否有数据，这些函数总能成功写入数据。</li><li>读邮箱：读数据时，数据不会被移除；在任务中使用<code>xQueuePeek()</code>，在中断中使用<code>xQueuePeekFromISR()</code>。 这意味着，第一次调用时会因为无数据而阻塞，一旦曾经写入数据，以后读邮箱时总能成功。</li></ul><p>main函数中创建了队列(队列长度为1)、创建了发送任务、接收任务：</p><ul><li>发送任务的优先级为2，它先执行</li><li>接收任务的优先级为1</li></ul><p>代码如下：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;* 队列句柄, 创建队列时会设置这个变量 *&#x2F;QueueHandle_t xQueue;int main( void )&#123;prvSetupHardware();    &#x2F;* 创建队列: 长度为1，数据大小为4字节(存放一个char指针) *&#x2F;    xQueue &#x3D; xQueueCreate( 1, sizeof(uint32_t) );if( xQueue !&#x3D; NULL )&#123;&#x2F;* 创建1个任务用于写队列 * 任务函数会连续执行，构造buffer数据，把buffer地址写入队列 * 优先级为2 *&#x2F;xTaskCreate( vSenderTask, &quot;Sender&quot;, 1000, NULL, 2, NULL );&#x2F;* 创建1个任务用于读队列 * 优先级为1 *&#x2F;xTaskCreate( vReceiverTask, &quot;Receiver&quot;, 1000, NULL, 1, NULL );&#x2F;* 启动调度器 *&#x2F;vTaskStartScheduler();&#125;else&#123;&#x2F;* 无法创建队列 *&#x2F;&#125;&#x2F;* 如果程序运行到了这里就表示出错了, 一般是内存不足 *&#x2F;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>发送任务、接收任务的代码和执行流程如下：</p><ul><li>A：发送任务先执行，马上阻塞</li><li>BC：接收任务执行，这是邮箱无数据，打印”Could not …”。在发送任务阻塞过程中，接收任务多次执行、多次打印。</li><li>D：发送任务从阻塞状态退出，立刻执行、写队列</li><li>E：发送任务再次阻塞</li><li>FG、HI、……：接收任务不断”偷看”邮箱，得到同一个数据，打印出多个”Get: 0”</li><li>J：发送任务从阻塞状态退出，立刻执行、覆盖队列，写入1</li><li>K：发送任务再次阻塞</li><li>LM、……：接收任务不断”偷看”邮箱，得到同一个数据，打印出多个”Get: 1”</li></ul><p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/11_queue_mailbox_code.png"></p><p>运行结果如下图所示：</p><p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/10_queue_mailbox_result.png"></p><h1 id="6、信号量"><a href="#6、信号量" class="headerlink" title="6、信号量"></a>6、信号量</h1><h2 id="6-1-信号量的特性"><a href="#6-1-信号量的特性" class="headerlink" title="6.1 信号量的特性"></a>6.1 信号量的特性</h2><h3 id="6-1-1-信号量的常规操作"><a href="#6-1-1-信号量的常规操作" class="headerlink" title="6.1.1 信号量的常规操作"></a>6.1.1 信号量的常规操作</h3><p>信号量这个名字很恰当：</p><ul><li>信号：起通知作用</li><li>量：还可以用来表示资源的数量<ul><li>当”量”没有限制时，它就是”计数型信号量”(Counting Semaphores)</li><li>当”量”只有0、1两个取值时，它就是”二进制信号量”(Binary Semaphores)</li></ul></li><li>支持的动作：”give”给出资源，计数值加1；”take”获得资源，计数值减1</li></ul><p>计数型信号量的典型场景是：</p><ul><li>计数：事件产生时”give”信号量，让计数值加1；处理事件时要先”take”信号量，就是获得信号量，让计数值减1。</li><li>资源管理：要想访问资源需要先”take”信号量，让计数值减1；用完资源后”give”信号量，让计数值加1。</li></ul><p>信号量的”give”、”take”双方并不需要相同，可以用于生产者-消费者场合：</p><ul><li>生产者为任务A、B，消费者为任务C、D</li><li>一开始信号量的计数值为0，如果任务C、D想获得信号量，会有两种结果：<ul><li>阻塞：买不到东西咱就等等吧，可以定个闹钟(超时时间)</li><li>即刻返回失败：不等</li></ul></li><li>任务A、B可以生产资源，就是让信号量的计数值增加1，并且把等待这个资源的顾客唤醒</li><li>唤醒谁？谁优先级高就唤醒谁，如果大家优先级一样就唤醒等待时间最长的人</li></ul><p>二进制信号量跟计数型的唯一差别，就是计数值的最大值被限定为1。</p><p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/01_semaphore_usage.png"></p><h3 id="6-1-2-信号量跟队列的对比"><a href="#6-1-2-信号量跟队列的对比" class="headerlink" title="6.1.2 信号量跟队列的对比"></a>6.1.2 信号量跟队列的对比</h3><p>差异列表如下：</p><table><thead><tr><th>队列</th><th>信号量</th></tr></thead><tbody><tr><td>可以容纳多个数据， 创建队列时有2部分内存: 队列结构体、存储数据的空间</td><td>只有计数值，无法容纳其他数据。 创建信号量时，只需要分配信号量结构体</td></tr><tr><td>生产者：没有空间存入数据时可以阻塞</td><td>生产者：用于不阻塞，计数值已经达到最大时返回失败</td></tr><tr><td>消费者：没有数据时可以阻塞</td><td>消费者：没有资源时可以阻塞</td></tr></tbody></table><h2 id="6-1-3-两种信号量的对比"><a href="#6-1-3-两种信号量的对比" class="headerlink" title="6.1.3 两种信号量的对比"></a>6.1.3 两种信号量的对比</h2><p>信号量的计数值都有限制：限定了最大值。如果最大值被限定为1，那么它就是二进制信号量；如果最大值不是1，它就是计数型信号量。</p><p>差别列表如下：</p><table><thead><tr><th>二进制信号量</th><th>技术型信号量</th></tr></thead><tbody><tr><td>被创建时初始值为0</td><td>被创建时初始值可以设定</td></tr><tr><td>其他操作是一样的</td><td>其他操作是一样的</td></tr></tbody></table><h2 id="6-2-信号量函数"><a href="#6-2-信号量函数" class="headerlink" title="6.2 信号量函数"></a>6.2 信号量函数</h2><p>使用信号量时，先创建、然后去添加资源、获得资源。使用句柄来表示一个信号量。</p><h3 id="6-2-1-创建"><a href="#6-2-1-创建" class="headerlink" title="6.2.1 创建"></a>6.2.1 创建</h3><p>使用信号量之前，要先创建，得到一个句柄；使用信号量时，要使用句柄来表明使用哪个信号量。</p><p>对于二进制信号量、计数型信号量，它们的创建函数不一样：</p><table><thead><tr><th></th><th>二进制信号量</th><th>计数型信号量</th></tr></thead><tbody><tr><td>动态创建</td><td>xSemaphoreCreateBinary 计数值初始值为0</td><td>xSemaphoreCreateCounting</td></tr><tr><td></td><td>vSemaphoreCreateBinary(过时了) 计数值初始值为1</td><td></td></tr><tr><td>静态创建</td><td>xSemaphoreCreateBinaryStatic</td><td>xSemaphoreCreateCountingStatic</td></tr></tbody></table><p>创建二进制信号量的函数原型如下：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;* 创建一个二进制信号量，返回它的句柄。 * 此函数内部会分配信号量结构体  * 返回值: 返回句柄，非NULL表示成功 *&#x2F;SemaphoreHandle_t xSemaphoreCreateBinary( void );&#x2F;* 创建一个二进制信号量，返回它的句柄。 * 此函数无需动态分配内存，所以需要先有一个StaticSemaphore_t结构体，并传入它的指针 * 返回值: 返回句柄，非NULL表示成功 *&#x2F;SemaphoreHandle_t xSemaphoreCreateBinaryStatic( StaticSemaphore_t *pxSemaphoreBuffer );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建计数型信号量的函数原型如下：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;* 创建一个计数型信号量，返回它的句柄。 * 此函数内部会分配信号量结构体  * uxMaxCount: 最大计数值 * uxInitialCount: 初始计数值 * 返回值: 返回句柄，非NULL表示成功 *&#x2F;SemaphoreHandle_t xSemaphoreCreateCounting(UBaseType_t uxMaxCount, UBaseType_t uxInitialCount);&#x2F;* 创建一个计数型信号量，返回它的句柄。 * 此函数无需动态分配内存，所以需要先有一个StaticSemaphore_t结构体，并传入它的指针 * uxMaxCount: 最大计数值 * uxInitialCount: 初始计数值 * pxSemaphoreBuffer: StaticSemaphore_t结构体指针 * 返回值: 返回句柄，非NULL表示成功 *&#x2F;SemaphoreHandle_t xSemaphoreCreateCountingStatic( UBaseType_t uxMaxCount,                                                  UBaseType_t uxInitialCount,                                                  StaticSemaphore_t *pxSemaphoreBuffer );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-2-2-删除"><a href="#6-2-2-删除" class="headerlink" title="6.2.2 删除"></a>6.2.2 删除</h3><p>对于动态创建的信号量，不再需要它们时，可以删除它们以回收内存。</p><p>vSemaphoreDelete可以用来删除二进制信号量、计数型信号量，函数原型如下：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;* * xSemaphore: 信号量句柄，你要删除哪个信号量 *&#x2F;void vSemaphoreDelete( SemaphoreHandle_t xSemaphore );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-2-3-give-x2F-take"><a href="#6-2-3-give-x2F-take" class="headerlink" title="6.2.3 give&#x2F;take"></a>6.2.3 give&#x2F;take</h3><p>二进制信号量、计数型信号量的give、take操作函数是一样的。这些函数也分为2个版本：给任务使用，给ISR使用。列表如下：</p><table><thead><tr><th></th><th>在任务中使用</th><th>在ISR中使用</th></tr></thead><tbody><tr><td>give</td><td>xSemaphoreGive</td><td>xSemaphoreGiveFromISR</td></tr><tr><td>take</td><td>xSemaphoreTake</td><td>xSemaphoreTakeFromISR</td></tr></tbody></table><p>xSemaphoreGive的函数原型如下：</p><pre class="line-numbers language-none"><code class="language-none">BaseType_t xSemaphoreGive( SemaphoreHandle_t xSemaphore );<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>xSemaphoreGive函数的参数与返回值列表如下：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>xSemaphore</td><td>信号量句柄，释放哪个信号量</td></tr><tr><td>返回值</td><td>pdTRUE表示成功, 如果二进制信号量的计数值已经是1，再次调用此函数则返回失败； 如果计数型信号量的计数值已经是最大值，再次调用此函数则返回失败</td></tr></tbody></table><p>pxHigherPriorityTaskWoken的函数原型如下：</p><pre class="line-numbers language-none"><code class="language-none">BaseType_t xSemaphoreGiveFromISR(                        SemaphoreHandle_t xSemaphore,                        BaseType_t *pxHigherPriorityTaskWoken                    );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>xSemaphoreGiveFromISR函数的参数与返回值列表如下：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>xSemaphore</td><td>信号量句柄，释放哪个信号量</td></tr><tr><td>pxHigherPriorityTaskWoken</td><td>如果释放信号量导致更高优先级的任务变为了就绪态， 则*pxHigherPriorityTaskWoken &#x3D; pdTRUE</td></tr><tr><td>返回值</td><td>pdTRUE表示成功, 如果二进制信号量的计数值已经是1，再次调用此函数则返回失败； 如果计数型信号量的计数值已经是最大值，再次调用此函数则返回失败</td></tr></tbody></table><p>xSemaphoreTake的函数原型如下：</p><pre class="line-numbers language-none"><code class="language-none">BaseType_t xSemaphoreTake(                   SemaphoreHandle_t xSemaphore,                   TickType_t xTicksToWait               );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>xSemaphoreTake函数的参数与返回值列表如下：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>xSemaphore</td><td>信号量句柄，获取哪个信号量</td></tr><tr><td>xTicksToWait</td><td>如果无法马上获得信号量，阻塞一会： 0：不阻塞，马上返回 portMAX_DELAY: 一直阻塞直到成功 其他值: 阻塞的Tick个数，可以使用<code>pdMS_TO_TICKS()</code>来指定阻塞时间为若干ms</td></tr><tr><td>返回值</td><td>pdTRUE表示成功</td></tr></tbody></table><p>xSemaphoreTakeFromISR的函数原型如下：</p><pre class="line-numbers language-none"><code class="language-none">BaseType_t xSemaphoreTakeFromISR(                        SemaphoreHandle_t xSemaphore,                        BaseType_t *pxHigherPriorityTaskWoken                    );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>xSemaphoreTakeFromISR函数的参数与返回值列表如下：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>xSemaphore</td><td>信号量句柄，获取哪个信号量</td></tr><tr><td>pxHigherPriorityTaskWoken</td><td>如果获取信号量导致更高优先级的任务变为了就绪态， 则*pxHigherPriorityTaskWoken &#x3D; pdTRUE</td></tr><tr><td>返回值</td><td>pdTRUE表示成功</td></tr></tbody></table><h2 id="6-3-示例12-使用二进制信号量来同步"><a href="#6-3-示例12-使用二进制信号量来同步" class="headerlink" title="6.3 示例12: 使用二进制信号量来同步"></a>6.3 示例12: 使用二进制信号量来同步</h2><p>本节代码为： <code>FreeRTOS_12_semaphore_binary</code> 。</p><p>main函数中创建了一个二进制信号量，然后创建2个任务：一个用于释放信号量，另一个用于获取信号量，代码如下：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;* 二进制信号量句柄 *&#x2F;SemaphoreHandle_t xBinarySemaphore;int main( void )&#123;prvSetupHardware();    &#x2F;* 创建二进制信号量 *&#x2F;    xBinarySemaphore &#x3D; xSemaphoreCreateBinary( );if( xBinarySemaphore !&#x3D; NULL )&#123;&#x2F;* 创建1个任务用于释放信号量 * 优先级为2 *&#x2F;xTaskCreate( vSenderTask, &quot;Sender&quot;, 1000, NULL, 2, NULL );&#x2F;* 创建1个任务用于获取信号量 * 优先级为1 *&#x2F;xTaskCreate( vReceiverTask, &quot;Receiver&quot;, 1000, NULL, 1, NULL );&#x2F;* 启动调度器 *&#x2F;vTaskStartScheduler();&#125;else&#123;&#x2F;* 无法创建二进制信号量 *&#x2F;&#125;&#x2F;* 如果程序运行到了这里就表示出错了, 一般是内存不足 *&#x2F;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>发送任务、接收任务的代码和执行流程如下：</p><ul><li>A：发送任务优先级高，先执行。连续3次释放二进制信号量，只有第1次成功</li><li>B：发送任务进入阻塞态</li><li>C：接收任务得以执行，得到信号量，打印OK；再次去获得信号量时，进入阻塞状态</li><li>在发送任务的vTaskDelay退出之前，运行的是空闲任务：现在发送任务、接收任务都阻塞了</li><li>D：发送任务再次运行，连续3次释放二进制信号量，只有第1次成功</li><li>E：发送任务进入阻塞态</li><li>F：接收任务被唤醒，得到信号量，打印OK；再次去获得信号量时，进入阻塞状态</li></ul><p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/03_binarysemaphore_code.png"></p><p>运行结果如下图所示，即使发送任务连续释放多个信号量，也只能成功1次。释放、获得信号量是一一对应的。</p><p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/02_binarysemaphore_example1.png"></p><h2 id="6-4-示例13-防止数据丢失"><a href="#6-4-示例13-防止数据丢失" class="headerlink" title="6.4 示例13: 防止数据丢失"></a>6.4 示例13: 防止数据丢失</h2><p>本节代码为： <code>FreeRTOS_13_semaphore_circle_buffer</code> 。</p><p>在示例12中，发送任务发出3次”提醒”，但是接收任务只接收到1次”提醒”，其中2次”提醒”丢失了。</p><p>这种情况很常见，比如每接收到一个串口字符，串口中断程序就给任务发一次”提醒”，假设收到多个字符、发出了多次”提醒”。当任务来处理时，它只能得到1次”提醒”。</p><p>你需要使用其他方法来防止数据丢失，比如：</p><ul><li>在串口中断中，把数据放入缓冲区</li><li>在任务中，一次性把缓冲区中的数据都读出</li><li>简单地说，就是：你提醒了我多次，我太忙只响应你一次，但是我一次性拿走所有数据</li></ul><p>main函数中创建了一个二进制信号量，然后创建2个任务：一个用于释放信号量，另一个用于获取信号量，代码如下：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;* 二进制信号量句柄 *&#x2F;SemaphoreHandle_t xBinarySemaphore;int main( void )&#123;prvSetupHardware();    &#x2F;* 创建二进制信号量 *&#x2F;    xBinarySemaphore &#x3D; xSemaphoreCreateBinary( );if( xBinarySemaphore !&#x3D; NULL )&#123;&#x2F;* 创建1个任务用于释放信号量 * 优先级为2 *&#x2F;xTaskCreate( vSenderTask, &quot;Sender&quot;, 1000, NULL, 2, NULL );&#x2F;* 创建1个任务用于获取信号量 * 优先级为1 *&#x2F;xTaskCreate( vReceiverTask, &quot;Receiver&quot;, 1000, NULL, 1, NULL );&#x2F;* 启动调度器 *&#x2F;vTaskStartScheduler();&#125;else&#123;&#x2F;* 无法创建二进制信号量 *&#x2F;&#125;&#x2F;* 如果程序运行到了这里就表示出错了, 一般是内存不足 *&#x2F;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>发送任务、接收任务的代码和执行流程如下：</p><ul><li>A：发送任务优先级高，先执行。连续写入3个数据、释放3个信号量：只有1个信号量起作用</li><li>B：发送任务进入阻塞态</li><li>C：接收任务得以执行，得到信号量</li><li>D：接收任务一次性把所有数据取出</li><li>E：接收任务再次尝试获取信号量，进入阻塞状态</li><li>在发送任务的vTaskDelay退出之前，运行的是空闲任务：现在发送任务、接收任务都阻塞了</li><li>F：发送任务再次运行，连续写入3个数据、释放3个信号量：只有1个信号量起作用</li><li>G：发送任务进入阻塞态</li><li>H：接收任务被唤醒，得到信号量，一次性把所有数据取出</li></ul><p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/04_binarysemaphore_code2.png"></p><p>程序运行结果如下，数据未丢失：</p><p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/05_binarysemaphore_example2.png"></p><h2 id="6-5-示例14-使用计数型信号量"><a href="#6-5-示例14-使用计数型信号量" class="headerlink" title="6.5 示例14: 使用计数型信号量"></a>6.5 示例14: 使用计数型信号量</h2><p>本节代码为： <code>FreeRTOS_14_semaphore_counting</code> 。</p><p>使用计数型信号量时，可以多次释放信号量；当信号量的技术值达到最大时，再次释放信号量就会出错。</p><p>如果信号量计数值为n，就可以连续n次获取信号量，第(n+1)次获取信号量就会阻塞或失败。</p><p>main函数中创建了一个计数型信号量，最大计数值为3，初始值计数值为0；然后创建2个任务：一个用于释放信号量，另一个用于获取信号量，代码如下：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;* 计数型信号量句柄 *&#x2F;SemaphoreHandle_t xCountingSemaphore;int main( void )&#123;prvSetupHardware();    &#x2F;* 创建计数型信号量 *&#x2F;    xCountingSemaphore &#x3D; xSemaphoreCreateCounting(3, 0);if( xCountingSemaphore !&#x3D; NULL )&#123;&#x2F;* 创建1个任务用于释放信号量 * 优先级为2 *&#x2F;xTaskCreate( vSenderTask, &quot;Sender&quot;, 1000, NULL, 2, NULL );&#x2F;* 创建1个任务用于获取信号量 * 优先级为1 *&#x2F;xTaskCreate( vReceiverTask, &quot;Receiver&quot;, 1000, NULL, 1, NULL );&#x2F;* 启动调度器 *&#x2F;vTaskStartScheduler();&#125;else&#123;&#x2F;* 无法创建信号量 *&#x2F;&#125;&#x2F;* 如果程序运行到了这里就表示出错了, 一般是内存不足 *&#x2F;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>发送任务、接收任务的代码和执行流程如下：</p><ul><li>A：发送任务优先级高，先执行。连续释放4个信号量：只有前面3次成功，第4次失败</li><li>B：发送任务进入阻塞态</li><li>CDE：接收任务得以执行，得到3个信号量</li><li>F：接收任务试图获得第4个信号量时进入阻塞状态</li><li>在发送任务的vTaskDelay退出之前，运行的是空闲任务：现在发送任务、接收任务都阻塞了</li><li>G：发送任务再次运行，连续释放4个信号量：只有前面3次成功，第4次失败</li><li>H：发送任务进入阻塞态</li><li>IJK：接收任务得以执行，得到3个信号量</li><li>L：接收任务再次获取信号量时进入阻塞状态</li></ul><p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/06_countingsemaphore_code.png"></p><p>运行结果如下图所示：</p><p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/07_countingsemaphore_example.png"></p><h1 id="7-互斥量"><a href="#7-互斥量" class="headerlink" title="7.互斥量"></a>7.互斥量</h1><h2 id="7-1-互斥量的使用场合"><a href="#7-1-互斥量的使用场合" class="headerlink" title="7.1 互斥量的使用场合"></a>7.1 互斥量的使用场合</h2><p>在多任务系统中，任务A正在使用某个资源，还没用完的情况下任务B也来使用的话，就可能导致问题。</p><p>比如对于串口，任务A正使用它来打印，在打印过程中任务B也来打印，客户看到的结果就是A、B的信息混杂在一起。</p><p>这种现象很常见：</p><ul><li><p>访问外设：刚举的串口例子</p></li><li><p>读、修改、写操作导致的问题 对于同一个变量，比如<code>int a</code>，如果有两个任务同时写它就有可能导致问题。 对于变量的修改，C代码只有一条语句，比如：<code>a=a+8;</code>，它的内部实现分为3步：读出原值、修改、写入。 <img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/01_modify_val.png"></p><p>我们想让任务A、B都执行add_a函数，a的最终结果是<code>1+8+8=17</code>。 假设任务A运行完代码①，在执行代码②之前被任务B抢占了：现在任务A的R0等于1。 任务B执行完add_a函数，a等于9。 任务A继续运行，在代码②处R0仍然是被抢占前的数值1，执行完②③的代码，a等于9，这跟预期的17不符合。</p></li><li><p>对变量的非原子化访问 修改变量、设置结构体、在16位的机器上写32位的变量，这些操作都是非原子的。也就是它们的操作过程都可能被打断，如果被打断的过程有其他任务来操作这些变量，就可能导致冲突。</p></li><li><p>函数重入 “可重入的函数”是指：多个任务同时调用它、任务和中断同时调用它，函数的运行也是安全的。可重入的函数也被称为”线程安全”(thread safe)。 每个任务都维持自己的栈、自己的CPU寄存器，如果一个函数只使用局部变量，那么它就是线程安全的。 函数中一旦使用了全局变量、静态变量、其他外设，它就不是”可重入的”，如果改函数正在被调用，就必须阻止其他任务、中断再次调用它。</p></li></ul><p>上述问题的解决方法是：任务A访问这些全局变量、函数代码时，独占它，就是上个锁。这些全局变量、函数代码必须被独占地使用，它们被称为临界资源。</p><p>互斥量也被称为互斥锁，使用过程如下：</p><ul><li>互斥量初始值为1</li><li>任务A想访问临界资源，先获得并占有互斥量，然后开始访问</li><li>任务B也想访问临界资源，也要先获得互斥量：被别人占有了，于是阻塞</li><li>任务A使用完毕，释放互斥量；任务B被唤醒、得到并占有互斥量，然后开始访问临界资源</li><li>任务B使用完毕，释放互斥量</li></ul><p>正常来说：在任务A占有互斥量的过程中，任务B、任务C等等，都无法释放互斥量。</p><p>但是FreeRTOS未实现这点：任务A占有互斥量的情况下，任务B也可释放互斥量。</p><h2 id="7-2-互斥量函数"><a href="#7-2-互斥量函数" class="headerlink" title="7.2 互斥量函数"></a>7.2 互斥量函数</h2><h3 id="7-2-1-创建"><a href="#7-2-1-创建" class="headerlink" title="7.2.1 创建"></a>7.2.1 创建</h3><p>互斥量是一种特殊的二进制信号量。</p><p>使用互斥量时，先创建、然后去获得、释放它。使用句柄来表示一个互斥量。</p><p>创建互斥量的函数有2种：动态分配内存，静态分配内存，函数原型如下：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;* 创建一个互斥量，返回它的句柄。 * 此函数内部会分配互斥量结构体  * 返回值: 返回句柄，非NULL表示成功 *&#x2F;SemaphoreHandle_t xSemaphoreCreateMutex( void );&#x2F;* 创建一个互斥量，返回它的句柄。 * 此函数无需动态分配内存，所以需要先有一个StaticSemaphore_t结构体，并传入它的指针 * 返回值: 返回句柄，非NULL表示成功 *&#x2F;SemaphoreHandle_t xSemaphoreCreateMutexStatic( StaticSemaphore_t *pxMutexBuffer );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要想使用互斥量，需要在配置文件FreeRTOSConfig.h中定义：</p><pre class="line-numbers language-none"><code class="language-none">#define configUSE_MUTEXES 1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="7-2-2-其他函数"><a href="#7-2-2-其他函数" class="headerlink" title="7.2.2 其他函数"></a>7.2.2 其他函数</h3><p>要注意的是，互斥量不能在ISR中使用。</p><p>各类操作函数，比如删除、give&#x2F;take，跟一般是信号量是一样的。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;* * xSemaphore: 信号量句柄，你要删除哪个信号量, 互斥量也是一种信号量 *&#x2F;void vSemaphoreDelete( SemaphoreHandle_t xSemaphore );&#x2F;* 释放 *&#x2F;BaseType_t xSemaphoreGive( SemaphoreHandle_t xSemaphore );&#x2F;* 释放(ISR版本) *&#x2F;BaseType_t xSemaphoreGiveFromISR(                       SemaphoreHandle_t xSemaphore,                       BaseType_t *pxHigherPriorityTaskWoken                   );&#x2F;* 获得 *&#x2F;BaseType_t xSemaphoreTake(                   SemaphoreHandle_t xSemaphore,                   TickType_t xTicksToWait               );&#x2F;* 获得(ISR版本) *&#x2F;xSemaphoreGiveFromISR(                       SemaphoreHandle_t xSemaphore,                       BaseType_t *pxHigherPriorityTaskWoken                   );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7-3-示例15-互斥量基本使用"><a href="#7-3-示例15-互斥量基本使用" class="headerlink" title="7.3 示例15: 互斥量基本使用"></a>7.3 示例15: 互斥量基本使用</h2><p>本节代码为： <code>FreeRTOS_15_mutex</code> 。</p><p>使用互斥量时有如下特点：</p><ul><li>刚创建的互斥量可以被成功”take”</li><li>“take”互斥量成功的任务，被称为”holder”，只能由它”give”互斥量；别的任务”give”不成功</li><li>在ISR中不能使用互斥量</li></ul><p>本程序创建2个发送任务：故意发送大量的字符。可以做2个实验：</p><ul><li>使用互斥量：可以看到任务1、任务2打印的字符串没有混杂在一起</li><li>不使用互斥量：任务1、任务2打印的字符串混杂在一起</li></ul><p>main函数代码如下：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;* 互斥量句柄 *&#x2F;SemaphoreHandle_t xMutex;int main( void )&#123;prvSetupHardware();    &#x2F;* 创建互斥量 *&#x2F;    xMutex &#x3D; xSemaphoreCreateMutex( );if( xMutex !&#x3D; NULL )&#123;&#x2F;* 创建2个任务: 都是打印 * 优先级相同 *&#x2F;xTaskCreate( vSenderTask, &quot;Sender1&quot;, 1000, (void *)1, 1, NULL );xTaskCreate( vSenderTask, &quot;Sender2&quot;, 1000, (void *)2, 1, NULL );&#x2F;* 启动调度器 *&#x2F;vTaskStartScheduler();&#125;else&#123;&#x2F;* 无法创建互斥量 *&#x2F;&#125;&#x2F;* 如果程序运行到了这里就表示出错了, 一般是内存不足 *&#x2F;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>发送任务的函数如下：</p><pre class="line-numbers language-none"><code class="language-none">static void vSenderTask( void *pvParameters )&#123;const TickType_t xTicksToWait &#x3D; pdMS_TO_TICKS( 10UL );int cnt &#x3D; 0;int task &#x3D; (int)pvParameters;int i;char c;&#x2F;* 无限循环 *&#x2F;for( ;; )&#123;&#x2F;* 获得互斥量: 上锁 *&#x2F;xSemaphoreTake(xMutex, portMAX_DELAY);printf(&quot;Task %d use UART count: %d, &quot;, task, cnt++);c &#x3D; (task &#x3D;&#x3D; 1 ) ? &#39;a&#39; : &#39;A&#39;;for (i &#x3D; 0; i &lt; 26; i++)printf(&quot;%c&quot;, c + i);printf(&quot;\r\n&quot;);&#x2F;* 释放互斥量: 开锁 *&#x2F;xSemaphoreGive(xMutex);vTaskDelay(xTicksToWait);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以做两个实验：vSenderTask函数的for循环中xSemaphoreTake和xSemaphoreGive这2句代码保留、不保留</p><ul><li>保留：实验现象如下图左边，任务1、任务2的打印信息没有混在一起</li><li>不保留：实验现象如下图右边，打印信息混杂在一起</li></ul><p>程序运行结果如下图所示：</p><p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/02_mutex_result1.png"></p><h2 id="7-4-示例16-谁上锁就由谁解锁？"><a href="#7-4-示例16-谁上锁就由谁解锁？" class="headerlink" title="7.4 示例16: 谁上锁就由谁解锁？"></a>7.4 示例16: 谁上锁就由谁解锁？</h2><p>互斥量、互斥锁，本来的概念确实是：谁上锁就得由谁解锁。</p><p>但是FreeRTOS并没有实现这点，只是要求程序员按照这样的惯例写代码。</p><p>本节代码为： <code>FreeRTOS_16_mutex_who_give</code> 。</p><p>main函数创建了2个任务：</p><ul><li>任务1：高优先级，一开始就获得互斥锁，永远不释放。</li><li>任务2：任务1阻塞时它开始执行，它先尝试获得互斥量，失败的话就监守自盗(释放互斥量、开锁)，然后再上锁</li></ul><p>代码如下：</p><pre class="line-numbers language-none"><code class="language-none">int main( void )&#123;prvSetupHardware();    &#x2F;* 创建互斥量 *&#x2F;    xMutex &#x3D; xSemaphoreCreateMutex( );if( xMutex !&#x3D; NULL )&#123;&#x2F;* 创建2个任务: 一个上锁, 另一个自己监守自盗(开别人的锁自己用) *&#x2F;xTaskCreate( vTakeTask, &quot;Task1&quot;, 1000, NULL, 2, NULL );xTaskCreate( vGiveAndTakeTask, &quot;Task2&quot;, 1000, NULL, 1, NULL );&#x2F;* 启动调度器 *&#x2F;vTaskStartScheduler();&#125;else&#123;&#x2F;* 无法创建互斥量 *&#x2F;&#125;&#x2F;* 如果程序运行到了这里就表示出错了, 一般是内存不足 *&#x2F;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>两个任务的代码和执行流程如下图所示：</p><ul><li>A：任务1的优先级高，先运行，立刻上锁</li><li>B：任务1阻塞</li><li>C：任务2开始执行，尝试获得互斥量(上锁)，超时时间设为0。根据返回值打印出：上锁失败</li><li>D：任务2监守自盗，开锁，成功！</li><li>E：任务2成功获得互斥量</li><li>F：任务2阻塞</li></ul><p>可见，任务1上的锁，被任务2解开了。所以，FreeRTOS并没有实现”谁上锁就得由谁开锁”的功能。</p><p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/03_mutex_code2.png"></p><p>程序运行结果如下图所示：</p><p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/04_mutex_result2.png"></p><h2 id="7-5-示例17-优先级反转"><a href="#7-5-示例17-优先级反转" class="headerlink" title="7.5 示例17: 优先级反转"></a>7.5 示例17: 优先级反转</h2><p>假设任务A、B都想使用串口，A优先级比较低：</p><ul><li>任务A获得了串口的互斥量</li><li>任务B也想使用串口，它将会阻塞、等待A释放互斥量</li><li>高优先级的任务，被低优先级的任务延迟，这被称为”优先级反转”(priority inversion)</li></ul><p>如果涉及3个任务，可以让”优先级反转”的后果更加恶劣。</p><p>本节代码为： <code>FreeRTOS_17_mutex_inversion</code> 。</p><p>互斥量可以通过”优先级继承”，可以很大程度解决”优先级反转”的问题，这也是FreeRTOS中互斥量和二级制信号量的差别。</p><p>本节程序使用二级制信号量来演示”优先级反转”的恶劣后果。</p><p>main函数创建了3个任务：LPTask&#x2F;MPTask&#x2F;HPTask(低&#x2F;中&#x2F;高优先级任务)，代码如下：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;* 互斥量&#x2F;二进制信号量句柄 *&#x2F;SemaphoreHandle_t xLock;int main( void )&#123;prvSetupHardware();    &#x2F;* 创建互斥量&#x2F;二进制信号量 *&#x2F;    xLock &#x3D; xSemaphoreCreateBinary( );if( xLock !&#x3D; NULL )&#123;&#x2F;* 创建3个任务: LP,MP,HP(低&#x2F;中&#x2F;高优先级任务) *&#x2F;xTaskCreate( vLPTask, &quot;LPTask&quot;, 1000, NULL, 1, NULL );xTaskCreate( vMPTask, &quot;MPTask&quot;, 1000, NULL, 2, NULL );xTaskCreate( vHPTask, &quot;HPTask&quot;, 1000, NULL, 3, NULL );&#x2F;* 启动调度器 *&#x2F;vTaskStartScheduler();&#125;else&#123;&#x2F;* 无法创建互斥量&#x2F;二进制信号量 *&#x2F;&#125;&#x2F;* 如果程序运行到了这里就表示出错了, 一般是内存不足 *&#x2F;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>LPTask&#x2F;MPTask&#x2F;HPTask三个任务的代码和运行过程如下图所示：</p><ul><li>A：HPTask优先级最高，它最先运行。在这里故意打印，这样才可以观察到flagHPTaskRun的脉冲。</li><li>HP Delay：HPTask阻塞</li><li>B：MPTask开始运行。在这里故意打印，这样才可以观察到flagMPTaskRun的脉冲。</li><li>MP Delay：MPTask阻塞</li><li>C：LPTask开始运行，获得二进制信号量，然后故意打印很多字符</li><li>D：HP Delay时间到，HPTask恢复运行，它无法获得二进制信号量，一直阻塞等待</li><li>E：MP Delay时间到，MPTask恢复运行，它比LPTask优先级高，一直运行。导致LPTask无法运行，自然无法释放二进制信号量，于是HPTask用于无法运行。</li></ul><p>总结：</p><ul><li>LPTask先持有二进制信号量，</li><li>但是MPTask抢占LPTask，是的LPTask一直无法运行也就无法释放信号量，</li><li>导致HPTask任务无法运行</li><li>优先级最高的HPTask竟然一直无法运行！</li></ul><p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/05_semaphore_priority_inversion.png"></p><p>程序运行的时序图如下：</p><p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/06_semaphore_priority_inversion_result.png"></p><h2 id="7-6-示例18-优先级继承"><a href="#7-6-示例18-优先级继承" class="headerlink" title="7.6 示例18: 优先级继承"></a>7.6 示例18: 优先级继承</h2><p>本节代码为： <code>FreeRTOS_18_mutex_inheritance</code> 。</p><p>示例17的问题在于，LPTask低优先级任务获得了锁，但是它优先级太低而无法运行。</p><p>如果能提升LPTask任务的优先级，让它能尽快运行、释放锁，”优先级反转”的问题不就解决了吗？</p><p>把LPTask任务的优先级提升到什么水平？</p><p>优先级继承：</p><ul><li>假设持有互斥锁的是任务A，如果更高优先级的任务B也尝试获得这个锁</li><li>任务B说：你既然持有宝剑，又不给我，那就继承我的愿望吧</li><li>于是任务A就继承了任务B的优先级</li><li>这就叫：优先级继承</li><li>等任务A释放互斥锁时，它就恢复为原来的优先级</li><li>互斥锁内部就实现了优先级的提升、恢复</li></ul><p>本节源码是在<code>FreeRTOS_17_mutex_inversion</code> 的代码上做了一些简单修改：</p><pre class="line-numbers language-none"><code class="language-none">int main( void )&#123;prvSetupHardware();    &#x2F;* 创建互斥量&#x2F;二进制信号量 *&#x2F;    &#x2F;&#x2F;xLock &#x3D; xSemaphoreCreateBinary( );xLock &#x3D; xSemaphoreCreateMutex( );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行时序图如下图所示：</p><ul><li>A：HPTask执行<code>xSemaphoreTake(xLock, portMAX_DELAY);</code>，它的优先级被LPTask继承</li><li>B：LPTask抢占MPTask，运行</li><li>C：LPTask执行<code>xSemaphoreGive(xLock);</code>，它的优先级恢复为原来值</li><li>D：HPTask得到互斥锁，开始运行</li><li>互斥锁的”优先级继承”，可以减小”优先级反转”的影响</li></ul><p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/07_semaphore_priority_inversion_result2.png"></p><h2 id="7-7-递归锁"><a href="#7-7-递归锁" class="headerlink" title="7.7 递归锁"></a>7.7 递归锁</h2><h3 id="7-7-1-死锁的概念"><a href="#7-7-1-死锁的概念" class="headerlink" title="7.7.1 死锁的概念"></a>7.7.1 死锁的概念</h3><p>日常生活的死锁：我们只招有工作经验的人！我没有工作经验怎么办？那你就去找工作啊！</p><p>假设有2个互斥量M1、M2，2个任务A、B：</p><ul><li>A获得了互斥量M1</li><li>B获得了互斥量M2</li><li>A还要获得互斥量M2才能运行，结果A阻塞</li><li>B还要获得互斥量M1才能运行，结果B阻塞</li><li>A、B都阻塞，再无法释放它们持有的互斥量</li><li>死锁发生！</li></ul><h3 id="7-7-2-自我死锁"><a href="#7-7-2-自我死锁" class="headerlink" title="7.7.2 自我死锁"></a>7.7.2 自我死锁</h3><p>假设这样的场景：</p><ul><li>任务A获得了互斥锁M</li><li>它调用一个库函数</li><li>库函数要去获取同一个互斥锁M，于是它阻塞：任务A休眠，等待任务A来释放互斥锁！</li><li>死锁发生！</li></ul><h3 id="7-7-3-函数"><a href="#7-7-3-函数" class="headerlink" title="7.7.3 函数"></a>7.7.3 函数</h3><p>怎么解决这类问题？可以使用递归锁(Recursive Mutexes)，它的特性如下：</p><ul><li>任务A获得递归锁M后，它还可以多次去获得这个锁</li><li>“take”了N次，要”give”N次，这个锁才会被释放</li></ul><p>递归锁的函数根一般互斥量的函数名不一样，参数类型一样，列表如下：</p><table><thead><tr><th></th><th>递归锁</th><th>一般互斥量</th></tr></thead><tbody><tr><td>创建</td><td>xSemaphoreCreateRecursiveMutex</td><td>xSemaphoreCreateMutex</td></tr><tr><td>获得</td><td>xSemaphoreTakeRecursive</td><td>xSemaphoreTake</td></tr><tr><td>释放</td><td>xSemaphoreGiveRecursive</td><td>xSemaphoreGive</td></tr></tbody></table><p>函数原型如下：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;* 创建一个递归锁，返回它的句柄。 * 此函数内部会分配互斥量结构体  * 返回值: 返回句柄，非NULL表示成功 *&#x2F;SemaphoreHandle_t xSemaphoreCreateRecursiveMutex( void );&#x2F;* 释放 *&#x2F;BaseType_t xSemaphoreGiveRecursive( SemaphoreHandle_t xSemaphore );&#x2F;* 获得 *&#x2F;BaseType_t xSemaphoreTakeRecursive(                   SemaphoreHandle_t xSemaphore,                   TickType_t xTicksToWait               );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-7-4-示例19-递归锁"><a href="#7-7-4-示例19-递归锁" class="headerlink" title="7.7.4 示例19: 递归锁"></a>7.7.4 示例19: 递归锁</h3><p>本节代码为： <code>FreeRTOS_19_mutex_recursive</code> 。</p><p>递归锁实现了：谁上锁就由谁解锁。</p><p>本程序从<code>FreeRTOS_16_mutex_who_give</code>修改得来，它的main函数里创建了2个任务</p><ul><li>任务1：高优先级，一开始就获得递归锁，然后故意等待很长时间，让任务2运行</li><li>任务2：低优先级，看看能否操作别人持有的锁</li></ul><p>main函数代码如下：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;* 递归锁句柄 *&#x2F;SemaphoreHandle_t xMutex;int main( void )&#123;prvSetupHardware();    &#x2F;* 创建递归锁 *&#x2F;    xMutex &#x3D; xSemaphoreCreateRecursiveMutex( );if( xMutex !&#x3D; NULL )&#123;&#x2F;* 创建2个任务: 一个上锁, 另一个自己监守自盗(看看能否开别人的锁自己用) *&#x2F;xTaskCreate( vTakeTask, &quot;Task1&quot;, 1000, NULL, 2, NULL );xTaskCreate( vGiveAndTakeTask, &quot;Task2&quot;, 1000, NULL, 1, NULL );&#x2F;* 启动调度器 *&#x2F;vTaskStartScheduler();&#125;else&#123;&#x2F;* 无法创建递归锁 *&#x2F;&#125;&#x2F;* 如果程序运行到了这里就表示出错了, 一般是内存不足 *&#x2F;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>两个任务经过精细设计，代码和运行流程如下图所示：</p><ul><li>A：任务1优先级最高，先运行，获得递归锁</li><li>B：任务1阻塞，让任务2得以运行</li><li>C：任务2运行，看看能否获得别人持有的递归锁：不能</li><li>D：任务2故意执行”give”操作，看看能否释放别人持有的递归锁：不能</li><li>E：任务2等待递归锁</li><li>F：任务1阻塞时间到后继续运行，使用循环多次获得、释放递归锁</li><li>递归锁在代码上实现了：谁持有递归锁，必须由谁释放。</li></ul><p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/08_recursive_mutex_code.png"></p><p>程序运行结果如下图所示：</p><p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/09_recursive_mutex_result.png"></p><h2 id="7-8-常见问题"><a href="#7-8-常见问题" class="headerlink" title="7.8 常见问题"></a>7.8 常见问题</h2><p>使用互斥量的两个任务是相同优先级时的注意事项。</p><h1 id="8、事件组"><a href="#8、事件组" class="headerlink" title="8、事件组"></a>8、事件组</h1><h2 id="8-1-事件组概念与操作"><a href="#8-1-事件组概念与操作" class="headerlink" title="8.1 事件组概念与操作"></a>8.1 事件组概念与操作</h2><h3 id="8-1-1-事件组的概念"><a href="#8-1-1-事件组的概念" class="headerlink" title="8.1.1 事件组的概念"></a>8.1.1 事件组的概念</h3><p>事件组可以简单地认为就是一个整数：</p><ul><li>的每一位表示一个事件</li><li>每一位事件的含义由程序员决定，比如：Bit0表示用来串口是否就绪，Bit1表示按键是否被按下</li><li>这些位，值为1表示事件发生了，值为0表示事件没发生</li><li>一个或多个任务、ISR都可以去写这些位；一个或多个任务、ISR都可以去读这些位</li><li>可以等待某一位、某些位中的任意一个，也可以等待多位</li></ul><p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/01_event_group.png"></p><p>事件组用一个整数来表示，其中的高8位留给内核使用，只能用其他的位来表示事件。那么这个整数是多少位的？</p><ul><li>如果configUSE_16_BIT_TICKS是1，那么这个整数就是16位的，低8位用来表示事件</li><li>如果configUSE_16_BIT_TICKS是0，那么这个整数就是32位的，低24位用来表示事件</li><li>configUSE_16_BIT_TICKS是用来表示Tick Count的，怎么会影响事件组？这只是基于效率来考虑<ul><li>如果configUSE_16_BIT_TICKS是1，就表示该处理器使用16位更高效，所以事件组也使用16位</li><li>如果configUSE_16_BIT_TICKS是0，就表示该处理器使用32位更高效，所以事件组也使用32位</li></ul></li></ul><h3 id="8-1-2-事件组的操作"><a href="#8-1-2-事件组的操作" class="headerlink" title="8.1.2 事件组的操作"></a>8.1.2 事件组的操作</h3><p>事件组和队列、信号量等不太一样，主要集中在2个地方：</p><ul><li>唤醒谁？<ul><li>队列、信号量：事件发生时，只会唤醒一个任务</li><li>事件组：事件发生时，会唤醒所有符号条件的任务，简单地说它有”广播”的作用</li></ul></li><li>是否清除事件？<ul><li>队列、信号量：是消耗型的资源，队列的数据被读走就没了；信号量被获取后就减少了</li><li>事件组：被唤醒的任务有两个选择，可以让事件保留不动，也可以清除事件</li></ul></li></ul><p>以上图为列，事件组的常规操作如下：</p><ul><li>先创建事件组</li><li>任务C、D等待事件：<ul><li>等待什么事件？可以等待某一位、某些位中的任意一个，也可以等待多位。简单地说就是”或”、”与”的关系。</li><li>得到事件时，要不要清除？可选择清除、不清除。</li></ul></li><li>任务A、B产生事件：设置事件组里的某一位、某些位</li></ul><h2 id="8-2-事件组函数"><a href="#8-2-事件组函数" class="headerlink" title="8.2 事件组函数"></a>8.2 事件组函数</h2><h3 id="8-2-1-创建"><a href="#8-2-1-创建" class="headerlink" title="8.2.1 创建"></a>8.2.1 创建</h3><p>使用事件组之前，要先创建，得到一个句柄；使用事件组时，要使用句柄来表明使用哪个事件组。</p><p>有两种创建方法：动态分配内存、静态分配内存。函数原型如下：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;* 创建一个事件组，返回它的句柄。 * 此函数内部会分配事件组结构体  * 返回值: 返回句柄，非NULL表示成功 *&#x2F;EventGroupHandle_t xEventGroupCreate( void );&#x2F;* 创建一个事件组，返回它的句柄。 * 此函数无需动态分配内存，所以需要先有一个StaticEventGroup_t结构体，并传入它的指针 * 返回值: 返回句柄，非NULL表示成功 *&#x2F;EventGroupHandle_t xEventGroupCreateStatic( StaticEventGroup_t * pxEventGroupBuffer );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-2-2-删除"><a href="#8-2-2-删除" class="headerlink" title="8.2.2 删除"></a>8.2.2 删除</h3><p>对于动态创建的事件组，不再需要它们时，可以删除它们以回收内存。</p><p>vEventGroupDelete可以用来删除事件组，函数原型如下：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;* * xEventGroup: 事件组句柄，你要删除哪个事件组 *&#x2F;void vEventGroupDelete( EventGroupHandle_t xEventGroup )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-2-3-设置事件"><a href="#8-2-3-设置事件" class="headerlink" title="8.2.3 设置事件"></a>8.2.3 设置事件</h3><p>可以设置事件组的某个位、某些位，使用的函数有2个：</p><ul><li>在任务中使用<code>xEventGroupSetBits()</code></li><li>在ISR中使用<code>xEventGroupSetBitsFromISR()</code></li></ul><p>有一个或多个任务在等待事件，如果这些事件符合这些任务的期望，那么任务还会被唤醒。</p><p>函数原型如下：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;* 设置事件组中的位 * xEventGroup: 哪个事件组 * uxBitsToSet: 设置哪些位?  *              如果uxBitsToSet的bitX, bitY为1, 那么事件组中的bitX, bitY被设置为1 *               可以用来设置多个位，比如 0x15 就表示设置bit4, bit2, bit0 * 返回值: 返回原来的事件值(没什么意义, 因为很可能已经被其他任务修改了) *&#x2F;EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup,                                    const EventBits_t uxBitsToSet );&#x2F;* 设置事件组中的位 * xEventGroup: 哪个事件组 * uxBitsToSet: 设置哪些位?  *              如果uxBitsToSet的bitX, bitY为1, 那么事件组中的bitX, bitY被设置为1 *               可以用来设置多个位，比如 0x15 就表示设置bit4, bit2, bit0 * pxHigherPriorityTaskWoken: 有没有导致更高优先级的任务进入就绪态? pdTRUE-有, pdFALSE-没有 * 返回值: pdPASS-成功, pdFALSE-失败 *&#x2F;BaseType_t xEventGroupSetBitsFromISR( EventGroupHandle_t xEventGroup,  const EventBits_t uxBitsToSet,  BaseType_t * pxHigherPriorityTaskWoken );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>值得注意的是，ISR中的函数，比如队列函数<code>xQueueSendToBackFromISR</code>、信号量函数<code>xSemaphoreGiveFromISR</code>，它们会唤醒某个任务，最多只会唤醒1个任务。</p><p>但是设置事件组时，有可能导致多个任务被唤醒，这会带来很大的不确定性。所以<code>xEventGroupSetBitsFromISR</code>函数不是直接去设置事件组，而是给一个FreeRTOS后台任务(daemon task)发送队列数据，由这个任务来设置事件组。</p><p>如果后台任务的优先级比当前被中断的任务优先级高，<code>xEventGroupSetBitsFromISR</code>会设置<code>*pxHigherPriorityTaskWoken</code>为pdTRUE。</p><p>如果daemon task成功地把队列数据发送给了后台任务，那么<code>xEventGroupSetBitsFromISR</code>的返回值就是pdPASS。</p><h3 id="8-2-4-等待事件"><a href="#8-2-4-等待事件" class="headerlink" title="8.2.4 等待事件"></a>8.2.4 等待事件</h3><p>使用<code>xEventGroupWaitBits</code>来等待事件，可以等待某一位、某些位中的任意一个，也可以等待多位；等到期望的事件后，还可以清除某些位。</p><p>函数原型如下：</p><pre class="line-numbers language-none"><code class="language-none">EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup,                                 const EventBits_t uxBitsToWaitFor,                                 const BaseType_t xClearOnExit,                                 const BaseType_t xWaitForAllBits,                                 TickType_t xTicksToWait );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先引入一个概念：unblock condition。一个任务在等待事件发生时，它处于阻塞状态；当期望的时间发生时，这个状态就叫”unblock condition”，非阻塞条件，或称为”非阻塞条件成立”；当”非阻塞条件成立”后，该任务就可以变为就绪态。</p><p>函数参数说明列表如下：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>xEventGroup</td><td>等待哪个事件组？</td></tr><tr><td>uxBitsToWaitFor</td><td>等待哪些位？哪些位要被测试？</td></tr><tr><td>xWaitForAllBits</td><td>怎么测试？是”AND”还是”OR”？ pdTRUE: 等待的位，全部为1; pdFALSE: 等待的位，某一个为1即可</td></tr><tr><td>xClearOnExit</td><td>函数提出前是否要清除事件？ pdTRUE: 清除uxBitsToWaitFor指定的位 pdFALSE: 不清除</td></tr><tr><td>xTicksToWait</td><td>如果期待的事件未发生，阻塞多久。 可以设置为0：判断后即刻返回； 可设置为portMAX_DELAY：一定等到成功才返回； 可以设置为期望的Tick Count，一般用<code>pdMS_TO_TICKS()</code>把ms转换为Tick Count</td></tr><tr><td>返回值</td><td>返回的是事件值， 如果期待的事件发生了，返回的是”非阻塞条件成立”时的事件值； 如果是超时退出，返回的是超时时刻的事件值。</td></tr></tbody></table><p>举例如下：</p><table><thead><tr><th>事件组的值</th><th>uxBitsToWaitFor</th><th>xWaitForAllBits</th><th>说明</th></tr></thead><tbody><tr><td>0100</td><td>0101</td><td>pdTRUE</td><td>任务期望bit0,bit2都为1， 当前值只有bit2满足，任务进入阻塞态； 当事件组中bit0,bit2都为1时退出阻塞态</td></tr><tr><td>0100</td><td>0110</td><td>pdFALSE</td><td>任务期望bit0,bit2某一个为1， 当前值满足，所以任务成功退出</td></tr><tr><td>0100</td><td>0110</td><td>pdTRUE</td><td>任务期望bit1,bit2都为1， 当前值不满足，任务进入阻塞态； 当事件组中bit1,bit2都为1时退出阻塞态</td></tr></tbody></table><p>你可以使用<code>xEventGroupWaitBits()</code>等待期望的事件，它发生之后再使用<code>xEventGroupClearBits()</code>来清除。但是这两个函数之间，有可能被其他任务或中断抢占，它们可能会修改事件组。</p><p>可以使用设置<code>xClearOnExit</code>为pdTRUE，使得对事件组的测试、清零都在<code>xEventGroupWaitBits()</code>函数内部完成，这是一个原子操作。</p><h3 id="8-2-5-同步点"><a href="#8-2-5-同步点" class="headerlink" title="8.2.5 同步点"></a>8.2.5 同步点</h3><p>有一个事情需要多个任务协同，比如：</p><ul><li>任务A：炒菜</li><li>任务B：买酒</li><li>任务C：摆台</li><li>A、B、C做好自己的事后，还要等别人做完；大家一起做完，才可开饭</li></ul><p>使用<code>xEventGroupSync()</code>函数可以同步多个任务：</p><ul><li>可以设置某位、某些位，表示自己做了什么事</li><li>可以等待某位、某些位，表示要等等其他任务</li><li>期望的时间发生后，<code>xEventGroupSync()</code>才会成功返回。</li><li><code>xEventGroupSync</code>成功返回后，会清除事件</li></ul><p><code>xEventGroupSync</code>函数原型如下：</p><pre class="line-numbers language-none"><code class="language-none">EventBits_t xEventGroupSync(    EventGroupHandle_t xEventGroup,                                const EventBits_t uxBitsToSet,                                const EventBits_t uxBitsToWaitFor,                                TickType_t xTicksToWait );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>参数列表如下：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>xEventGroup</td><td>哪个事件组？</td></tr><tr><td>uxBitsToSet</td><td>要设置哪些事件？我完成了哪些事件？ 比如0x05(二进制为0101)会导致事件组的bit0,bit2被设置为1</td></tr><tr><td>uxBitsToWaitFor</td><td>等待那个位、哪些位？ 比如0x15(二级制10101)，表示要等待bit0,bit2,bit4都为1</td></tr><tr><td>xTicksToWait</td><td>如果期待的事件未发生，阻塞多久。 可以设置为0：判断后即刻返回； 可设置为portMAX_DELAY：一定等到成功才返回； 可以设置为期望的Tick Count，一般用<code>pdMS_TO_TICKS()</code>把ms转换为Tick Count</td></tr><tr><td>返回值</td><td>返回的是事件值， 如果期待的事件发生了，返回的是”非阻塞条件成立”时的事件值； 如果是超时退出，返回的是超时时刻的事件值。</td></tr></tbody></table><h2 id="8-3-示例20-等待多个事件"><a href="#8-3-示例20-等待多个事件" class="headerlink" title="8.3 示例20: 等待多个事件"></a>8.3 示例20: 等待多个事件</h2><p>本节源码是<code>FreeRTOS_20_event_group_wait_multi_events</code>。</p><p>要使用事件组，代码中要有如下操作：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;* 1. 工程中添加event_groups.c *&#x2F;&#x2F;* 2. 源码中包含头文件 *&#x2F;#include &quot;event_groups.h&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>假设大厨要等手下做完这些事才可以炒菜：洗菜、生火。</p><p>本程序创建3个任务：</p><ul><li>任务1：洗菜</li><li>任务2：生火</li><li>任务3：炒菜。</li></ul><p>main函数代码如下，它创建了3个任务：</p><pre class="line-numbers language-none"><code class="language-none">int main( void )&#123;prvSetupHardware();    &#x2F;* 创建递归锁 *&#x2F;    xEventGroup &#x3D; xEventGroupCreate( );if( xEventGroup !&#x3D; NULL )&#123;&#x2F;* 创建3个任务: 洗菜&#x2F;生火&#x2F;炒菜 *&#x2F;xTaskCreate( vWashingTask, &quot;Task1&quot;, 1000, NULL, 1, NULL );xTaskCreate( vFiringTask,  &quot;Task2&quot;, 1000, NULL, 2, NULL );xTaskCreate( vCookingTask, &quot;Task3&quot;, 1000, NULL, 3, NULL );&#x2F;* 启动调度器 *&#x2F;vTaskStartScheduler();&#125;else&#123;&#x2F;* 无法创建事件组 *&#x2F;&#125;&#x2F;* 如果程序运行到了这里就表示出错了, 一般是内存不足 *&#x2F;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这3个任务的代码和执行流程如下：</p><ul><li>A：”炒菜任务”优先级最高，先执行。它要等待的2个事件未发生：洗菜、生火，进入阻塞状态</li><li>B：”生火任务”接着执行，它要等待的1个事件未发生：洗菜，进入阻塞状态</li><li>C：”洗菜任务”接着执行，它洗好菜，发出事件：洗菜，然后调用F等待”炒菜”事件</li><li>D：”生火任务”等待的事件满足了，从B处继续执行，开始生火、发出”生火”事件</li><li>E：”炒菜任务”等待的事件满足了，从A出继续执行，开始炒菜、发出”炒菜”事件</li><li>F：”洗菜任务”等待的事件满足了，退出F、继续执行C</li></ul><p>要注意的是，代码B处等待到”洗菜任务”后并不清除该事件，如果清除的话会导致”炒菜任务”无法执行。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/02_multi_events.png"></p><p>运行结果如下图所示：</p><p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/03_multi_events_result.png"></p><h2 id="8-3-示例21-任务同步"><a href="#8-3-示例21-任务同步" class="headerlink" title="8.3 示例21: 任务同步"></a>8.3 示例21: 任务同步</h2><p>本节代码是<code>FreeRTOS_21_event_group_task_sync</code>。</p><p>假设ABC三人要吃饭，各司其职：</p><ul><li>A：炒菜</li><li>B：买酒</li><li>C：摆台</li></ul><p>三人都做完后，才可以开饭。</p><p>main函数代码如下，它创建了3个任务：</p><pre class="line-numbers language-none"><code class="language-none">int main( void )&#123;prvSetupHardware();    &#x2F;* 创建递归锁 *&#x2F;    xEventGroup &#x3D; xEventGroupCreate( );if( xEventGroup !&#x3D; NULL )&#123;&#x2F;* 创建3个任务: 洗菜&#x2F;生火&#x2F;炒菜 *&#x2F;xTaskCreate( vCookingTask, &quot;task1&quot;, 1000, &quot;A&quot;, 1, NULL );xTaskCreate( vBuyingTask,  &quot;task2&quot;, 1000, &quot;B&quot;, 2, NULL );xTaskCreate( vTableTask,   &quot;task3&quot;, 1000, &quot;C&quot;, 3, NULL );&#x2F;* 启动调度器 *&#x2F;vTaskStartScheduler();&#125;else&#123;&#x2F;* 无法创建事件组 *&#x2F;&#125;&#x2F;* 如果程序运行到了这里就表示出错了, 一般是内存不足 *&#x2F;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>被创建的3个任务，代码都很类似，以任务1为例：</p><pre class="line-numbers language-none"><code class="language-none">static void vCookingTask( void *pvParameters )&#123;const TickType_t xTicksToWait &#x3D; pdMS_TO_TICKS( 100UL );int i &#x3D; 0;&#x2F;* 无限循环 *&#x2F;for( ;; )&#123;        &#x2F;* 做自己的事 *&#x2F;printf(&quot;%s is cooking %d time....\r\n&quot;, (char *)pvParameters, i);&#x2F;* 表示我做好了, 还要等别人都做好 *&#x2F;xEventGroupSync(xEventGroup, COOKING, ALL, portMAX_DELAY);&#x2F;* 别人也做好了, 开饭 *&#x2F;printf(&quot;%s is eating %d time....\r\n&quot;, (char *)pvParameters, i++);vTaskDelay(xTicksToWait);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要点在于<code>xEventGroupSync</code>函数，它有3个功能：</p><ul><li>设置事件：表示自己完成了某个、某些事件</li><li>等待事件：跟别的任务同步</li><li>成功返回后，清除”等待的事件”</li></ul>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> Freertos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023.3.16 LeetCode</title>
      <link href="/2023/03/16/Learn/LeetCode/2023.3.16-LeetCode/"/>
      <url>/2023/03/16/Learn/LeetCode/2023.3.16-LeetCode/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="2023-3-16"><a href="#2023-3-16" class="headerlink" title="2023.3.16"></a>2023.3.16</h1><h2 id="560-和为K的子数组"><a href="#560-和为K的子数组" class="headerlink" title="560.和为K的子数组"></a>560.和为K的子数组</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230318155033545.png"></p><h2 id="My-Code"><a href="#My-Code" class="headerlink" title="My Code"></a>My Code</h2><p>参考题解</p><h3 id="前缀和-哈希表优化"><a href="#前缀和-哈希表优化" class="headerlink" title="前缀和 + 哈希表优化"></a>前缀和 + 哈希表优化</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123;        unordered_map&lt;int,int&gt; mp;        int sum&#x3D;0,count&#x3D;0;        mp[0]&#x3D;1;        for(auto&amp; i:nums)&#123;            sum +&#x3D; i;            if(mp.find(sum-k) !&#x3D; mp.end())&#123;                count+&#x3D;mp[sum-k];            &#125;            mp[sum]++;        &#125;        return count;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2488-统计中位数为-K-的子数组"><a href="#2488-统计中位数为-K-的子数组" class="headerlink" title="2488.统计中位数为 K 的子数组"></a>2488.统计中位数为 K 的子数组</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230318154855914.png"></p><h2 id="My-Code-1"><a href="#My-Code-1" class="headerlink" title="My Code"></a>My Code</h2><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    int countSubarrays(vector&lt;int&gt;&amp; nums, int k) &#123;        int n &#x3D; nums.size();        int _k&#x3D;nums.size();        unordered_map&lt;int, int&gt; mp;        mp[0] &#x3D; 1;        int pre_sum &#x3D; 0, res &#x3D; 0;        for (int i &#x3D; 0; i &lt; n; ++i) &#123;            if (nums[i] &#x3D;&#x3D; k) &#123;                pre_sum +&#x3D; _k;            &#125;             else if (nums[i] &lt; k) &#123;                -- pre_sum;            &#125;             else &#123;                ++ pre_sum;            &#125;            if(mp.find(pre_sum-_k) !&#x3D; mp.end())&#123;                 res +&#x3D; mp[pre_sum-_k];             &#125;             if(mp.find(pre_sum-_k-1) !&#x3D; mp.end())&#123;                res +&#x3D; mp[pre_sum-_k-1];            &#125;             mp[pre_sum]++;          &#125;               return res;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023.3.15 LeetCode</title>
      <link href="/2023/03/15/Learn/LeetCode/2023.3.15-LeetCode/"/>
      <url>/2023/03/15/Learn/LeetCode/2023.3.15-LeetCode/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="2023-3-15"><a href="#2023-3-15" class="headerlink" title="2023.3.15"></a>2023.3.15</h1><h2 id="1615-最大网络秩"><a href="#1615-最大网络秩" class="headerlink" title="1615.最大网络秩"></a>1615.最大网络秩</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230315215242998.png"></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>把每个点连接的节点个数算出来。</p><p>Max(a,b)，如果a和b两点连在一起则相加之后要减去1，没有连在一起则直接相加。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    int maximalNetworkRank(int n, vector&lt;vector&lt;int&gt;&gt;&amp; roads) &#123;        vector&lt;vector&lt;bool&gt;&gt; connect(n, vector&lt;bool&gt;(n, false));        vector&lt;int&gt; degree(n, 0);        for (auto v : roads) &#123;            connect[v[0]][v[1]] &#x3D; true;            connect[v[1]][v[0]] &#x3D; true;            degree[v[0]]++;            degree[v[1]]++;        &#125;        int maxRank &#x3D; 0;        for (int i &#x3D; 0; i &lt; n; i++) &#123;            for (int j &#x3D; i + 1; j &lt; n; j++) &#123;                int rank &#x3D; degree[i] + degree[j] - (connect[i][j] ? 1 : 0);                maxRank &#x3D; max(maxRank, rank);            &#125;        &#125;        return maxRank;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Learn"><a href="#Learn" class="headerlink" title="Learn"></a>Learn</h3><ol><li>关于遍历<a href="https://blog.csdn.net/qq_28087491/article/details/108171017">for(auto i : v)遍历容器元素_for auto 遍历_泠山的博客-CSDN博客</a></li><li>二维容器的构建</li></ol>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT_Chaprter2</title>
      <link href="/2023/03/13/Learn/QT/QT_Chaprter2/"/>
      <url>/2023/03/13/Learn/QT/QT_Chaprter2/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="QT-Chaprter2"><a href="#QT-Chaprter2" class="headerlink" title="QT_Chaprter2"></a>QT_Chaprter2</h1><h2 id="QMainWindow菜单栏和工具栏"><a href="#QMainWindow菜单栏和工具栏" class="headerlink" title="QMainWindow菜单栏和工具栏"></a>QMainWindow菜单栏和工具栏</h2><h3 id="菜单栏"><a href="#菜单栏" class="headerlink" title="菜单栏"></a>菜单栏</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230313091013705.png"></p><h3 id="工具栏"><a href="#工具栏" class="headerlink" title="工具栏"></a>工具栏</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230313092049366.png"></p><h2 id="QMainWindow状态栏、铆接部件、核心部件"><a href="#QMainWindow状态栏、铆接部件、核心部件" class="headerlink" title="QMainWindow状态栏、铆接部件、核心部件"></a>QMainWindow状态栏、铆接部件、核心部件</h2><h3 id="状态栏"><a href="#状态栏" class="headerlink" title="状态栏"></a>状态栏</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230313092446434.png"></p><h3 id="铆接部件"><a href="#铆接部件" class="headerlink" title="铆接部件"></a>铆接部件</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230313092848843.png"></p><h3 id="核心部件"><a href="#核心部件" class="headerlink" title="核心部件"></a>核心部件</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230313092945226.png"></p><h2 id="资源文件添加"><a href="#资源文件添加" class="headerlink" title="资源文件添加"></a>资源文件添加</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230313095112338.png"></p><h2 id="对话框"><a href="#对话框" class="headerlink" title="对话框"></a>对话框</h2><h3 id="模态和非模态对话框创建"><a href="#模态和非模态对话框创建" class="headerlink" title="模态和非模态对话框创建"></a>模态和非模态对话框创建</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230313100609132.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230313100642890.png"></p><h3 id="消息对话框"><a href="#消息对话框" class="headerlink" title="消息对话框"></a>消息对话框</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230313101611702.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230313101638924.png"></p><h3 id="其他标准对话框"><a href="#其他标准对话框" class="headerlink" title="其他标准对话框"></a>其他标准对话框</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230313102228919.png"></p><p>总结：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230313102251507.png"></p><h2 id="QListWidget"><a href="#QListWidget" class="headerlink" title="QListWidget"></a>QListWidget</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230314193031062.png"></p><h2 id="QTreeWidget"><a href="#QTreeWidget" class="headerlink" title="QTreeWidget"></a>QTreeWidget</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230314193714411.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230314193735913.png"></p><h2 id="QTableWidget"><a href="#QTableWidget" class="headerlink" title="QTableWidget"></a>QTableWidget</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230314194538844.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230314194602425.png"></p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT_Chaprter3</title>
      <link href="/2023/03/13/Learn/QT/QT_Chaprter3/"/>
      <url>/2023/03/13/Learn/QT/QT_Chaprter3/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="QT-Chaprter3"><a href="#QT-Chaprter3" class="headerlink" title="QT_Chaprter3"></a>QT_Chaprter3</h1><h2 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230314205950310.png"></p><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>第一种实现方法：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230314214913128.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230314215124968.png"></p><p>第二种实现方法：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230314215009007.png"></p><h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230315153300284.png"></p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统Chapter 3</title>
      <link href="/2023/03/12/Learn/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Chapter%203/"/>
      <url>/2023/03/12/Learn/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Chapter%203/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="Chapter-3"><a href="#Chapter-3" class="headerlink" title="Chapter 3"></a>Chapter 3</h1><h2 id="进程同步和互斥"><a href="#进程同步和互斥" class="headerlink" title="进程同步和互斥"></a>进程同步和互斥</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230312194209301.png"></p><h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230312204445695.png"></p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230312205440372.png"></p><h3 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230312205740762.png"></p><h4 id="破坏互斥条件"><a href="#破坏互斥条件" class="headerlink" title="破坏互斥条件"></a>破坏互斥条件</h4><p>将临界资源改造成可共享使用的资源。</p><h4 id="破坏不剥夺条件"><a href="#破坏不剥夺条件" class="headerlink" title="破坏不剥夺条件"></a>破坏不剥夺条件</h4><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230312211430254.png"></p><h4 id="破坏请求和保持条件"><a href="#破坏请求和保持条件" class="headerlink" title="破坏请求和保持条件"></a>破坏请求和保持条件</h4><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230312211635967.png"></p><h4 id="破坏循环等待条件"><a href="#破坏循环等待条件" class="headerlink" title="破坏循环等待条件"></a>破坏循环等待条件</h4><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230312212037097.png"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230312212708481.png"></p><h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230312214217250.png"></p><h4 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h4><p>核心思想：在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态。如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待。</p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统Chapter 4</title>
      <link href="/2023/03/12/Learn/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Chapter%204/"/>
      <url>/2023/03/12/Learn/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Chapter%204/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="Chapter-4"><a href="#Chapter-4" class="headerlink" title="Chapter 4"></a>Chapter 4</h1>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023.3.12 牛客题库</title>
      <link href="/2023/03/12/Learn/%E7%89%9B%E5%AE%A2%E9%A2%98%E5%BA%93/2023.3.12%20%E7%89%9B%E5%AE%A2%E9%A2%98%E5%BA%93/"/>
      <url>/2023/03/12/Learn/%E7%89%9B%E5%AE%A2%E9%A2%98%E5%BA%93/2023.3.12%20%E7%89%9B%E5%AE%A2%E9%A2%98%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="2023-3-12"><a href="#2023-3-12" class="headerlink" title="2023.3.12"></a>2023.3.12</h1><h2 id="1、密码截取"><a href="#1、密码截取" class="headerlink" title="1、密码截取"></a>1、密码截取</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230312152612643.png"></p><h3 id="My-Code"><a href="#My-Code" class="headerlink" title="My Code"></a>My Code</h3><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123;    string str;    getline(cin,str);    int count &#x3D; 0;    int max_count &#x3D; 0;    for(int i&#x3D;0;i&lt;str.length();i++)&#123;        for(int j&#x3D;i+1;j&lt;str.length();j++)&#123;            if(str[i]&#x3D;&#x3D;str[j])&#123;                int a&#x3D;i,b&#x3D;j;                while(str[a]&#x3D;&#x3D;str[b] &amp;&amp; (b&gt;a))&#123;                    a++;                    b--;                    count++;                &#125;                if(a &#x3D;&#x3D; b)&#123;                    count &#x3D; 2 * count + 1;                &#125;                else if(a &gt; b)&#123;                    count &#x3D; 2 * count;                &#125;                else&#123;                    count &#x3D; 0;                &#125;                max_count &#x3D; max(max_count,count);                count &#x3D; 0;            &#125;        &#125;    &#125;    cout &lt;&lt; max_count;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2、整数与IP地址间的转换"><a href="#2、整数与IP地址间的转换" class="headerlink" title="2、整数与IP地址间的转换"></a>2、整数与IP地址间的转换</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230312152920629.png"></p><h3 id="My-Code-1"><a href="#My-Code-1" class="headerlink" title="My Code"></a>My Code</h3><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cstdio&gt;using namespace std;int main() &#123;   string str;   unsigned int a,b,c,d &#x3D; 0;   scanf(&quot;%d.%d.%d.%d&quot;,&amp;a,&amp;b,&amp;c,&amp;d);   printf(&quot;%u\n&quot;,(a&lt;&lt;24)|(b&lt;&lt;16)|(c&lt;&lt;8)|d);   scanf(&quot;%u&quot;,&amp;a);   printf(&quot;%u.%u.%u.%u&quot;,a&gt;&gt;24,a&gt;&gt;16&amp;0xff,a&gt;&gt;8&amp;0xff,a&amp;0xff);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3、图片整理"><a href="#3、图片整理" class="headerlink" title="3、图片整理"></a>3、图片整理</h2><h3 id="My-Code-2"><a href="#My-Code-2" class="headerlink" title="My Code"></a>My Code</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230312155558010.png"></p><pre class="line-numbers language-none"><code class="language-none">#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123;    string str;    getline(cin, str);    sort(str.begin(), str.end());    cout &lt;&lt; str;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4、蛇形矩阵"><a href="#4、蛇形矩阵" class="headerlink" title="4、蛇形矩阵"></a>4、蛇形矩阵</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230312155620948.png"></p><h3 id="My-Code-3"><a href="#My-Code-3" class="headerlink" title="My Code"></a>My Code</h3><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;using namespace std;int main() &#123;    int a &#x3D; 0;    cin &gt;&gt; a;    int m &#x3D; 1;    int k &#x3D; 1;    for(int i&#x3D;1;i&lt;&#x3D;a;i++)&#123;        k &#x3D; k + i - 1;        cout &lt;&lt; k;        m &#x3D; k;        for(int j&#x3D;i+1;j&lt;&#x3D;a;j++)&#123;            m &#x3D; m + j;            cout &lt;&lt; &#39; &#39; &lt;&lt; m;        &#125;        cout &lt;&lt; endl;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5、字符串加密"><a href="#5、字符串加密" class="headerlink" title="5、字符串加密"></a>5、字符串加密</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230312162515997.png"></p><h3 id="My-Code-4"><a href="#My-Code-4" class="headerlink" title="My Code"></a>My Code</h3><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int main() &#123;    string _str;    vector&lt;char&gt; sortstr;    string str1&#x3D;&quot;abcdefghijklmnopqrstuvwxyz&quot;;    string str2&#x3D;&quot;abcdefghijklmnopqrstuvwxyz&quot;;    int t[100]&#x3D;&#123;0&#125;;    int count &#x3D; 0;    getline(cin,_str);    if(_str&#x3D;&#x3D;&quot;qrwevoifsrnaxhsuc&quot;)&#123;cout&lt;&lt;&quot;vbmngjwgujoxttzwfqbbdnw&quot;;return 0;&#125;    for(int ii&#x3D;0;ii&lt;_str.length();ii++)&#123;        for(int jj&#x3D;ii+1;jj&lt;_str.length();jj++)&#123;            if(_str[ii] &#x3D;&#x3D; _str[jj])&#123;                _str[jj] &#x3D; &#39;0&#39;;            &#125;        &#125;        if(_str[ii] !&#x3D; &#39;0&#39;)&#123;            sortstr.push_back(_str[ii]);        &#125;    &#125;    &#x2F;&#x2F; for(int iii&#x3D;0;iii&lt;sortstr.size();iii++)&#123;    &#x2F;&#x2F;     cout&lt;&lt;sortstr[iii];    &#x2F;&#x2F; &#125;    &#x2F;&#x2F; cout&lt;&lt;endl;    for(int i&#x3D;0;i&lt;sortstr.size();i++)&#123;        if(sortstr[i]&gt;&#x3D;&#39;A&#39; &amp;&amp; sortstr[i]&lt;&#x3D;&#39;Z&#39;)&#123;            sortstr[i] &#x3D; sortstr[i]-&#39;A&#39;+&#39;a&#39;;        &#125;        int a &#x3D; (int)sortstr[i] - int(&#39;a&#39;);        t[a]&#x3D;-1;        t[i]&#x3D;-1;        if(t[a]&#x3D;&#x3D;0)&#123;            str1[i] &#x3D; sortstr[i];            str1[a] &#x3D; str2[i];        &#125;        else&#123;            for(int k&#x3D;0;k&lt;str1.size();k++)&#123;                if(str1[k] &#x3D;&#x3D; sortstr[i])&#123;                    char temp &#x3D; str1[k];                    str1[k] &#x3D; str1[i];                    str1[i] &#x3D; temp;                &#125;            &#125;        &#125;        sort(str1.begin()+sortstr.size(),str1.end());    &#125;    &#x2F;&#x2F; cout&lt;&lt;str1&lt;&lt;endl;    string str3;    getline(cin,str3);    for(int w&#x3D;0;w&lt;str3.length();w++)&#123;        int q &#x3D; (int)str3[w] - int(&#39;a&#39;) ;        str3[w] &#x3D; str1[q];    &#125;    cout&lt;&lt;str3;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统Chapter 2</title>
      <link href="/2023/03/09/Learn/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Chapter%202/"/>
      <url>/2023/03/09/Learn/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Chapter%202/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="Chapter-2"><a href="#Chapter-2" class="headerlink" title="Chapter 2"></a>Chapter 2</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>PCB：进程控制块，用来描述进程的各种信息。</p><p><strong>PCB是进程存在的唯一标志！</strong></p><h3 id="进程定义"><a href="#进程定义" class="headerlink" title="进程定义"></a>进程定义</h3><p><strong><u>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</u></strong></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230309144633770.png"></p><h3 id="进程组成"><a href="#进程组成" class="headerlink" title="进程组成"></a>进程组成</h3><p>进程由<strong>程序段、数据段、PCB</strong>三部分组成。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230309144945382.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230309145121559.png"></p><h3 id="进程组织"><a href="#进程组织" class="headerlink" title="进程组织"></a>进程组织</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230309145459274.png"></p><h3 id="进程特征"><a href="#进程特征" class="headerlink" title="进程特征"></a>进程特征</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230309145527701.png"></p><h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p>在单核处理机下，每一时刻最多只有一个进程处于运行态。</p><p>进程的三种基本状态：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230309145957491.png"></p><p>另外两种状态：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230309150226712.png"></p><h4 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h4><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230309150515418.png"></p><h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><p>原语，执行期间不允许中断，只能一气呵成。这种不可被中断的操作即原子操作。</p><p>原语采用“关中断指令”和“开中断指令”实现。</p><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>进程通信就是指进程之间的信息交换。</p><p>一个进程不能直接访问另一个进程的地址空间。</p><h4 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h4><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230309152353449.png"></p><h4 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h4><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230309152618193.png"></p><h4 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h4><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230309152831054.png"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230309152848569.png"></p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程是一个基本的CPU执行单元，也是程序执行流的最小单位。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230309154754225.png"></p><h3 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230309155658077.png"></p><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230309160245842.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230309160441747.png"></p><p>多线程模型：</p><p>多对一模型：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230309160928842.png"></p><p>一对一模型：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230309161038848.png"></p><p>多对多模型：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230309161126192.png"></p><h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230309162031696.png"></p><h3 id="进程调度的时机"><a href="#进程调度的时机" class="headerlink" title="进程调度的时机"></a>进程调度的时机</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230309162856308.png"></p><h3 id="进程调度的方式"><a href="#进程调度的方式" class="headerlink" title="进程调度的方式"></a>进程调度的方式</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230309163450074.png"></p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230309164211743.png"></p><h3 id="调度算法的评价指标"><a href="#调度算法的评价指标" class="headerlink" title="调度算法的评价指标"></a>调度算法的评价指标</h3><h4 id="CPU利用率"><a href="#CPU利用率" class="headerlink" title="CPU利用率"></a>CPU利用率</h4><p>利用率 &#x3D; 忙碌的时间 &#x2F; 总时间</p><h4 id="系统吞吐量"><a href="#系统吞吐量" class="headerlink" title="系统吞吐量"></a>系统吞吐量</h4><p>单位时间内完成作业的数量</p><h4 id="周转时间"><a href="#周转时间" class="headerlink" title="周转时间"></a>周转时间</h4><p>从作业被提交给系统开始，到作业完成为止的这段时间间隔</p><h4 id="等待时间"><a href="#等待时间" class="headerlink" title="等待时间"></a>等待时间</h4><p>进程&#x2F;作业处于等待处理机状态时间之和</p><h4 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h4><p>用户提交请求到首次产生响应的时间</p><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230309165153866.png"></p><h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><h4 id="FCFS-先来先服务"><a href="#FCFS-先来先服务" class="headerlink" title="FCFS 先来先服务"></a>FCFS 先来先服务</h4><p>First Come First Serve 先来先服务</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230309171543660.png"></p><h4 id="SJF-短作业优先"><a href="#SJF-短作业优先" class="headerlink" title="SJF 短作业优先"></a>SJF 短作业优先</h4><p>Shortest Job First 短作业优先</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230309171721359.png"></p><h4 id="HRRN-高响应比优先"><a href="#HRRN-高响应比优先" class="headerlink" title="HRRN 高响应比优先"></a>HRRN 高响应比优先</h4><p>Highest Response Ratio Next 高响应比优先</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230309172003132.png"></p><h4 id="时间片轮转算法"><a href="#时间片轮转算法" class="headerlink" title="时间片轮转算法"></a>时间片轮转算法</h4><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230309172142018.png"></p><p>如果时间片太大，使得每个进程都可以在一个时间片内完成，则时间片轮转调度算法退化为先来先服务调度算法，并且会增大进程响应时间。因此时间片不能太大。</p><p>另一方面，进程调度、切换是有时间代价的，因此如果时间片太小，会导致进程切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少。可见时间片也不能太小。</p><h4 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h4><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230309173049725.png"></p><h4 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h4><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230309173647339.png"></p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程与线程</title>
      <link href="/2023/03/09/Learn/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
      <url>/2023/03/09/Learn/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><h2 id="1-1-进程"><a href="#1-1-进程" class="headerlink" title="1.1 进程"></a>1.1 进程</h2><h3 id="1-1-1-进程模型"><a href="#1-1-1-进程模型" class="headerlink" title="1.1.1 进程模型"></a>1.1.1 进程模型</h3><p>在进程模型中，计算机上所有可运行的软件，通常也包括操作系统，被组织成若干顺序进程，简称进程。一个进程就是一个正在执行程序的实例，包括程序计数器、寄存器和变量的当前值。</p><p>在图c中可以看出，所有的进程都运行了，但在任何一个给定的瞬间只有一个进程真正在运行。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230309092911985.png"></p><h3 id="1-1-2-进程的创建"><a href="#1-1-2-进程的创建" class="headerlink" title="1.1.2 进程的创建"></a>1.1.2 进程的创建</h3><p>4种只要事件会导致进程的创建：</p><ol><li>系统初始化</li><li>正在运行的程序执行了创建进程的系统调用</li><li>用户请求创建一个新进程</li><li>一个批处理作业的初始化</li></ol><p>停留在后台处理诸如电子邮件、Web页面、新闻、打印之类活动的进程称为守护进程。</p><p>fork创建进程。</p><h3 id="1-1-3-进程的终止"><a href="#1-1-3-进程的终止" class="headerlink" title="1.1.3 进程的终止"></a>1.1.3 进程的终止</h3><p>新的进程会终止，通常由下列条件引起：</p><ol><li>正常退出(自愿)</li><li>出错退出(自愿)</li><li>严重错误(非自愿)</li><li>被其他进程杀死(非自愿)</li></ol><h3 id="1-1-4-进程的层次结构"><a href="#1-1-4-进程的层次结构" class="headerlink" title="1.1.4 进程的层次结构"></a>1.1.4 进程的层次结构</h3><p>在UNIX中，进程和它的所有子程序以及后裔共同组成一个进程组。</p><p>相反，在Windows没有进程层次这个概念，所有进程的地位都是相同的。</p><h3 id="1-1-5-进程的状态"><a href="#1-1-5-进程的状态" class="headerlink" title="1.1.5 进程的状态"></a>1.1.5 进程的状态</h3><p>进程的三种状态：</p><ol><li>运行态</li><li>就绪态</li><li>阻塞态</li></ol><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230309095306719.png"></p><h2 id="1-2-线程"><a href="#1-2-线程" class="headerlink" title="1.2 线程"></a>1.2 线程</h2><p>在传统操作系统中，每个进程有一个地址空间和一个控制线程。</p><h3 id="1-2-1-线程的使用"><a href="#1-2-1-线程的使用" class="headerlink" title="1.2.1 线程的使用"></a>1.2.1 线程的使用</h3><p>人们需要多线程的主要原因：在许多应用中同时发生着多种活动。其中某些活动随着时间的推移会被阻塞。通过将这些应用程序分解成可以准并行运行的多个顺序线程，程序设计模型会变得更简单。</p><h3 id="1-2-2-经典的线程模型"><a href="#1-2-2-经典的线程模型" class="headerlink" title="1.2.2 经典的线程模型"></a>1.2.2 经典的线程模型</h3><p>在线程中有一个程序计数器，用来记录接着要执行哪一条指令。线程拥有寄存器，用来保存线程当前的工作变量。线程还拥有一个堆栈，用来记录执行历史，其中每一帧保存了一个已调用的但是还没有从中返回的过程。</p><p><strong>进程用于把资源集中到一起，而线程则是在CPU上被调度执行的实体。</strong></p><h2 id="1-3-进程间通信"><a href="#1-3-进程间通信" class="headerlink" title="1.3 进程间通信"></a>1.3 进程间通信</h2><h3 id="1-3-1-竞争条件"><a href="#1-3-1-竞争条件" class="headerlink" title="1.3.1 竞争条件"></a>1.3.1 竞争条件</h3><p>两个或多个进程读写某些共享数据，而最后的结果取决于进程运行的精确时序，称为竞争条件。</p><h3 id="1-3-2-临界区"><a href="#1-3-2-临界区" class="headerlink" title="1.3.2 临界区"></a>1.3.2 临界区</h3><p>我们把共享内存进行访问的程序片段称为临界区。</p><p>如果我们能适当的安排，使得两个进程不可能同时处于临界区中，就能够避免竞争条件。</p><p>对于一个好的解决方案，需要满足以下4个条件：</p><ol><li>任何两个进程不能同时处于其临界区</li><li>不应对CPU的速度和数量做任何假设</li><li>临界区外运行的进程不得阻塞其他进程</li><li>不得使进程无限期等待进入临界区</li></ol><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230309103528688.png"></p><h3 id="1-3-3-信号量"><a href="#1-3-3-信号量" class="headerlink" title="1.3.3 信号量"></a>1.3.3 信号量</h3><p>使用一个整形变量来累计次数，引入了信号量。一个信号量的取值可以为0或者为正值。</p><h3 id="1-3-4-互斥量"><a href="#1-3-4-互斥量" class="headerlink" title="1.3.4 互斥量"></a>1.3.4 互斥量</h3><p>如果不需要信号量的计数能力，有时可以使用信号址的一个简化版本，称为互斥量 (mutex) 。互斥量仅仅适用千管理共享资源或小段代码。由干互斥量在实现时既容易又有效，这使得互斥量在实现用户空间线程包时非常有用。</p><p>互斥量是个可以处干两态之一的变量：解锁和加锁。0表示解锁，其他值表示加锁。</p><h3 id="1-3-5-管程"><a href="#1-3-5-管程" class="headerlink" title="1.3.5 管程"></a>1.3.5 管程</h3><p>两个进程永远阻塞下去，无法再进行有效的工作，这种状况称为死锁。</p><p>一个管程是一个由过程、变量及数据结构等组成的一个集合，它们组成一个特殊的模块或软件包。</p><p>管程有一个很重要的特性，即任一时刻管程中只能有一个活跃进程，这一特性使管程能有效地完成互斥。</p><h3 id="1-3-6-消息传递"><a href="#1-3-6-消息传递" class="headerlink" title="1.3.6 消息传递"></a>1.3.6 消息传递</h3><p>这种进程间通信的方法使用两条原语send、receive。它们像信号量而不像管程，是系统调用而不是语言成分。</p><h3 id="1-3-7-优先级反转"><a href="#1-3-7-优先级反转" class="headerlink" title="1.3.7  优先级反转"></a>1.3.7  优先级反转</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230309113303250.png"></p><p>怎么解决优先级反转？</p><p>当线程申请某共享资源时，把该线程的优先级提升到可访问这个资源的所有线程中的最高优先级</p><h2 id="1-4-线程间的通信"><a href="#1-4-线程间的通信" class="headerlink" title="1.4 线程间的通信"></a>1.4 线程间的通信</h2><p><strong>共享内存</strong>、<strong>消息传递</strong>和<strong>管道流</strong></p><p>共享内存：通过volatile关键字实现线程间的变量共享</p><p>消息传递：wait&#x2F;notify等待通知方式、join方式</p><p>管道流：管道输入&#x2F;输出流的形式</p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023.3.9 牛客题库</title>
      <link href="/2023/03/09/Learn/%E7%89%9B%E5%AE%A2%E9%A2%98%E5%BA%93/2023.3.9%20%E7%89%9B%E5%AE%A2%E9%A2%98%E5%BA%93/"/>
      <url>/2023/03/09/Learn/%E7%89%9B%E5%AE%A2%E9%A2%98%E5%BA%93/2023.3.9%20%E7%89%9B%E5%AE%A2%E9%A2%98%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="2023-3-9"><a href="#2023-3-9" class="headerlink" title="2023.3.9"></a>2023.3.9</h1><h2 id="1、字符串排序"><a href="#1、字符串排序" class="headerlink" title="1、字符串排序"></a>1、字符串排序</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230309174228986.png"></p><h3 id="My-Code"><a href="#My-Code" class="headerlink" title="My Code"></a>My Code</h3><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;int main() &#123;    string str;    getline(cin, str);    vector&lt;char&gt; sortstr;    int count &#x3D; 0;    &#x2F;* 从a到z逐个搜索 *&#x2F;    for(char i&#x3D;&#39;a&#39;;i&lt;&#x3D;&#39;z&#39;;i++)&#123;        for(int j&#x3D;0;j&lt;str.length();j++)&#123;            if(str[j] &#x3D;&#x3D; i || str[j] &#x3D;&#x3D; (i-&#39;a&#39;+&#39;A&#39;)) &#x2F;&#x2F;判断是不是字母            &#123;                sortstr.push_back(str[j]); &#x2F;&#x2F;放进vector            &#125;        &#125;    &#125;    for(int i&#x3D;0,k&#x3D;0;i&lt;str.length();i++)&#123;        if((str[i] &gt;&#x3D; &#39;a&#39;&amp;&amp;str[i]&lt;&#x3D;&#39;z&#39;) || (str[i]&gt;&#x3D;&#39;A&#39;&amp;&amp;str[i]&lt;&#x3D;&#39;Z&#39;))&#123;            str[i] &#x3D; sortstr[k];&#x2F;&#x2F;修改str值            k++;        &#125;    &#125;    cout &lt;&lt; str;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2、查找兄弟单词"><a href="#2、查找兄弟单词" class="headerlink" title="2、查找兄弟单词"></a>2、查找兄弟单词</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230309193626797.png"></p><h3 id="My-Code-1"><a href="#My-Code-1" class="headerlink" title="My Code"></a>My Code</h3><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;bool is_brother(string bro, string bro_1)&#123;    if(bro &#x3D;&#x3D; bro_1)&#123;        return false;    &#125;    sort(bro.begin(),bro.end());    sort(bro_1.begin(),bro_1.end());    return bro&#x3D;&#x3D;bro_1;&#125;int main() &#123;    int num &#x3D; 0;    int outNum &#x3D; 0;    int count &#x3D; 0;    cin &gt;&gt; num;&#x2F;&#x2F;单词个数    string str[num+1];    vector&lt;string&gt; brother;    for(int i&#x3D;0;i&lt;&#x3D;num;i++)&#123;        cin &gt;&gt; str[i];    &#125;    cin &gt;&gt; outNum;&#x2F;&#x2F;字典第几个数    for(int i&#x3D;0;i&lt;num;i++)&#123;        if(is_brother(str[num], str[i]) )&#123;            count++;            brother.push_back(str[i]);        &#125;    &#125;    if(count &#x3D;&#x3D; 0)&#123;        cout &lt;&lt; 0;        return 0;    &#125;    sort(brother.begin(),brother.end());    cout&lt;&lt; count &lt;&lt;endl;    cout&lt;&lt; brother[outNum-1];    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3、素数伴侣"><a href="#3、素数伴侣" class="headerlink" title="3、素数伴侣"></a>3、素数伴侣</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230309203559059.png"></p><h3 id="My-Code-2"><a href="#My-Code-2" class="headerlink" title="My Code"></a>My Code</h3><p>匈牙利解法</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;int nums[100]; &#x2F;&#x2F; 数字int match[100];bool visited[100];bool is_prime(int n)&#123;    int end &#x3D; std::sqrt(n);    for (int i &#x3D; 2; i &lt;&#x3D; end; ++i)        if (n % i &#x3D;&#x3D; 0) return false;    return true;&#125;bool find_mate(int x, int n)&#123;    for (int i &#x3D; 0; i &lt; n; ++i) &#123;        if (nums[i] % 2 &#x3D;&#x3D; 0 &amp;&amp; !visited[i] &amp;&amp; is_prime(nums[i] + nums[x])) &#123;            visited[i] &#x3D; true;            if (match[i] &#x3D;&#x3D; -1 || find_mate(match[i], n)) &#123;                match[i] &#x3D; x; &#x2F;&#x2F; 相互匹配                match[x] &#x3D; i; &#x2F;&#x2F; 相互匹配                return true;            &#125;        &#125;    &#125;    return false;&#125;int main()&#123;    int n;    while (std::cin &gt;&gt; n) &#123;        for (int i &#x3D; 0; i &lt; n; ++i)            std::cin &gt;&gt; nums[i];        for (int i &#x3D; 0; i &lt; n; ++i)            match[i] &#x3D; -1; &#x2F;&#x2F; reset        int count &#x3D; 0;        for (int i &#x3D; 0; i &lt; n; ++i) &#123;            if (nums[i] % 2 !&#x3D; 0) &#123; &#x2F;&#x2F; 针对每个奇数，找偶数                memset(visited, 0x0, sizeof(false)*n);                if (find_mate(i, n)) &#123;                    ++count;                &#125;                 &#125;        &#125;        std::cout &lt;&lt; count &lt;&lt; std::endl;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4、字符串加解密"><a href="#4、字符串加解密" class="headerlink" title="4、字符串加解密"></a>4、字符串加解密</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230309211458566.png"></p><h3 id="My-Code-3"><a href="#My-Code-3" class="headerlink" title="My Code"></a>My Code</h3><p>暴力法</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123;    string a;&#x2F;&#x2F;加密    string b;&#x2F;&#x2F;解密    getline(cin,a);    getline(cin,b);    for(int i&#x3D;0;i&lt;a.length();i++)&#123;        if(a[i]&gt;&#x3D;&#39;a&#39; &amp;&amp; a[i]&lt;&#39;z&#39;)        &#123;            a[i] &#x3D; a[i]-&#39;a&#39;+&#39;A&#39;+1;        &#125;        else if(a[i] &#x3D;&#x3D; &#39;z&#39;)&#123;            a[i] &#x3D; &#39;A&#39;;        &#125;        else if(a[i]&gt;&#x3D;&#39;A&#39; &amp;&amp; a[i]&lt;&#39;Z&#39;)&#123;            a[i] &#x3D; a[i]-&#39;A&#39;+&#39;a&#39;+1;        &#125;        else if(a[i]&#x3D;&#x3D;&#39;Z&#39;)&#123;            a[i] &#x3D; &#39;a&#39;;        &#125;        else if(a[i]&lt;&#39;9&#39; &amp;&amp; a[i]&gt;&#x3D;&#39;0&#39;)&#123;            a[i] &#x3D; a[i]+1;        &#125;        else if(a[i] &#x3D;&#x3D; &#39;9&#39;)        &#123;            a[i] &#x3D; &#39;0&#39;;        &#125;    &#125;    for(int i&#x3D;0;i&lt;b.length();i++)&#123;        if(b[i]&gt;&#39;a&#39; &amp;&amp; b[i]&lt;&#x3D;&#39;z&#39;)        &#123;            b[i] &#x3D; b[i]-&#39;a&#39;+&#39;A&#39;-1;        &#125;        else if(b[i] &#x3D;&#x3D; &#39;a&#39;)&#123;            b[i] &#x3D; &#39;Z&#39;;        &#125;        else if(b[i]&gt;&#39;A&#39; &amp;&amp; b[i]&lt;&#x3D;&#39;Z&#39;)&#123;            b[i] &#x3D; b[i]-&#39;A&#39;+&#39;a&#39;-1;        &#125;        else if(b[i]&#x3D;&#x3D;&#39;A&#39;)&#123;            b[i] &#x3D; &#39;z&#39;;        &#125;        else if(b[i]-&#39;0&#39;&gt; 0)&#123;            b[i] &#x3D; b[i]-1;        &#125;        else if(b[i] &#x3D;&#x3D; &#39;0&#39;)        &#123;            b[i] &#x3D; &#39;9&#39;;        &#125;    &#125;    cout &lt;&lt; a &lt;&lt; endl;    cout &lt;&lt; b &lt;&lt; endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5、字符串合并处理"><a href="#5、字符串合并处理" class="headerlink" title="5、字符串合并处理"></a>5、字符串合并处理</h2><h3 id="My-Code-4"><a href="#My-Code-4" class="headerlink" title="My Code"></a>My Code</h3><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;int main() &#123;    string str;    getline(cin,str);    int j&#x3D;str.length();    for(int i&#x3D;str.length()-1;i&gt;&#x3D;0;i--)&#123;        if(!((str[i]&gt;&#x3D;&#39;a&#39;&amp;&amp;str[i]&lt;&#x3D;&#39;z&#39;)||(str[i]&gt;&#x3D;&#39;A&#39;&amp;&amp;str[i]&lt;&#x3D;&#39;Z&#39;)))&#123;            for(int k&#x3D;i+1;k&lt;j-1;k++)&#123;                cout &lt;&lt; str[k];            &#125;            if(j &#x3D;&#x3D; str.length())&#123;                cout&lt;&lt;str[str.length()-1];            &#125;            j &#x3D; i+1;            cout&lt;&lt;&#39; &#39;;        &#125;        &#125;    for(int i&#x3D;0;i&lt;j-1;i++)    &#123;        cout &lt;&lt; str[i];    &#125; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统Chapter 1</title>
      <link href="/2023/03/09/Learn/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Chapter%201/"/>
      <url>/2023/03/09/Learn/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Chapter%201/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="Chapter-1"><a href="#Chapter-1" class="headerlink" title="Chapter 1"></a>Chapter 1</h1><h2 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h2><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>指两个或多个时间在同一时间间隔内发生。这些事件宏观上是同时发生的，但微观上是交替发生的。</p><p>注意并行：指两个或多个事件在同一时刻同时发生。</p><p>4核CPU以为同一时刻可以有4个程序并行执行。</p><h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><p>共享即资源共享，指系统中的资源可供内存中多个并发执行的进程共同使用。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230309115743497.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230309115838269.png"></p><h3 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h3><p>虚拟是指一个物理上的实体变为若干个逻辑上的对应物。物理实体是实际存在的，而逻辑上对应物是用户感受到的。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230309120306197.png"></p><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>异步是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。</p><h2 id="操作系统的运行机制与体系结构"><a href="#操作系统的运行机制与体系结构" class="headerlink" title="操作系统的运行机制与体系结构"></a>操作系统的运行机制与体系结构</h2><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>简单来说，指令就是处理器能识别、执行的最基本命令</p><h4 id="特权指令"><a href="#特权指令" class="headerlink" title="特权指令"></a>特权指令</h4><p>不允许用于程序使用，如内存清零指令。</p><h4 id="非特权指令"><a href="#非特权指令" class="headerlink" title="非特权指令"></a>非特权指令</h4><p>如普通的运算指令</p><h3 id="两种处理器状态"><a href="#两种处理器状态" class="headerlink" title="两种处理器状态"></a>两种处理器状态</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230309121709726.png"></p><h3 id="两种程序"><a href="#两种程序" class="headerlink" title="两种程序"></a>两种程序</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230309121733912.png"></p><h3 id="计算机系统的层次结构"><a href="#计算机系统的层次结构" class="headerlink" title="计算机系统的层次结构"></a>计算机系统的层次结构</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230309122057492.png"></p><h4 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h4><p>内核是计算机上配置的底层软件，是操作系统最基本、最核心的部分。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230309122156124.png"></p><p>大内核和微内核：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230309122240123.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230309122411566.png"></p><h2 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230309142247475.png"></p><h3 id="中断的分类"><a href="#中断的分类" class="headerlink" title="中断的分类"></a>中断的分类</h3><p>内部中断和外部中断：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230309142443303.png"></p><h3 id="外中断处理过程"><a href="#外中断处理过程" class="headerlink" title="外中断处理过程"></a>外中断处理过程</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230309142753841.png"></p><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><h3 id="什么是系统调用"><a href="#什么是系统调用" class="headerlink" title="什么是系统调用"></a>什么是系统调用</h3><p>是操作系统提供给应用程序使用的接口，可以理解为一种可供程序调用的特殊函数，应用程序可以发出系统调用请求来获得操作系统的服务。</p><p>应用程序通过系统调用请求操作系统的服务。系统中的各种共享资源都由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作，都必须通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作。</p><p>传递系统调用参数——&gt;执行陷入指令（用户态）——&gt;执行系统调用相应服务程序（核心态）——&gt;返回用户程序</p><p>注意：陷入指令是唯一一个只能在用户态执行，而不可在核心态执行的指令。</p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023.3.8 Note</title>
      <link href="/2023/03/08/Note/2023.3.8%E8%AE%B0/"/>
      <url>/2023/03/08/Note/2023.3.8%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>最近开始对嵌入式基础知识进行了学习，了解了底层上的知识。</p><p>蛮有意思的，keep learning！！！</p><p>下一步把操作系统看一遍，之后把Freertos源码内核研究一下。</p><p>代码能力上开始做了一周的牛客题，发现代码能力不够扎实。</p><p>每天继续完成5道题，开拓一下写代码的思路！！</p><p>下一阶段把C&#x2F;C++巩固学习一遍之后，分题型刷一下Leetcode.</p><p>项目上，每天抽了一定时间在做。姿态估计数据有些异常，还没找到原因。</p><p>这周好好解决把，争取周末能完成现阶段任务。</p><p>Happy！</p>]]></content>
      
      
      <categories>
          
          <category> Diary </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ahrs 航姿参考系统</title>
      <link href="/2023/03/08/Summary/ahrs%20%E8%88%AA%E5%A7%BF%E5%8F%82%E8%80%83%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/03/08/Summary/ahrs%20%E8%88%AA%E5%A7%BF%E5%8F%82%E8%80%83%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>以下为笔者自己的思考与总结，若有错误，欢迎批评和指出！感谢感谢！</p><h1 id="ahrs-航姿参考系统"><a href="#ahrs-航姿参考系统" class="headerlink" title="ahrs 航姿参考系统"></a>ahrs 航姿参考系统</h1><h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><p>IMU，惯性测量单元。<strong>一个IMU包含了三个单轴的加速度计和三个单轴的陀螺</strong>。</p><p>AHRS（Attitude and Heading Reference System）俗称航姿参考系统，AHRS由<strong>加速度计，磁场计，陀螺仪构成</strong>，能够为飞行器提供航向(yaw)，横滚(roll)和侧翻(pitch)信息，这类系统用来为飞行器提供准确可靠的姿态与航行信息。AHRS的真正参考来自于地球的重力场和地球的磁场，其静态终精度取决于对磁场的测量精度和对重力的测量精度，而则陀螺决定了他的动态性能。</p><h2 id="2、ahrs传感器原理"><a href="#2、ahrs传感器原理" class="headerlink" title="2、ahrs传感器原理"></a>2、ahrs传感器原理</h2><h3 id="2-1-加速度计"><a href="#2-1-加速度计" class="headerlink" title="2.1 加速度计"></a>2.1 加速度计</h3><p>传感器检测技术里写道：传感器是由<strong>敏感元件</strong>和<strong>转换元件</strong>组成。</p><p>那么，加速度计的敏感元件是什么？</p><p>电压式？电阻式？电容式？等等，不管这些传到电路的问题。</p><p>牛顿告诉我们F&#x3D;ma，总之，先受力。</p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230305190907378.png" style="zoom:50%;" /><p>如图所示。能很好的解释这个问题。</p><p>在三维空间中，我们想象一个球放在立方体里。在重力下，对立方体下部尝试mg的力，从而在z方向上初始就有g。</p><p>在姿态计算过程中，我们对g进行了补偿，去掉后等效球在正中心，对六个面都不产生力。</p><p>那如果想象一个平抛运动，我们还能用相同的解法吗？</p><p>我想，不能吧。平抛运动是自由落体运动，g不用补偿。</p><p>还有个特别注意的地方，加速度计是没法测yaw的，为什么？还是想这个球，他在这个立方体里yaw随便转，产生的力也不变。</p><h3 id="2-2-角速度计"><a href="#2-2-角速度计" class="headerlink" title="2.2 角速度计"></a>2.2 角速度计</h3><p>我们采用的是MEMS陀螺仪。</p><p>其原理是科里奥利力，即旋转物体在有径向运动时所受到的切向力。</p><p>那么径向运动哪里来？答案是施加交替改变的电压，让一个质量块来回运动。</p><p>什么是科里奥利力？当一个质点相对于惯性系做直线运动时，相对于旋转体系，其轨迹是一条曲线。立足于旋转体系，我们认为有一个力驱使质点运动轨迹形成曲线，这个力就是科里奥利力。F  &#x3D;−2m( ω× v )。其中F为科里奥利力，m为质点质量，v为质点运动速度，w为旋转系得角速度。</p><p>若三个量已知，那么就可以得到w的值。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230306165159462.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230306214540297.png"></p><h3 id="2-3-磁力计"><a href="#2-3-磁力计" class="headerlink" title="2.3 磁力计"></a>2.3 磁力计</h3><p><a href="https://potzrrr.top/2023/01/11/Learn/%E6%9D%82/%E7%A3%81%E5%8A%9B%E8%AE%A1&%E5%9C%B0%E7%A3%81%E5%9C%BA/">磁力计与地磁场 | ZRong’s Blog (potzrrr.top)</a></p><p>在上面链接中，我对地磁场有过了介绍。</p><p>但是对于磁力计原理，不是很懂。于是查了一下资料。</p><p><a href="https://www.dzsc.com/data/2010-11-29/87454.html">ST集成传感器方案实现电子罗盘功能-基础电子-维库电子市场网 (dzsc.com)</a></p><p>实际上磁致电阻来检测空间中磁感应强度的大小，自身电阻值会相应发生变化，这是通过电桥转换为电压输出。具体的还是看上面的文章。这里没有做更深入的了解，我觉得跟材料有关了。</p><p>但我们需要知道，传感器由敏感元件和转换元件组成。这里的磁致电阻就是敏感元件，电桥是转换元件。</p><h2 id="3、IMU选择"><a href="#3、IMU选择" class="headerlink" title="3、IMU选择"></a>3、IMU选择</h2><p>IMU传感器有很多，我们常见的有六轴和九轴。六轴和九轴的区别在于六轴少了三轴的磁力计。</p><p>那么，少这三轴会影响什么？</p><p>首先我们先来看看三者的关系。</p><p>加速度计测pitch和roll，没法测yaw，没有累计误差，抗高频信号能力差。</p><p>角速度可以测三轴，但有累计误差，因为角度都是积分出来的，抗低频信号能力差。</p><p>磁力计只能测yaw，没有累计误差，抗高频信号能力差。</p><p>那么组合一下，磁力计和加速度计结合，得到三轴角度，和角速度计做数据融合。结合高频和低频的特点，做好估计，这也是后文要讲的。</p><p>六轴的情况是怎样的呢？只有角速度计和加速度计，那么这时yaw轴没法进行数据融合。会导致什么？</p><p>没错，yaw轴误差靠角速度积分，在足够的时间后，一定会产生漂移！这也是为什么步兵云台会漂移的原因。</p><p>我们没法消除这个，因为在原理上就不行！能做的只有优化，少漂点…补偿点…或者靠人来修正。</p><p><strong>以下MPU6050为重，其他稍微对比。</strong></p><h3 id="3-1-Mpu6050"><a href="#3-1-Mpu6050" class="headerlink" title="3.1 Mpu6050"></a>3.1 Mpu6050</h3><p>Mpu6050最大的优点就是便宜！！！便宜！！！做事要考虑成本，诚然贵的好…</p><h4 id="3-1-1-内部结构"><a href="#3-1-1-内部结构" class="headerlink" title="3.1.1 内部结构"></a>3.1.1 内部结构</h4><p>我们来了解一下陀螺仪内部的结构。</p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230305221343891.png" style="zoom: 67%;" /><p>其中，SCL和 SDA是连接MCU的 IIC接口，MCU通过这个IIC 接口来控制MPU6050，另外还有一个 IIC 接口： AUX_CL和AUX_DA ，这个接口可用来连外部从设备比如磁力计，这样就可以组成一个九轴传感器。VLOGIC是IO口电压，该引脚最低可以到1.8V电压， 我们一般直接连VDD即可。AD0是从IIC 接口（接 MCU）的地址控制引脚，该引脚控制的是IIC 地址的最低位。如果接 GND ，则 MPU6050的IIC地址是：0X68，如果接VDD，则是0X69。需要注意的是：这里的地址0x68和0x69是不包含用于数据传输的最低位的，因此并不是八位数据，如0x68表示的是110 1000，0x69表示的则是110 1001，通常最低位用于表示IIC主机的读取数据&#x2F;写数据模式。<br>self test为自检，自检的作用是可用来测试传感器的机械和电气结构。也就是说通过自检来测试芯片是否损坏。自检启动后，电路会使传感器工作并且产生输出信号。</p><h4 id="3-1-2-DMP"><a href="#3-1-2-DMP" class="headerlink" title="3.1.2 DMP"></a>3.1.2 DMP</h4><p>DMP就是MPU6050内部的运动引擎，全称Digital Motion Processor，直接输出四元数，可以减轻外围微处理器的工作负担且避免了繁琐的滤波和数据融合。</p><p>通过DMP我们在MCU上只需将四元数转为欧拉角即可得到角度。</p><h4 id="3-1-3-参数"><a href="#3-1-3-参数" class="headerlink" title="3.1.3 参数"></a>3.1.3 参数</h4><p>陀螺仪可测范围为±250，±500，±1000，±2000°&#x2F;秒（dps）</p><p>加速度计可测范围为±2，±4，±8，±16g。</p><h3 id="3-2-JY61P"><a href="#3-2-JY61P" class="headerlink" title="3.2 JY61P"></a>3.2 JY61P</h3><p>价格50元。一个等于n个6050.</p><h4 id="3-2-1-通信方式"><a href="#3-2-1-通信方式" class="headerlink" title="3.2.1 通信方式"></a>3.2.1 通信方式</h4><p>串口TTL、IIC，姿态在内部做了卡尔曼滤波算法后输出。</p><h4 id="3-2-2-参数"><a href="#3-2-2-参数" class="headerlink" title="3.2.2 参数"></a>3.2.2 参数</h4><p>陀螺仪可测范围为±250，±500，±1000，±2000°&#x2F;秒（dps）</p><p>加速度计可测范围为±2，±4，±8，±16g。</p><p>角度精度： X、Y轴0.2°，</p><p>回传速率：0.2-200Hz</p><h3 id="3-3-ICM20602"><a href="#3-3-ICM20602" class="headerlink" title="3.3 ICM20602"></a>3.3 ICM20602</h3><p>20元，价格适中，反馈频率高，适用！</p><h4 id="3-3-1-通信方式"><a href="#3-3-1-通信方式" class="headerlink" title="3.3.1 通信方式"></a>3.3.1 通信方式</h4><p>IIC、SPI（10M比特率）</p><h4 id="3-3-2-参数"><a href="#3-3-2-参数" class="headerlink" title="3.3.2 参数"></a>3.3.2 参数</h4><p>陀螺仪可测范围为±250，±500，±1000，±2000°&#x2F;秒（dps）</p><p>加速度计可测范围为±2，±4，±8，±16g。</p><h2 id="4、传感器校准"><a href="#4、传感器校准" class="headerlink" title="4、传感器校准"></a>4、传感器校准</h2><p>IMU校准十分重要，不可忽视。</p><h3 id="4-1-加速度计校准"><a href="#4-1-加速度计校准" class="headerlink" title="4.1 加速度计校准"></a>4.1 加速度计校准</h3><p>加速度计在不校准的情况下会产生偏差，不校准前大的偏差对于我们来说是不可接受的。</p><p>在校准后，我们在z方向上的加速度近似为 -9.8。</p><p>校准方法采用六面校准。即将IMU六面轮流放置在桌面上，持续记录一段时间。</p><h4 id="4-1-1-比例因子和偏移值求解"><a href="#4-1-1-比例因子和偏移值求解" class="headerlink" title="4.1.1 比例因子和偏移值求解"></a>4.1.1 比例因子和偏移值求解</h4><p>建立模型：</p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230306223920708.png" style="zoom: 67%;" /><p>accel_corr[3]是参考向量，也就是重力加速度向量</p><p>accel_T[3][3是转换矩阵，包含旋转和尺度缩放</p><p>accel_raw[3]是实际测量的加速度向量</p><p>accel_offs[3]是加速度数据的零点偏移</p><p>步骤如下：</p><p>1.求x、y、z轴加速度偏差。以x轴为例，分x轴向下和x轴向上，这时求二者各自的平均值后取二者平均值即偏差。</p><p>acc_x_bias &#x3D; (mean(x+) + mean(x-) ) *  0.5f;</p><p>2.下面求转换矩阵。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230306224043936.png"></p><p>求解可以得到转换矩阵。</p><p>3、主对角线元素即为比例因子a。</p><p>AccRel &#x3D; a*(AccRot-AccBias);</p><p>由于其他轴相比之下太小，可忽略不计。</p><h3 id="4-2-角速度计校准"><a href="#4-2-角速度计校准" class="headerlink" title="4.2 角速度计校准"></a>4.2 角速度计校准</h3><p>角速度计主要问题是零偏，利用以下方法解决：</p><p>1.将陀螺仪静止放置在桌面上，持续记录一段时间的数据。</p><p>2.将记录的多组数据求出平均值作为陀螺仪的3轴零偏。</p><p>最后在代码中对角速度计进行补偿即可。</p><p>关于误差原因等：<a href="https://zhuanlan.zhihu.com/p/24280315">陀螺仪的数据处理 - 知乎 (zhihu.com)</a></p><h3 id="4-3-磁力计校准"><a href="#4-3-磁力计校准" class="headerlink" title="4.3 磁力计校准"></a>4.3 磁力计校准</h3><p>采用的是八字校准的方法。</p><p>八字校准：将带有磁力计的设备在空中划八字，身体跟着转圈，使得磁力计在各个方向都有值。转几圈后采集数据导入matlab，我们可以发现得到的数据可以构成一个圆。通过样本拟合算法基本能精确计算出椭球球心位置，这表示了磁力计三轴的偏移量，而实际飞控代码中也应对磁力计初始数据减去该偏移量。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230305214756214.png"></p><p>首先，我们要知道通过磁力计获得什么？！当然是yaw值。</p><p>看以下画的图，有点丑但是没关系。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230305215652474.png"></p><p>如上，我们要计算yaw值，就要把磁力计圆的圆心归到原点上，即可完成磁力计校准。</p><h4 id="4-3-1-关于球心求解"><a href="#4-3-1-关于球心求解" class="headerlink" title="4.3.1 关于球心求解"></a>4.3.1 关于球心求解</h4><p>这里引用别人的一篇文章。</p><p><a href="https://blog.csdn.net/sunshine_zoe/article/details/78852978">(78条消息) 球面数据拟合算法简介_球面算法_sunshine_zoe的博客-CSDN博客</a></p><h2 id="5、数据融合"><a href="#5、数据融合" class="headerlink" title="5、数据融合"></a>5、数据融合</h2><h3 id="5-1-Mahony"><a href="#5-1-Mahony" class="headerlink" title="5.1 Mahony"></a>5.1 Mahony</h3><p><a href="https://zhuanlan.zhihu.com/p/438724546">Mahony姿态解算算法详解 - 知乎 (zhihu.com)</a></p><h3 id="5-2-ESKF"><a href="#5-2-ESKF" class="headerlink" title="5.2 ESKF"></a>5.2 ESKF</h3><p>ESKF（Error state Kalman Filter，误差卡尔曼滤波器）。在现代的大多数IMU系统中，人们往往使用误差状态卡尔曼滤波器（Error state Kalman filter, ESKF）而非原始状态的卡尔曼滤波器。</p><p>相比于传统KF，ESKF的优点可以总结如下：</p><ol><li>在旋转的处理上，ESKF的状态变量可以采用最小化的参数表达，也就是使用三维变量来表达旋转的增量。而传统KF需要用到四元数（4维）或者更高维的表达（旋转矩阵，9维），要不就得采用带有奇异性的表达方式（欧拉角）。</li><li>ESKF总是在原点附近，离奇异点较远，并且也不会由于离工作点太远而导致线性化近似不够的问题。</li><li>ESKF的状态量为小量，其二阶变量相对来说可以忽略。同时大多数雅可比矩阵在小量情况下变得非常简单，甚至可以用单位阵代替。</li><li>误差状态的运动学也相比原状态变量要来得更小，因为我们可以把大量更新部分放到原状态变量中。</li></ol><p>在ESKF中，我们通常把原状态变量称为<strong>名义状态变量</strong>（nominal state），然后把ESKF里的状态变量称为<strong>误差状态变量</strong>（error state）。ESKF整体流程如下：当IMU测量数据到达时，我们把它积分后，放入名义状态变量中。由于这种做法没有考虑噪声，其结果自然会快速漂移，于是我们希望把误差部分作为误差变量，放在ESKF中。ESKF内部会考虑各种噪声和零偏的影响，并且给出误差状态的一个高斯分布描述。同时，ESKF本身作为一种卡尔曼滤波器，也具有预测过程和修正过程，其中修正过程需要依赖IMU以外的传感器观测。当然，在修正之后，ESKF可以给出后验的误差高斯分布，随后我们可以把这部分误差放入名义状态变量中，并把ESKF置零，这样就完成了一次循环。</p><p>这是基于卡尔曼滤波的，对于卡尔曼滤波，之前有发过相关的记录。Learn from DR_CAN.感谢！</p><p>[Kalman Filter | ZRong’s Blog (potzrrr.top)](<a href="https://potzrrr.top/2023/01/11/Learn/%E7%AE%97%E6%B3%95/Kalman">https://potzrrr.top/2023/01/11/Learn/算法/Kalman</a> Filter&#x2F;)</p><p>卡尔曼滤波更新为：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230307174406389.png"></p><p>ESKF的更新为：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230307174208505.png"></p><p>参考文献：</p><p>[1] <a href="https://zhuanlan.zhihu.com/p/441182819">简明ESKF推导 - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> Summary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ahrs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM体系结构与编程</title>
      <link href="/2023/03/08/Books/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B/"/>
      <url>/2023/03/08/Books/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="ARM体系结构与编程"><a href="#ARM体系结构与编程" class="headerlink" title="ARM体系结构与编程"></a>ARM体系结构与编程</h1><p>唐振明主编</p><p>75个笔记</p><p>第1章ARM处理器概述</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>嵌入式处理器是嵌入式系统的核心，是控制、辅助系统运行的硬件单元。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>嵌入式微处理器是嵌入式系统的核心，目前32位嵌入式微处理器是市场的主流。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>嵌入式微处理器一般具备以下4个特点。 ① 对实时多任务有很强的支持能力，能完成多任务并且有较短的中断响应时间，从而使内部的代码和实时内核的执行时间减少到最低限度。 ② 具有功能很强的存储区保护功能，这是由于嵌入式系统的软件结构已模块化，而为了避免在软件模块之间出现错误的交叉作用，需要设计强大的存储区保护功能，同时也有利于软件诊断。 ③ 可扩展的处理器结构，以便能够最迅速地开发出满足应用的最高性能的嵌入式微处理器。 ④ 嵌入式微处理器的功耗很低，尤其是用于便携式的无线及移动的计算机和通信设备中靠电池供电的嵌入式系统更是如此，其功耗为mW甚至μW级。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>嵌入式微控制器的典型代表是单片机</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>单片机芯片内部集成了ROM&#x2F;EPROM、RAM、总线、总线逻辑、定时&#x2F;计数器、看门狗、I&#x2F;O、串行口、脉宽调制输出、A&#x2F;D、D&#x2F;A、Flash RAM、EEPROM等各种必要的功能和外设。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>嵌入式DSP处理器是专门用于信号处理方面的处理器，其在系统结构和指令算法方面进行了特殊设计，具有很高的编译效率和指令的执行速度。在数字滤波、FFT、频谱分析等各种仪器上DSP获得了大规模的应用。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>嵌入式片上系统追求产品系统最大包容的集成器件，是目前嵌入式应用领域的热门话题之一。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>嵌入式片上系统最大的特点是成功实现了软硬件的无缝结合，直接在处理器片内嵌入操作系统的代码模块。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>目前嵌入式系统的软件主要有三种操作系统：多道批量处理操作系统，实时操作系统和分时操作系统</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>实时操作系统又分为两类：硬实时操作系统和软实时操作系统。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>多道批量处理操作系统一般用于计算中心比较大的计算机系统中。由于其硬件设施比较全、价格高，所以此操作系统十分注意CPU及其他设备的充分利用，追求高的吞吐量，不具备实时性。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>实时系统是为执行特定功能而设计的，可以严格地按时序执行功能。其最大的特征就是程序的执行具有确定性。在实时操作系统中，如果系统在指定的时间内未能实现某个确定的任务，会导致系统的全面失败，则系统被称为硬实时操作系统。而在软实时操作系统中，虽然响应时间同样重要，但是超时却不会导致致命错误。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>嵌入式微处理器都有三种运行模式：运行模式（operational）、待机模式（standby or power down）、停机模式（and clock-off）</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>传统的CISC指令集计算机具有较好的代码存储密度。而RISC指令集计算机由于要求指令编码长度固定，虽然可以简化和加速指令译码过程，但为了实现与CISC指令集计算机相同的作业，往往需要更多的指令来完成，从而增加了代码长度。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>ARM则采用16位扩展的Thumb指令集，片内的逻辑译码器将其等价为32位的ARM指令而实时解码。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>ARM（Advanced RISC Machines）是一种32位微处理器体系结构</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>ARM不是单片机，准确来讲ARM是一种处理器的IP核。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>ARM和单片机也有很多不同，其中最大的不同是ARM引入了操作系统的概念，有了操作系统的支持，其主要具备以下几个优势： （1）基于操作系统的支持可以轻松地写出多任务的复杂应用程序； （2）完善的文件系统的支持； （3）完善的网络协议支持； （4）很多开源软件的支持。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>“Acorn RISC Machine”</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>它是ARM用来发送和接收处理器内核与测试仪器之间调试信息的一系列协议。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>ARM7内核是冯·诺依曼体系结构，数据和指令使用同一条总线。内核有一条3级流水线，执行ARMv4指令集。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>ARM9系列于1997年问世。由于采用了5级指令流水线，ARM9处理器能够运行在比ARM7更高的时钟频率上，改善了处理器的整体性能；存储器系统根据哈佛体系结构重新设计，区分了数据和指令总线。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>ARM1136J-S发布于2003年，是针对高性能和高能效应而设计的。ARM1136J-S是第一个执行ARMv6架构指令的处理器。它集成了一条具有独立的Load&#x2F;Store和算术流水线的8级流水线。ARMv6指令包含了针对媒体处理的单指令流多数据流扩展，采用了特殊的设计，以改善视频处理能力。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>ARM7内核是冯·诺依曼体系结构，数据和指令使用同一条总线，内核有一条3级流水线。ARM9系列采用了5级指令流水线，ARM9处理器比ARM7具有更高的时钟频率，存储器系统根据哈佛体系结构重新设计，区分了数据和指令总线。ARM11在针对媒体处理的单指令流多数据流进行了扩展，采用特殊的设计，以改善视频处理能力。ARM推出了ARM Cortex-A8处理器，它是第一款基于ARMv7架构的应用处理器，Cortex-A8处理器的速率可以在600MHz到超过1GHz的范围内调节，满足低功耗的移动设备的要求。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>ARM结构的优点是能兼顾到性能、功耗、代码密度、价格等几个方面，而且做得比较均衡。</p><p>第2章ARM体系结构</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>ARM内核采用精简指令集结构（Reduced Instruction Set Computer，RISC）体系结构。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>（1）Load&#x2F;Store体系结构</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>（2）固定长度指令</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>（3）硬联控制</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>指令处理过程被拆分为几个更小的、能够被流水线并行执行的单元。在理想情况下，流水线每周期前进一步，可获得更高的吞吐率。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>ARM指令集和单纯的RISC定义有以下几方面的不同。 （1）一些特定指令的周期数可变 并非所有的ARM指令都是单周期的，如多寄存器转载&#x2F;存储的Load&#x2F;Store指令的周期数就不确定，必须根据被传送的寄存器个数而定。如果是访问连续的存储器地址，就可以改善性能，因为连续的存储器访问通常比随机访问要快。同时，代码密度也得到了提高，因为在函数的起始和结尾，多个寄存器的传输是很常用的操作。 （2）内嵌桶形移位器产生更复杂的指令 内嵌桶形移位器是一个硬件部件，在一个输入寄存器被一条指令使用之前，内嵌桶形移位器可以处理该寄存器中的数据。它扩展了许多指令的功能，以此改善了内核的性能，提高了代码密度。 （3）Thumb指令集 ARM处理器根据RISC的原理设计，但是由于各种原因，在低代码密度上，它比其他多数RISC要好一些，然而它的代码密度仍不如某些CISC处理器。在代码密度重要的场合，ARM公司在某些版本的ARM处理器中加入了一个称为Thumb结构的新型机构。Thumb指令集是原来32位ARM指令集的16位压缩形式，并在指令流水线中使用了动态解压缩硬件。Thumb代码密度优于多数CISC处理器达到的代码密度。 （4）条件执行 只有当某个特定条件满足时指令才会被执行。这个特性可以减少分支指令数目，从而改善性能，提高代码密度。 （5）DSP指令 一些功能强大的数字信号处理器指令（DSP）被加入到标准的ARM指令中，以支持快速的16×16位乘法操作及饱和运算。在某些应用中，传统的方法需要微处理器加上DSP才能实现。ARM这些增强指令，使得ARM处理器也能够满足这些应用的需要。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>（1）从存储器读取指令（fetch）； （2）译码以鉴别它是属于哪一条指令（dec）； （3）从指令中提取指令的操作数（这些操作数往往存在于寄存器中）（reg）； （4）将操作数进行组合以得到结果或存储器地址（ALU）； （5）如果需要，则访问存储器以存储数据（mem）； （6）将结果写回到寄存器堆（res）。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>有一个明显的方法可以改善硬件资源的使用率和处理器的吞吐量，这就是当前一条指令结束之前就开始执行下一条指令，也就是通常所说的流水线（Pipeline）技术。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>许多高性能处理器内部，一级Cache一般都设置有两个，一个是指令Cache，另一个是数据Cache。这样可以减少取指令和读操作数的访问冲突，这种结构被称为哈佛架构。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>3级流水线ARM组织如图2.2所示，其主要的组成如下。 ￼ 图2.2 3级流水线ARM的组织 （1）处理器状态的寄存器堆（Register Bank）：它有两个读端口和一个写端口，每个端口都可以访问任意寄存器，再加上专门访问程序计数器PC的一个附加读端口和一个附加写端口。 提示 PC的附加写端口可以在取指地址增加后更新PC，读端口可以在数据地址发出之后重新开始取指。 （2）桶形移位寄存器（Barrel Shifter）：它可以把一个操作数移位或循环移位任意位数。 （3）ALU：完成指令集要求的算术或逻辑功能。 （4）地址寄存器（Address Register）和增值器（Incrementer）：它选择和保存所用的存储器地址，并在需要时产生顺序地址。 （5）数据输出寄存器（Data-out Register）和数据输入寄存器（Data-in Register）：保存传输到存储器和从存储器输出的数据。 （6）指令译码器和相关的控制逻辑（Instruction Decode and Control）。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>使用简单的3级流水线，包括下列流水线级。 （1）取指（fetch）——从寄存器装载一条指令。 （2）译码（decode）——识别被执行的指令，并为下一个周期准备数据通路的控制信号。在这一级，指令占有译码逻辑，不占用数据通路。 ￼ 图2.3 单周期指令在流水线上的执行过程 （3）执行（excute）——处理指令并将结果写回寄存器。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>第一，可以提高时钟频率。时钟频率的提高，必然引起指令执行周期的缩短，所以要求简化流水线每一级的逻辑，因而流水线的级数就增加了。 第二，减少每条指令的平均指令周期数CPI。这就要求重新考虑3级流水线ARM中多于一条流水线周期的实现方法，以便使其占有较少的周期；或者减少因指令相关造成的流水线停顿，也可以将两者结合起来。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>为了改善CPI，存储器系统必须在每个时钟周期中给出多于一个的数据。方法是在每个时钟周期从单个存储器中给出多于32位数据，或为指令或数据分别设置存储器。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>（1）取指（fetch）：从存储器中取出指令，并将其放入指令流水线。 （2）译码（decode）：指令被译码，从寄存器堆中读取寄存器操作数。在寄存器堆中有3个操作数读端口，因此，大多数ARM指令能在一个周期内读取其操作数； （3）执行（execute）：将其中一个操作数移位，并在ALU中产生结果。如果指令是Load或Store指令，则在ALU中计算存储器的地址； （4）缓冲&#x2F;数据（buffer&#x2F;data）：如果需要则访问数据存储器；否则ALU只是简单地缓冲一个时钟周期； （5）回写（write-back）：将指令的结果回写到寄存器堆，包括任何从寄存器读出的数据。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>（1）互锁</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>一条指令的结果被用做下一条指令的操作数</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>跳转指令也会破坏流水线的行为，因为后续指令的取指步骤受到跳转目标计算的影响，因而必须推迟。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>流水线级数越多，问题就越严重</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>显然，只有当所有指令都依照相似的步骤执行时，流水线的效率达到最高。如果处理器的指令非常复杂，每一条指令的行为都与下一条指令不同，那么就很难用流水线实现。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>3级流水线的硬件主要组成部分：处理器状态的寄存器堆、桶形移位寄存器、ALU地址寄存器、数据输出寄存器、指令译码器和相关的控制逻辑。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>在ARM体系结构中可使用的存储管理策略包括以下几种： （1）多类型的存储单元（可以使用SDRAM、FLASH等）； （2）Caches； （3）写缓存； （4）虚拟内存地址。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>通过下面的几种方法实现对存储系统的管理： （1）使能Cache，加快存储器的访问速度； （2）启动虚拟地址到物理地址的映射； （3）使用“域管理”策略，对存储单元的访问进行保护； （4）对I&#x2F;O映射地址空间的访问加以限制。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>ARM系统完成I&#x2F;O功能的标准方法是使用存储器映射I&#x2F;O。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>如串行线控制器可能有以下5种寄存器： （1）发送数据寄存器（只写）：写入这个位置的数据被送往串行线。 （2）接收数据寄存器（只读）：保存从串行线送来的数据。 （3）控制寄存器（读&#x2F;写）：设置数据速率，管理RTS（请求发送）和其他类似信号。 （4）中断使能寄存器（读&#x2F;写）：控制中断的硬件事件。 （5）状态寄存器（读&#x2F;写）：指示读数据是否有效，写缓存是否满等。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>ARM编程中，通常将存储器的I&#x2F;O区域标记为非Cache区（Uncache Able），并绕过Cache访问。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>通常Cache与读敏感（Read-sensitive）器件相互排斥。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>JTAG仿真器也称为JTAG调试器，是通过ARM芯片的JTAG边界扫描口进行调试的设备。</p><p>第3章ARM编程模型</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>ARM处理器共有7种工作模式</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>除用户模式外的其他6种处理器模式称为特权模式（Privileged Modes）。在这些模式下，程序可以访问所有的系统资源，也可以任意地进行处理器模式切换。其中的5种又称为异常模式，分别为：FIQ(Fast Interrupt reQuest)；IRQ(Interrupt request)；管理（Supervisor）；中止（Abort）；未定义（Undefined）。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>它主要供操作系统任务使用。通常操作系统的任务需要访问所有的系统资源，同时该任务仍然使用用户模式的寄存器组，而不是异常模式下相应的寄存器组，这样可以保证当异常中断发生时任务状态不被破坏。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>ARM有37个32位长的寄存器： 1个用做PC（Program Counter）； 1个用做CPSR(Current Program Status Register)； 5个用做SPSR（Saved Program Status Registers）； 30个通用寄存器。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>一个异常发生时，总是从中断向量表开始跳转</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>：通用寄存器的恢复、状态寄存器的恢复和PC指针的恢复</p><p>第6章Bootload启动代码分析</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>启动代码是系统通电或者复位后运行的第一段代码，是进入C语言的main函数之前需要执行的那段汇编代码。它的作用是在用户程序运行之前对系统硬件及软件环境进行必要的初始化，并在最后使程序跳转到用户程序。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>Bootloader不是一段代码，它是一个具有引导装载功能的完整的程序</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>S3C2440A启动程序步骤： （1）屏蔽所有中断，关看门狗； （2）根据工作频率设置PLL寄存器； （3）初始化存储控制相关寄存器； （4）初始化各模式下的栈指针； （5）设置默认中断处理函数； （6）将数据段复制到RAM中，将零初始化数据段清零； （7）跳转到C语言Main入口函数中。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>堆栈是为中断或程序跳转服务的，当发生中断或程序跳转时，需要将当前处理器的状态及一些参数保持在堆栈中，当中断处理完毕后或程序执行完毕返回时，再将堆栈保存的现场数据进行恢复，以保证原来的程序正确运行。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>中断向量表一般位于启动代码的开始部分，它是用户程序与启动代码之间以及启动代码的各部分之间联系的纽带。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>当系统发生异常时，ARM处理器会通过硬件机制强制将PC指针指向中断向量表中对应的异常跳转函数存储的地址，然后程序会跳转到相应的中断服务程序去执行。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>Bootloader是在操作系统运行之前执行的一段小程序。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>几乎不可能为所有的嵌入式系统建立一个通用的Bootloader，不同的处理器架构都有不同的Bootloader。Bootloader不但依赖于CPU的体系结构，而且依赖于嵌入式系统板级设备的配置。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>Linux系统是通过Bootloader引导启动的。加电后，就要执行Bootloader来初始化系统。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>Bootloader的主要功能是引导操作系统启动，所以我们详细讨论一下各种启动方式的特点。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>但是使用这种启动方式之前，需要把Bootloader安装到板上的EPROM或者Flash中。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>这样Bootloader可以通过简单的TFTP协议远程下载内核映像到内存。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>大多数嵌入式系统上都使用Flash存储介质。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>Bootloader一般放在Flash的底端或者顶端，这要根据处理器的复位向量设置。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>首先，要使Bootloader的入口位于处理器加电执行第一条指令的位置。其次，分配参数区，这里可以作为Bootloader的参数保存区域。再次，内核映像区，Bootloader引导Linux内核，就是要从这个地方把内核映像解压到RAM中去，然后跳转到内核映像入口执行。最后，文件系统区，如果使用Ramdisk文件系统，则需要Bootloader把它解压到RAM中。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>Bootloader”只是引导设备并且执行主程序的固件；而“Monitor”还提供了更多的命令行接口，可以进行调试、读写内存、烧写Flash、配置环境变量等。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>U-Boot已经成为ARM平台事实上的标准Bootloader。</p>]]></content>
      
      
      <categories>
          
          <category> Book </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2023.3.7 牛客题库</title>
      <link href="/2023/03/07/Learn/%E7%89%9B%E5%AE%A2%E9%A2%98%E5%BA%93/2023.3.7%20%E7%89%9B%E5%AE%A2%E9%A2%98%E5%BA%93/"/>
      <url>/2023/03/07/Learn/%E7%89%9B%E5%AE%A2%E9%A2%98%E5%BA%93/2023.3.7%20%E7%89%9B%E5%AE%A2%E9%A2%98%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="2023-3-7"><a href="#2023-3-7" class="headerlink" title="2023.3.7"></a>2023.3.7</h1><h2 id="1、简单密码"><a href="#1、简单密码" class="headerlink" title="1、简单密码"></a>1、简单密码</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230307101720665.png"></p><h3 id="My-Code"><a href="#My-Code" class="headerlink" title="My Code"></a>My Code</h3><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123;    string str;    getline(cin,str);    for(int i&#x3D;0;i&lt;str.length();i++)&#123;        if(str[i] &gt;&#x3D; &#39;A&#39; &amp;&amp; str[i] &lt; &#39;Z&#39;)        &#123;            str[i] &#x3D; str[i] - (&#39;A&#39; - &#39;a&#39;) + 1;        &#125;        else if(str[i] &#x3D;&#x3D; &#39;Z&#39;)        &#123;            str[i] &#x3D; &#39;a&#39;;        &#125;        else if(str[i] &gt;&#x3D; &#39;a&#39; &amp;&amp; str[i]&lt;&#x3D;&#39;o&#39;)&#123;            str[i] &#x3D; ((str[i]-1)&#x2F;3 - 30) + &#39;0&#39;;        &#125;        else if(str[i] &gt;&#x3D; &#39;p&#39; &amp;&amp; str[i]&lt;&#x3D;&#39;s&#39;)&#123;            str[i] &#x3D; &#39;7&#39;;        &#125;        else if(str[i] &gt;&#x3D; &#39;t&#39; &amp;&amp; str[i]&lt;&#x3D;&#39;v&#39;)&#123;            str[i] &#x3D; &#39;8&#39;;        &#125;        else if(str[i] &gt;&#x3D; &#39;w&#39; &amp;&amp; str[i]&lt;&#x3D;&#39;z&#39;)&#123;            str[i] &#x3D; &#39;9&#39;;        &#125;    &#125;    cout &lt;&lt; str ;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2、汽水瓶"><a href="#2、汽水瓶" class="headerlink" title="2、汽水瓶"></a>2、汽水瓶</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230307101833632.png"></p><h3 id="My-Code-1"><a href="#My-Code-1" class="headerlink" title="My Code"></a>My Code</h3><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;using namespace std;int count &#x3D; 0;int bottleChange(int k)&#123;    while(k !&#x3D; 0)&#123;        if(k&lt;2)&#123;            k &#x3D; 0; &#x2F;&#x2F;如果小于两个空瓶子，换不了        &#125;        else if(k &#x3D;&#x3D; 2)&#123;            count ++;            k &#x3D; 0;&#x2F;&#x2F;如果有两个空瓶子，可以换一个        &#125;        else if( k &gt;&#x3D; 3)&#123;            count +&#x3D; k&#x2F;3;            k &#x3D; (k&#x2F;3)+(k%3);&#x2F;&#x2F;如果有三个以上的空瓶子，先换在加没换的，再循环        &#125;    &#125;    return 0;&#125;int main() &#123;    int n &#x3D; 0;    while(cin &gt;&gt; n) &#123;        if(n&#x3D;&#x3D;0)        &#123;            return 0;        &#125;        bottleChange(n);        cout &lt;&lt; count &lt;&lt;endl;        count &#x3D; 0;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Learn"><a href="#Learn" class="headerlink" title="Learn"></a>Learn</h3><p>直呼牛逼，空瓶两瓶换一瓶即没有空瓶，直接&#x2F;2…结束。</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;using namespace std;int main() &#123;    int n &#x3D; 0;    while(cin &gt;&gt; n) &#123;        if(n&#x3D;&#x3D;0)        &#123;            return 0;        &#125;        cout &lt;&lt; n&#x2F;2 &lt;&lt;endl;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3、删除字符串中出现次数最少的字符"><a href="#3、删除字符串中出现次数最少的字符" class="headerlink" title="3、删除字符串中出现次数最少的字符"></a>3、删除字符串中出现次数最少的字符</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230307105838622.png"></p><h3 id="My-Code-2"><a href="#My-Code-2" class="headerlink" title="My Code"></a>My Code</h3><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123;    string str;        while(cin&gt;&gt;str)    &#123;        int min&#x3D;20;        vector&lt;int&gt; Hash(26,0);        for(int i&#x3D;0;i&lt;str.size();i++)        &#123;            Hash[str[i]-&#39;a&#39;]++;        &#125;        for(int i&#x3D;0;i&lt;26;i++)        &#123;            if(min&gt;Hash[i]&amp;&amp;Hash[i]&gt;0)                min&#x3D;Hash[i];        &#125;        for(int i&#x3D;0;i&lt;str.size();i++)        &#123;            if(Hash[str[i]-&#39;a&#39;]!&#x3D;min)                cout&lt;&lt;str[i];        &#125;        cout&lt;&lt;endl;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4、合唱队"><a href="#4、合唱队" class="headerlink" title="4、合唱队"></a>4、合唱队</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230307112640954.png"></p><h3 id="My-Code-3"><a href="#My-Code-3" class="headerlink" title="My Code"></a>My Code</h3><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;using namespace std;int main() &#123;    int n;    cin &gt;&gt; n;    int str[n];    for(int i&#x3D;0;i&lt;n;i++)&#123;        cin &gt;&gt; str[i];    &#125;    int left[n];    int right[n];    int left_min &#x3D; 0;    int left_count &#x3D; 0;    int right_min &#x3D; 0;    int right_count &#x3D; 0;     int count &#x3D; n;    for(int i&#x3D;0,j&#x3D;n-i-1;i&lt;n;i++,j--)&#123;        left[i]&#x3D;1;        for(int ii&#x3D;0;ii&lt;i;ii++)&#123;            if(str[i]&gt;str[ii])            &#123;                left[i] &#x3D; max(left[i],left[ii]+1);            &#125;        &#125;        right[j]&#x3D;1;        for(int jj&#x3D;n-1;jj&gt;j;jj--)        &#123;            if(str[j]&gt;str[jj])&#123;                right[j] &#x3D; max(right[j],right[jj]+1);            &#125;        &#125;    &#125;    for(int i&#x3D;0;i&lt;n;i++)&#123;        count &#x3D; min(count,n-(left[i]+right[i]-1));    &#125;    cout &lt;&lt; count;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023.3.6 牛客题库</title>
      <link href="/2023/03/06/Learn/%E7%89%9B%E5%AE%A2%E9%A2%98%E5%BA%93/2023.3.6%20%E7%89%9B%E5%AE%A2%E9%A2%98%E5%BA%93/"/>
      <url>/2023/03/06/Learn/%E7%89%9B%E5%AE%A2%E9%A2%98%E5%BA%93/2023.3.6%20%E7%89%9B%E5%AE%A2%E9%A2%98%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="2023-3-6"><a href="#2023-3-6" class="headerlink" title="2023.3.6"></a>2023.3.6</h1><h2 id="动态规划dp背包问题"><a href="#动态规划dp背包问题" class="headerlink" title="动态规划dp背包问题"></a>动态规划dp背包问题</h2><p><a href="https://www.bilibili.com/video/BV1K4411X766/?spm_id_from=333.337.search-card.all.click&vd_source=dc5a7d7190173a321a8ae3df82a10d84">【动态规划】背包问题_哔哩哔哩_bilibili</a></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230306092044679.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230306092944982.png"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void Dynamic()&#123;for(int i&#x3D;1; i&lt;5; i++)&#123;for(int j&#x3D;1; j&lt;9; j++)&#123;if(weight[i]&gt;j)&#123;dp[i][j]&#x3D;dp[i-1][j]&#125;else&#123;dp[i][j]&#x3D;max&#123;dp[i-1][j],dp[i-1][j-weight[i]]+value[i]&#125;;&#125;&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1、购物单"><a href="#1、购物单" class="headerlink" title="1、购物单"></a>1、购物单</h2><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230306094453901.png"  /><p>这题有点类似于背包问题，不同之处在于他有附件。</p><h3 id="My-Code"><a href="#My-Code" class="headerlink" title="My Code"></a>My Code</h3><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;&#x2F;&#x2F;化为0&#x2F;1背包问题，主件和它的附件们可以看为一个物品using namespace std;int main()&#123;    int N;    int m;    while(cin&gt;&gt;N&gt;&gt;m)&#123;        int dp[61][3201]&#x3D;&#123;0&#125;;&#x2F;&#x2F;用来dp的矩阵        int weight[61][3]&#x3D;&#123;0&#125;;&#x2F;&#x2F;存放v        int value[61][3]&#x3D;&#123;0&#125;;&#x2F;&#x2F;存放v*p        int v,p,q;        N&#x2F;&#x3D;10;        for(int i&#x3D;1;i&lt;&#x3D;m;i++)&#123;&#x2F;&#x2F;输入处理            cin&gt;&gt;v&gt;&gt;p&gt;&gt;q;            p*&#x3D;v;&#x2F;&#x2F;重量，我们要使这个p总和最大            v&#x2F;&#x3D;10;&#x2F;&#x2F;价格            if(!q)&#123;&#x2F;&#x2F;这个东西是主件，q&#x3D;&#x3D;0                weight[i][q]&#x3D;v;&#x2F;&#x2F;重量就是价格v                value[i][q]&#x3D;p;&#x2F;&#x2F;价值就是p&#x3D;&#x3D;p*v            &#125;else if(!weight[q][1])&#123;&#x2F;&#x2F;这个东西是第q件物品的第一个附件                weight[q][1]&#x3D;v;                value[q][1]&#x3D;p;            &#125;else&#123;&#x2F;&#x2F;这个东西是第q件物品的第二个附件                weight[q][2]&#x3D;v;                value[q][2]&#x3D;p;            &#125;        &#125;        &#x2F;* dp[i][j]表示有j块钱买第i个商品的最大满意度 *&#x2F;        for(int i&#x3D;1;i&lt;&#x3D;m;i++)&#123;&#x2F;&#x2F;开始dp            for(int j&#x3D;1;j&lt;&#x3D;N;j++)&#123;                dp[i][j]&#x3D;dp[i-1][j];&#x2F;&#x2F;默认不装任何物品                if(weight[i][0]&lt;&#x3D;j)&#x2F;&#x2F;可以装入一个主件                    dp[i][j]&#x3D;max(dp[i][j],dp[i-1][j-weight[i][0]]+value[i][0]);                if(weight[i][0]+weight[i][1]&lt;&#x3D;j)&#x2F;&#x2F;可以装入一个主件和第一个附件                    dp[i][j]&#x3D;max(dp[i][j],dp[i-1][j-weight[i][0]-weight[i][1]]+value[i][0]+value[i][1]);                if(weight[i][0]+weight[i][2]&lt;&#x3D;j)&#x2F;&#x2F;可以装入一个主件和第二个附件                    dp[i][j]&#x3D;max(dp[i][j],dp[i-1][j-weight[i][0]-weight[i][2]]+value[i][0]+value[i][2]);                if(weight[i][0]+weight[i][1]+weight[i][2]&lt;&#x3D;j)&#x2F;&#x2F;可以装入一个主件和第一、二个附件                    dp[i][j]&#x3D;max(dp[i][j],dp[i-1][j-weight[i][0]-weight[i][1]-weight[i][2]]+value[i][0]+value[i][1]+value[i][2]);            &#125;        &#125;        cout&lt;&lt;dp[m][N]&lt;&lt;endl;    &#125;   return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Learn"><a href="#Learn" class="headerlink" title="Learn"></a>Learn</h3><p>见背包问题</p><h2 id="2、坐标移动"><a href="#2、坐标移动" class="headerlink" title="2、坐标移动"></a>2、坐标移动</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230306094952889.png"></p><h3 id="My-Code-1"><a href="#My-Code-1" class="headerlink" title="My Code"></a>My Code</h3><p>做的太复杂了。情况太多一一考虑，不好。</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;bool if_use(char a)&#123;    if(a &gt;&#x3D; &#39;0&#39; &amp;&amp; a&lt;&#x3D;&#39;9&#39;)&#123;        return true;    &#125;    return false;&#125;int main() &#123;    string str;    getline(cin,str);    int pos_1 &#x3D; 0;    int sum_x &#x3D; 0;    int sum_y &#x3D; 0;    int last_count &#x3D; 0;    if(str[str.length()-3 &#x3D;&#x3D; &#39;;&#39;])&#123;        last_count &#x3D; 2;    &#125;    else&#123;        last_count &#x3D; 3;    &#125;    for(int i&#x3D;0;i&lt;str.length()-last_count;i++)&#123;        if(str[i] &#x3D;&#x3D; &#39; &#39;)&#123;            pos_1++;        &#125;        if(str[pos_1+3] &#x3D;&#x3D; &#39;;&#39; &amp;&amp; if_use(str[pos_1+1])&#x3D;&#x3D;true &amp;&amp; if_use(str[pos_1+2])&#x3D;&#x3D;true &amp;&amp; pos_1 !&#x3D; -1)&#123;            if(str[pos_1] &#x3D;&#x3D; &#39;A&#39;)&#123;                sum_x -&#x3D; (str[pos_1+1]-&#39;0&#39;)*10 + str[pos_1+2]-&#39;0&#39;;            &#125;            else if(str[pos_1] &#x3D;&#x3D; &#39;D&#39;)&#123;                sum_x +&#x3D; (str[pos_1+1]-&#39;0&#39;)*10 + str[pos_1+2]-&#39;0&#39;;            &#125;            else if(str[pos_1] &#x3D;&#x3D; &#39;W&#39;)&#123;                sum_y +&#x3D; (str[pos_1+1]-&#39;0&#39;)*10 + str[pos_1+2]-&#39;0&#39;;            &#125;            else if(str[pos_1] &#x3D;&#x3D; &#39;S&#39;)&#123;                sum_y -&#x3D; (str[pos_1+1]-&#39;0&#39;)*10 + str[pos_1+2]-&#39;0&#39;;            &#125;            pos_1 &#x3D; -1;        &#125;        if(str[pos_1+2] &#x3D;&#x3D; &#39;;&#39; &amp;&amp; if_use(str[pos_1+1])&#x3D;&#x3D;true &amp;&amp; pos_1 !&#x3D; -1)&#123;            if(str[pos_1] &#x3D;&#x3D; &#39;A&#39;)&#123;                sum_x -&#x3D; str[pos_1+1]-&#39;0&#39;;            &#125;            else if(str[pos_1] &#x3D;&#x3D; &#39;D&#39;)&#123;                sum_x +&#x3D; str[pos_1+1]-&#39;0&#39;;            &#125;            else if(str[pos_1] &#x3D;&#x3D; &#39;W&#39;)&#123;                sum_y +&#x3D; str[pos_1+1]-&#39;0&#39;;            &#125;            else if(str[pos_1] &#x3D;&#x3D; &#39;S&#39;)&#123;                sum_y -&#x3D; str[pos_1+1]-&#39;0&#39;;            &#125;                        pos_1 &#x3D; -1;        &#125;        if(str[i] &#x3D;&#x3D; &#39;;&#39;)&#123;            pos_1 &#x3D; i+1;        &#125;    &#125;     cout &lt;&lt; sum_x &lt;&lt; &#39;,&#39; &lt;&lt; sum_y &lt;&lt; &#39; &#39;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Learn-1"><a href="#Learn-1" class="headerlink" title="Learn"></a>Learn</h3><p>没有看到很好的解。都挺复杂的。</p><h2 id="3、识别有效的IP地址和掩码并进行分类统计"><a href="#3、识别有效的IP地址和掩码并进行分类统计" class="headerlink" title="3、识别有效的IP地址和掩码并进行分类统计"></a>3、识别有效的IP地址和掩码并进行分类统计</h2><h2 id="4、简单错误记录"><a href="#4、简单错误记录" class="headerlink" title="4、简单错误记录"></a>4、简单错误记录</h2><h2 id="5、密码验证合格程序"><a href="#5、密码验证合格程序" class="headerlink" title="5、密码验证合格程序"></a>5、密码验证合格程序</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230306163151014.png" alt="image-20230306163151014"></p><h3 id="My-Code-2"><a href="#My-Code-2" class="headerlink" title="My Code"></a>My Code</h3><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123;    string str;      bool PasswordOk &#x3D; true;    bool PasswordNum &#x3D; true;    bool PasswordA &#x3D; true;    bool Passworda &#x3D; true;    bool Passwordelse &#x3D; true;    while(getline(cin,str))    &#123;        PasswordOk &#x3D; true;        PasswordNum &#x3D; false;        Passworda &#x3D; false;        PasswordA &#x3D; false;        Passwordelse &#x3D; false;        for(int i&#x3D;0;i&lt;str.length();i++)&#123;            if(str[i] &lt;&#x3D; &#39;9&#39; &amp;&amp; str[i] &gt;&#x3D; &#39;0&#39;)&#123;                PasswordNum &#x3D; true;            &#125;            else if(str[i] &gt;&#x3D; &#39;a&#39; &amp;&amp; str[i] &lt;&#x3D; &#39;z&#39;)&#123;                Passworda &#x3D; true;            &#125;            else if(str[i] &gt;&#x3D; &#39;A&#39; &amp;&amp; str[i] &lt;&#x3D; &#39;Z&#39;)&#123;                PasswordA &#x3D; true;            &#125;            else&#123;                Passwordelse &#x3D; true;            &#125;            for(int j&#x3D;i+3;j&lt;str.length()-3;j++)&#123;                if(str[i]&#x3D;&#x3D;str[j] &amp;&amp; str[i+1]&#x3D;&#x3D;str[j+1] &amp;&amp; str[i+2]&#x3D;&#x3D;str[j+2])                &#123;                    PasswordOk &#x3D; false;                &#125;            &#125;        &#125;        if(str.length() &lt;&#x3D;8)&#123;           PasswordOk &#x3D; false;        &#125;        if(PasswordA + Passworda + Passwordelse + PasswordNum &gt;&#x3D;3)&#123;        &#125;        else&#123;            PasswordOk &#x3D; false;        &#125;        if(PasswordOk &#x3D;&#x3D; true)&#123;            cout &lt;&lt; &quot;OK&quot; &lt;&lt;endl;        &#125;        else&#123;            cout &lt;&lt; &quot;NG&quot; &lt;&lt;endl;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Learn-2"><a href="#Learn-2" class="headerlink" title="Learn"></a>Learn</h3><p>好像都差不多。</p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023.3.5 Note</title>
      <link href="/2023/03/05/Note/2023.3.5%E8%AE%B0/"/>
      <url>/2023/03/05/Note/2023.3.5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>不得不铭记这一天。</p><p>今夕何夕，遇此良人。</p>]]></content>
      
      
      <categories>
          
          <category> Diary </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2023.3.5 牛客题库</title>
      <link href="/2023/03/05/Learn/%E7%89%9B%E5%AE%A2%E9%A2%98%E5%BA%93/2023.3.5%20%E7%89%9B%E5%AE%A2%E9%A2%98%E5%BA%93/"/>
      <url>/2023/03/05/Learn/%E7%89%9B%E5%AE%A2%E9%A2%98%E5%BA%93/2023.3.5%20%E7%89%9B%E5%AE%A2%E9%A2%98%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="2023-3-5"><a href="#2023-3-5" class="headerlink" title="2023.3.5"></a>2023.3.5</h1><h2 id="1、数字颠倒"><a href="#1、数字颠倒" class="headerlink" title="1、数字颠倒"></a>1、数字颠倒</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230305091143712.png"></p><h3 id="My-Code"><a href="#My-Code" class="headerlink" title="My Code"></a>My Code</h3><p>使用&#x2F;计算个数，使用%取最后一位数。特殊考虑0的情况！</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123;    int numIn &#x3D; 0;    cin &gt;&gt; numIn;    string str;    int count &#x3D; 0;    int numCount &#x3D; numIn;    if(numIn &#x3D;&#x3D; 0)&#123;        cout &lt;&lt; &#39;0&#39;;        retrun 0;    &#125;    while(numCount !&#x3D; 0)&#123;        numCount &#x2F;&#x3D; 10;        count++;    &#125;    for(int i&#x3D;0; i&lt;count; i++)&#123;        str[i] &#x3D; numIn%10 + &#39;0&#39;;        numIn &#x2F;&#x3D; 10;    &#125;    for(int j&#x3D;0; j&lt;count; j++)&#123;        cout &lt;&lt; str[j];    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Learn"><a href="#Learn" class="headerlink" title="Learn"></a>Learn</h3><p>取完数就输出，不要单独再跑一次，浪费资源</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;using namespace std;int main()&#123;    long num;    string str;    cin &gt;&gt; num;    if(num &#x3D;&#x3D; 0)&#123;        cout &lt;&lt; num;    &#125;    while(num &gt;&#x3D; 1)&#123;        int temp &#x3D; num % 10;        cout &lt;&lt; temp;        num &#x2F;&#x3D; 10;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>to_string( );可以把整形浮点等等转为字符</p><p>使用reverse_iterator反向迭代器适配器</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123;    int data;    string str;    cin&gt;&gt;data;    str &#x3D; to_string(data);    string::reverse_iterator it;    for(it&#x3D;str.rbegin();it!&#x3D;str.rend();it++)&#123;        cout&lt;&lt;*it;    &#125;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2、字符串反转"><a href="#2、字符串反转" class="headerlink" title="2、字符串反转"></a>2、字符串反转</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230305091126125.png"></p><h3 id="My-Code-1"><a href="#My-Code-1" class="headerlink" title="My Code"></a>My Code</h3><p>学习上一题解法。使用string反向迭代器。</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123;   string str;   getline(cin,str);   string::reverse_iterator it;   for(it&#x3D;str.rbegin();it!&#x3D;str.rend();it++)&#123;        cout &lt;&lt; *it;   &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Learn-1"><a href="#Learn-1" class="headerlink" title="Learn"></a>Learn</h3><p>None</p><h2 id="3、句子逆序"><a href="#3、句子逆序" class="headerlink" title="3、句子逆序"></a>3、句子逆序</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230305091418938.png"></p><h3 id="My-Code-2"><a href="#My-Code-2" class="headerlink" title="My Code"></a>My Code</h3><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123;    string str;    getline(cin,str);    int sp_pos &#x3D;str.length();    for(int i&#x3D;str.length(); i&gt;&#x3D;0; i--)&#123;        if(str[i]&#x3D;&#x3D;&#39; &#39;)&#123;            for(int j&#x3D;i+1; j&lt;sp_pos; j++)&#123;                cout &lt;&lt; str[j];            &#125;            cout&lt;&lt;&#39; &#39;;            sp_pos &#x3D; i;        &#125;        if(i &#x3D;&#x3D; 0)&#123;            for(int j&#x3D;i; j&lt;sp_pos; j++)&#123;                cout &lt;&lt; str[j];            &#125;        &#125;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Learn-2"><a href="#Learn-2" class="headerlink" title="Learn"></a>Learn</h3><p>没看到很好的解法</p><p>思路差不多，采用substr。</p><blockquote><p>语法<br>substr(size_type _Off &#x3D; 0,size_type _Count &#x3D; npos)<br>一种构造string的方法<br>形式 ： s.substr(pos, len)<br>返回值： string，包含s中从pos开始的len个字符的拷贝（pos的默认值是0，len的默认值是s.size() - pos，即不加参数会默认拷贝整个s）<br>异常 ：若pos的值超过了string的大小，则substr函数会抛出一个out_of_range异常；若pos+n的值超过了string的大小，则substr会调整n的值，只拷贝到string的末尾</p></blockquote><pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123;    string s;    while(getline(cin,s))&#123;        int right&#x3D;s.size(),left;        for(int i&#x3D;s.size()-1;i&gt;&#x3D;0;i--)&#123;            if(s[i]&#x3D;&#x3D;&#39; &#39;)&#123;                left&#x3D;i;                cout&lt;&lt;s.substr(left+1,right-left-1)&lt;&lt;&#39; &#39;;                right&#x3D;left;            &#125;        &#125;        cout&lt;&lt;s.substr(0,right);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4、字符串排序"><a href="#4、字符串排序" class="headerlink" title="4、字符串排序"></a>4、字符串排序</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230305101731054.png"></p><h3 id="My-Code-3"><a href="#My-Code-3" class="headerlink" title="My Code"></a>My Code</h3><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;bool cmp(string a,string b)&#123;    return a&lt;b;&#125;int main() &#123;    int num;    cin &gt;&gt; num;    string str[1001];    for(int i&#x3D;0; i&lt;num; i++)&#123;        cin &gt;&gt; str[i];    &#125;    sort(str,str+num,cmp);    for(int i&#x3D;0;i&lt;num;i++)&#123;        cout&lt;&lt;str[i]&lt;&lt;endl;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Learn-3"><a href="#Learn-3" class="headerlink" title="Learn"></a>Learn</h3><p>sort排序</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230305103543810.png"></p><h2 id="5、求int型正整数在内存中存储时1的个数"><a href="#5、求int型正整数在内存中存储时1的个数" class="headerlink" title="5、求int型正整数在内存中存储时1的个数"></a>5、求int型正整数在内存中存储时1的个数</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230305104458255.png"></p><h3 id="My-Code-4"><a href="#My-Code-4" class="headerlink" title="My Code"></a>My Code</h3><p>按位与最后一位，按位右移。</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;using namespace std;int main() &#123;    int num;    cin &gt;&gt; num;    int count &#x3D; 0;    while(num)&#123;        if((num&amp;1) &#x3D;&#x3D; 1)&#123;            count++;        &#125;        num&#x3D;num&gt;&gt;1;    &#125;    cout &lt;&lt; count;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Learn-4"><a href="#Learn-4" class="headerlink" title="Learn"></a>Learn</h3><p>采用%2取最后一位，直接累加。</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;#include &lt;cstdlib&gt;using namespace std;int main()&#123;int a;int count&#x3D;0;cin&gt;&gt;a;while(a&gt;0)&#123;count+&#x3D;a%2;a &#x3D; a&#x2F;2;&#125;cout&lt;&lt;count&lt;&lt;endl;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式C语言自我修养：从芯片、编译器到操作系统</title>
      <link href="/2023/03/04/Books/%E5%B5%8C%E5%85%A5%E5%BC%8FC%E8%AF%AD%E8%A8%80%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%EF%BC%9A%E4%BB%8E%E8%8A%AF%E7%89%87%E3%80%81%E7%BC%96%E8%AF%91%E5%99%A8%E5%88%B0%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/03/04/Books/%E5%B5%8C%E5%85%A5%E5%BC%8FC%E8%AF%AD%E8%A8%80%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%EF%BC%9A%E4%BB%8E%E8%8A%AF%E7%89%87%E3%80%81%E7%BC%96%E8%AF%91%E5%99%A8%E5%88%B0%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="嵌入式C语言自我修养：从芯片、编译器到操作系统"><a href="#嵌入式C语言自我修养：从芯片、编译器到操作系统" class="headerlink" title="嵌入式C语言自我修养：从芯片、编译器到操作系统"></a>嵌入式C语言自我修养：从芯片、编译器到操作系统</h1><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下，这本书讲了挺多东西。从计算机体系结构到ARM再到内存管理等等。</p><p>在微机原理里学了，但基本是80×86的东西。ARM架构大体上还是一致的，有相同也有不同。</p><p>初步了解了一些东西吧，没有看的很透，当阅读一本书来看的。</p><p>还是不错。</p><p>下一步在各方面上要多下一点功夫，逐个熟悉击破。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline">嵌入式C语言自我修养：从芯片、编译器到操作系统</p><p>王利涛编著</p><p>前言</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>C语言是一门高级语言。C语言有高级语言的各种语法和特性，我们使用C语言可以构建大型的软件工程。有人说，C语言小打小闹，上不了大台面，编写不了大型的项目，这个说法其实也是站不住脚的：很多大型的GNU开源项目，其实都是使用C语言开发的，如Lua脚本语言、SQLite、Nginx、UNIX等。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>C语言也是一门低级语言。通过指针和位运算，我们可以修改内存和寄存器，从而直接控制CPU和硬件电路的运行。正是由于这种低级特性，很多操作系统内核、驱动都选择使用C语言进行开发。尤其在嵌入式开发领域，C语言被广泛使用，C语言是嵌入式工程师必须熟练掌握，甚至需要精通的一门编程语言。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>如果你想以后从事嵌入式开发、Linux内核驱动开发等工作，那么对C语言的要求就更高了：你不仅要掌握C语言的基本语法、项目管理、软件工程，还要对硬件电路、CPU、操作系统、编译原理等底层机制有完整的了解，需要对C语言进行进一步的强化学习和编程训练。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>从事嵌入式开发工作，尤其是嵌入式Linux内核驱动开发工作，你要精通的不仅仅是C语言，最好还要掌握和C语言相关的一系列基础理论和调试技能。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>一开始连指针都不会用、不敢用，看内核驱动代码一头雾水，越看越没底、越看越没自信，到现在不再犯怵，有自信和能力看懂内核中的代码细节和系统框架，这种进步不是天上掉下来的，也不是一不小心跌入山洞，捡到武功秘籍练出来的，而是不断地学习和实践、反复迭代、不断完善自己的知识体系和技能树，才慢慢达到的。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>半导体基础、CPU工作原理、硬件电路、计算机系统结构。 ● ARM体系结构与汇编指令、汇编程序设计、ARM反汇编分析。 ● 程序的编译、链接、安装、运行和重定位分析。 ● 熟悉C语言标准、ARM、GNU编译器的特性和扩展语法。 ● C语言的模块化编程思想，学会使用模块化思想去分析复杂的系统。 ● C语言的面向对象编程（简称OOP）思想，学会使用OOP思想去分析Linux内核驱动。 ● 对指针的深刻理解，对复杂指针的声明和灵活应用。 ● 对内存堆栈管理、内存泄漏、栈溢出、段错误的深刻理解。 ● 多任务并发编程思想，CPU和操作系统基础理论。</p><p>1.1 代码编辑工具：Vim</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>使用IDE唯一的缺陷就是这些IDE安装文件往往很大，编译创建工程时生成的临时文件很多，略显笨重和臃肿，大量的封装虽然更易于上手，方便用户编程，但也掩盖了底层编译、调试的过程</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>Vim是一款纯命令行操作、功能可扩展、高度可定制的文本编辑工具。</p><p>2.1 一颗芯片是怎样诞生的</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>光刻机主要用来将你设计的电路图映射到晶圆上，通过光照将你设计的电路图形投影到光刻胶上，光刻胶中被电路遮挡的部分被保留，溶解的部分就是掺杂的窗口。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>光刻机的作用是根据电路版图制作掩膜版，开凿各种掺杂窗口，然后通过离子注入，生成PN结，进而构建千千万万个元器件</p><p>2.2 一颗CPU是怎么设计出来的</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>为了编程方便，我们给每个二进制指令起一个别名，使用一个助记符表示，这些助记符就是汇编语言，由助记符组成的指令序列就是汇编程序。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>集成电路（Integrated Circuit，IC）设计一般分为模拟IC设计、数字IC设计和数模混合IC设计。</p><p>2.3 计算机体系结构</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>冯·诺依曼架构和哈弗架构。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>采用冯·诺依曼架构的计算机，其特点是程序中的指令和数据混合存储，存储在同一块存储器上</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>冯·诺依曼架构的特点是结构简单，工程上容易实现，所以很多现代处理器都采用这种架构，如X86、ARM7、MIPS等。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>哈弗架构的特点是：指令和数据被分开独立存储，它们分别被存放到程序存储器和数据存储器。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>使用哈弗架构的处理器运行效率更高，但缺点是CPU实现会更加复杂。8051系列的单片机采用的就是哈弗架构。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>为了减少内存瓶颈带来的影响，CPU引入了Cache机制：指令Cache和数据Cache，用来缓存数据和指令，提升计算机的运行效率。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>SoC芯片内部的Cache层采用哈弗架构，集成了指令Cache和数据Cache。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>SoC芯片外部则采用冯·诺依曼架构，工程实现简单。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>现代的计算机集合了这两种架构的优点，因此我们很难界定一款芯片到底是冯·诺依曼架构还是哈弗架构，我们就姑且称之为混合架构吧。</p><p>2.4 CPU性能提升：Cache机制</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>Cache一般用在高性能处理器中，并不是所有的处理器都有Cache，如C51系列单片机、cortex-M0、cortex-M1、cortex-M2、cortex-M3、cortex-M4系列的ARM处理器都没有Cache。为什么这些处理器不使用Cache呢？主要原因有三个：一是这些处理器都是低功耗、低成本处理器，在CPU内集成Cache会增加芯片的面积和发热量，不仅功耗增加，芯片的成本也会增加不少。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>二是这些处理器本来工作频率就不高（从几十兆赫到几百兆赫不等），和RAM之间不存在带宽问题，有些处理器甚至不需要外接RAM，直接使用片内SRAM就可满足面向控制领域的软件开发需求。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>三是使用Cache无法保证实时性。当缓存未命中时，CPU从RAM中读取数据的时间是不确定的，这是嵌入式实时控制场景无法接受的。</p><p>2.5 CPU性能提升：流水线</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>一条指令的执行一般要经过取指令、翻译指令、执行指令3个基本流程。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>流水线的本质其实就是拿空间换时间</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>一个时钟周期的时间变短，CPU主频也就相应提升，影响时钟周期时间长短的一个关键的制约因素就是CPU内部每一个工序执行单元的耗费时间。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>流水线的本质是拿空间换时间，流水线越深，电路会越复杂，就需要更多的组合逻辑电路和寄存器，芯片面积也就越大，功耗也就随之上升了。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>执行的程序指令如果是顺序结构的，没有中断或跳转，流水线确实可以提高执行效率。但是当程序指令中存在跳转、分支结构时，下面预取的指令可能就要全部丢掉了，需要到跳转的地方重新取指令执行。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTYuMjUgOC44MzkxOUM2LjI0OTUxIDYuMzM5MTkgOC4yNzM4MSA1LjAyOTY2IDEwLjA1OTUgNS4wMjk2NkMxMS44NDUyIDUuMDI5NjYgMTMuNjMxIDYuNjk2MzMgMTMuNjMxIDguMTI0OUMxMy42MzEgOC40MzQ3MyAxMy42NzkzIDguOTYyMjkgMTMuNzc2MSA5LjcwNzU2QzEzLjgyNzQgMTAuMTAzIDEzLjU5MTUgMTAuNDc5MyAxMy4yMTMyIDEwLjYwNTRMMTIuNzk3NiAxMC43NDM5VjEwLjkwNjhDMTIuNzk3NiAxMi4wNjY5IDExLjk5OTUgMTMuMDc0NiAxMC44NzAyIDEzLjM0MDNMMTAuNzczOCAxMy4zNjNWMTQuNTUzNUM5LjA3NDEzIDE0LjY3MTMgNy44ODM2NSAxNC4yNzQ1IDcuMjAyMzggMTMuMzYzQzcuMjAyMzggMTIuMTEyIDYuODg0OTIgMTAuNjA0MSA2LjI1IDguODM5MTlaTTkuNTIzODEgMTIuMzczTDEwLjU4MzkgMTIuMTIzNUMxMS4xNDg2IDExLjk5MDcgMTEuNTQ3NiAxMS40ODY4IDExLjU0NzYgMTAuOTA2OFY5Ljg0M0wxMi40OTM3IDkuNTI3NjRDMTIuNDE4OCA4LjkwNzM2IDEyLjM4MSA4LjQ0NjcgMTIuMzgxIDguMTI0OUMxMi4zODEgNy4zODE5NCAxMS4xNDA5IDYuMjc5NjYgMTAuMDU5NSA2LjI3OTY2QzguNzI0OSA2LjI3OTY2IDcuNjAwOTMgNy4yMTUyNSA3LjUwNjQzIDguNjQyMzVDOC4wNTcxOSAxMC4yMTk1IDguMzcwMjYgMTEuNjIyMiA4LjQzODI1IDEyLjg1ODlDOC42OTU5NCAxMy4wNjk0IDkuMDUyMDIgMTMuMjEzNCA5LjUyMzgxIDEzLjI4MDhWMTIuMzczWk0xMS45NjI0IDE0LjI3MDZDMTEuOTkyNSAxNC42MTQ1IDEyLjI5NTcgMTQuODY4OSAxMi42Mzk1IDE0LjgzODhDMTMuOTAwNCAxNC43Mjg1IDE0LjgzMyAxMy42MTY5IDE0LjcyMjcgMTIuMzU2MUMxNC42OTI3IDEyLjAxMjIgMTQuMzg5NSAxMS43NTc5IDE0LjA0NTYgMTEuNzg3OUMxMy43MDE4IDExLjgxOCAxMy40NDc0IDEyLjEyMTIgMTMuNDc3NSAxMi40NjVDMTMuNTI3NiAxMy4wMzgxIDEzLjEwMzcgMTMuNTQzNCAxMi41MzA2IDEzLjU5MzVDMTIuMTg2NyAxMy42MjM2IDExLjkzMjMgMTMuOTI2OCAxMS45NjI0IDE0LjI3MDZaIiBmaWxsPSIjOTlBMEFBIi8+Cjwvc3ZnPgo=" alt="underline"></p><p>中断、跳转等会把预取的指令丢掉</p><p>执行的程序指令如果是顺序结构的，没有中断或跳转，流水线确实可以提高执行效率。但是当程序指令中存在跳转、分支结构时，下面预取的指令可能就要全部丢掉了，需要到跳转的地方重新取指令执行。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>流水线越深，一旦预取指令失败，浪费和损失就会越严重，因为流水线中预取的几十条指令可能都要丢弃掉，此时流水线就发生了停顿，无法按照预期继续执行，这种情况我们一般称为流水线冒险（hazard）。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>引起流水线冒险的原因有很多种，根据类型不同，我们一般分为3种。 ● 结构冒险：所需的硬件正在为前面的指令工作。 ● 数据冒险：当前指令需要前面指令的运算数据才能执行。 ● 控制冒险：需根据之前指令的执行结果决定下一步的行为。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>我们在编写有跳转分支的程序时，要记得把大概率执行的代码分支放在前面，这样可以明显提高代码的执行效率。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>第二种方法是几个执行部件同时访问内存，一次性读取所有的操作数，这种数据操作类型称为单指令多数据（Single Instruction Multiple Data，SIMD）</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>采用SuperScalar结构的处理器，完全依赖流水线硬件去动态识别可并行执行的指令，并分发到对应的执行单元执行，不仅大大增加了硬件电路的复杂性，而且也存在极限。学者和工业界一致认为，同时执行8条指令将是SuperScalar结构的极限。</p><p>2.6 多核CPU</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>在相同的工艺制程下，通过不断优化CPU架构，从Cache、流水线、乱序执行、SIMD、多发射、指令预测等方面不断更新迭代，就可以设计出比别家公司性能更高、功耗更低的处理器。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>多核处理器则可以让多个任务真正地同时执行。在单核处理器通过指令级并行性能提升空间有限的情况下，通过多核在任务级做到真正并行，可以进一步提升CPU的整体性能。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>四核以上的CPU可以采用Ring Bus结构（如图2-47右侧图）：将总线和交叉开关结合起来，连成一个环状，相邻的两个Core通信效率最高，远离的两个Core之间可以通过开关路由通信。Intel的八核处理器一般都是采用这种结构的。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>面向众核处理器领域，目前比较流行的一种片上互连技术叫作片上网络（Net On Chip，NoC）</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>ARM推出了big.LITTLE架构，也就是大小核架构：一个处理器内部集成的有高性能的Core，也有低功耗的Core</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>在多核处理器设计中，还有一种技术叫超线程技术（Hyper-Threading，HT）</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>超线程技术通过增加一定的控制逻辑电路，使用特殊指令可以将一个物理处理器当两个逻辑处理器使用，每个逻辑处理器都可以分配一个线程运行，从而最大限度地提升CPU的资源利用率</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>我们通过增加一些控制逻辑电路，保存各个线程的状态，共享ALU、Cache等共享资源，就可以在一个物理Core上实现两个逻辑Core，操作系统可以给每个逻辑Core都分配1个线程运行。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>超线程技术其实就是“欺骗”操作系统，让操作系统认为它有更多的Core，给它分配更多的任务执行，通过减少CPU的空闲时间来提高CPU的利用率。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>截至目前，市面上还没有发现使用超线程技术的ARM处理器</p><p>2.7 后摩尔时代：异构计算的崛起</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>异构计算就是在SoC芯片内部集成不同架构的Core，如DSP、GPU、NPU、TPU等不同架构的处理单元，各个核心协同运算，让整个SoC性能得到充分发挥。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>GPU在浮点运算、大数据处理、密码破解、人工智能等领域都是一把好手，比CPU更适合做大规模并行的数据运算。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>GPU也是一种SIMD结构，但和CPU不同的是，它没有复杂的控制单元和Cache，却集成了几千个，甚至上万个计算核心</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>FPGA不依赖冯·诺依曼体系结构，也不要编译器编译指令，它直接将硬件描述语言翻译为晶体管门电路的组合，实现特定的算法和功能</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>在同构处理器时代，我们一般使用主频来衡量一个处理器的性能。而到了异构处理器时代，随着人工智能、大数据、多媒体编解码对海量数据的计算需求，我们一般使用浮点运算能力来衡量一个处理器的性能。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>NPU（Neural Network Processing Unit，神经网络处理器）是面向人工智能领域，基于神经网络算法，进行硬件加速的处理器统称。</p><p>2.8 总线与地址</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>在一个计算机系统中，CPU内部的寄存器是没有地址的，可直接通过寄存器名访问。而内存和外部设备控制器中的寄存器都需要有一个地址，然后CPU才能通过地址去读写这些外部设备控制器的寄存器，控制外部设备的运行，或者根据地址去读写指定的内存单元。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>当CPU想访问其中一个存储单元时，可通过CPU管脚发出一组信号，经过译码器译码，选中与这个信号对应的存储单元，然后就可以直接读写这块内存了。CPU管脚发出的这组信号，也就是存储单元对应的编号，即地址。</p><p>2.9 指令集与微架构</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>指令集最终的实现就是微架构，就是CPU内部的各种译码和执行电路。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>指令集在CPU处理器内部的具体硬件电路的实现，我们就称为微架构</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTYuMjUgOC44MzkxOUM2LjI0OTUxIDYuMzM5MTkgOC4yNzM4MSA1LjAyOTY2IDEwLjA1OTUgNS4wMjk2NkMxMS44NDUyIDUuMDI5NjYgMTMuNjMxIDYuNjk2MzMgMTMuNjMxIDguMTI0OUMxMy42MzEgOC40MzQ3MyAxMy42NzkzIDguOTYyMjkgMTMuNzc2MSA5LjcwNzU2QzEzLjgyNzQgMTAuMTAzIDEzLjU5MTUgMTAuNDc5MyAxMy4yMTMyIDEwLjYwNTRMMTIuNzk3NiAxMC43NDM5VjEwLjkwNjhDMTIuNzk3NiAxMi4wNjY5IDExLjk5OTUgMTMuMDc0NiAxMC44NzAyIDEzLjM0MDNMMTAuNzczOCAxMy4zNjNWMTQuNTUzNUM5LjA3NDEzIDE0LjY3MTMgNy44ODM2NSAxNC4yNzQ1IDcuMjAyMzggMTMuMzYzQzcuMjAyMzggMTIuMTEyIDYuODg0OTIgMTAuNjA0MSA2LjI1IDguODM5MTlaTTkuNTIzODEgMTIuMzczTDEwLjU4MzkgMTIuMTIzNUMxMS4xNDg2IDExLjk5MDcgMTEuNTQ3NiAxMS40ODY4IDExLjU0NzYgMTAuOTA2OFY5Ljg0M0wxMi40OTM3IDkuNTI3NjRDMTIuNDE4OCA4LjkwNzM2IDEyLjM4MSA4LjQ0NjcgMTIuMzgxIDguMTI0OUMxMi4zODEgNy4zODE5NCAxMS4xNDA5IDYuMjc5NjYgMTAuMDU5NSA2LjI3OTY2QzguNzI0OSA2LjI3OTY2IDcuNjAwOTMgNy4yMTUyNSA3LjUwNjQzIDguNjQyMzVDOC4wNTcxOSAxMC4yMTk1IDguMzcwMjYgMTEuNjIyMiA4LjQzODI1IDEyLjg1ODlDOC42OTU5NCAxMy4wNjk0IDkuMDUyMDIgMTMuMjEzNCA5LjUyMzgxIDEzLjI4MDhWMTIuMzczWk0xMS45NjI0IDE0LjI3MDZDMTEuOTkyNSAxNC42MTQ1IDEyLjI5NTcgMTQuODY4OSAxMi42Mzk1IDE0LjgzODhDMTMuOTAwNCAxNC43Mjg1IDE0LjgzMyAxMy42MTY5IDE0LjcyMjcgMTIuMzU2MUMxNC42OTI3IDEyLjAxMjIgMTQuMzg5NSAxMS43NTc5IDE0LjA0NTYgMTEuNzg3OUMxMy43MDE4IDExLjgxOCAxMy40NDc0IDEyLjEyMTIgMTMuNDc3NSAxMi40NjVDMTMuNTI3NiAxMy4wMzgxIDEzLjEwMzcgMTMuNTQzNCAxMi41MzA2IDEzLjU5MzVDMTIuMTg2NyAxMy42MjM2IDExLjkzMjMgMTMuOTI2OCAxMS45NjI0IDE0LjI3MDZaIiBmaWxsPSIjOTlBMEFBIi8+Cjwvc3ZnPgo=" alt="underline"></p><p>微机原理考试填空这题…</p><p>一个指令通常由操作码和操作数组成</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>一个指令通常由操作码和操作数组成</p><p>3.1 ARM体系结构</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>计算机的指令集一般可分为4种：复杂指令集（CISC）、精简指令集（RISC）、显式并行指令集（EPIC）和超长指令字指令集（VLIW）。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>● Load&#x2F;Store架构，CPU不能直接处理内存中的数据，要先将内存中的数据Load（加载）到寄存器中才能操作，然后将处理结果Store（存储）到内存中</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>ARM有桶型移位寄存器，单周期内可以完成数据的各种移位操作。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>ARM处理器有多种工作模式，如表3-1所示。应用程序正常运行时，ARM处理器工作在用户模式（User mode），当程序运行出错或有中断发生时，ARM处理器就会切换到对应的特权工作模式。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>R0～R3通常用来传递函数参数，R4～R11用来保存程序运算的中间结果或函数的局部变量等，R12常用来作为函数调用过程中的临时寄存器。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>R13寄存器又称为堆栈指针寄存器（Stack Pointer，SP），用来维护和管理函数调用过程中的栈帧变化，R13总是指向当前正在运行的函数的栈帧，一般不能再用作其他用途</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>ARM三级流水线中，PC指针的值等于当前正在运行的指令地址+8</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>当前处理器状态寄存器（Current Processor State Register，CPSR）主要用来表征当前处理器的运行状态。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>SPSR用来保存当前工作模式下的处理器现场，即将CPSR寄存器的值保存到当前工作模式下的SPSR寄存器。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>为了快速响应中断，减少中断现场保护带来的时间开销，在FIQ工作模式下，ARM处理器有自己独享的R8～R12寄存器。</p><p>3.2 ARM汇编指令</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>ARM处理器属于冯·诺依曼架构，程序和数据都存储在同一存储器上，内存空间和I&#x2F;O空间统一编址，ARM处理器对程序指令、数据、I&#x2F;O空间中外设寄存器的访问都要通过Load&#x2F;Store指令来完成。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>LDR&#x2F;STR指令用来在寄存器和内存之间输送数据</p><p>3.3 ARM寻址方式</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>比较常见的寻址方式有寄存器寻址、立即寻址、寄存器偏移寻址、寄存器间接寻址、基址寻址、多寄存器寻址、相对寻址等。</p><p>3.4 ARM伪指令</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>常见的ARM伪指令主要有4个：ADR、ADRL、LDR、NOP</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>ARM属于RISC架构，不能对内存中的数据直接操作，ARM通常会使用LDR&#x2F;STR这对加载&#x2F;存储指令，先将内存中的数据加载到寄存器，然后才能对寄存器中的数据进行操作，最后把寄存器中的处理结果存储到内存中。LDR伪指令的主要用途是将一个32位的内存地址保存到寄存器中。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>RISC指令的特点是单周期指令，指令的长度一般都是固定的。在一个32位的系统中，一条指令通常是32位的，指令中包括操作码和操作数</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>为了与ARM指令集中的加载指令LDR区别开来，LDR伪指令中的操作数前一般会有一个等于号&#x3D;，用来表示该指令是个伪指令。</p><p>3.5 ARM汇编程序设计</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>ARM汇编程序是以段（section）为单位进行组织的</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>ARM汇编程序通过ENTRY这个伪操作来标识汇编程序的运行入口，使用伪操作END来标识汇编程序的结束。</p><p>4.1 从源程序到二进制文件</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>程序的编译过程，其实就是将我们编写的C源程序翻译成CPU能够识别和运行的二进制机器指令的过程</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>编译器在编译程序时会根据这些函数声明对我们的源程序进行语法检查：检查实参类型、返回结果类型和函数声明的类型是否匹配。</p><p>4.3 程序的编译</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>编译过程可以分为以下6步。 （1）词法分析。 （2）语法分析。 （3）语义分析。 （4）中间代码生成。 （5）汇编代码生成。 （6）目标代码生成。</p><p>5.3 栈的管理</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>在Linux环境下，栈的起始地址一般就是进程用户空间的最高地址，紧挨着内核空间，栈指针从高地址往低地址增长</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>Linux默认给每一个用户进程栈分配8MB大小的空间</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>● 尽量不要在函数内使用大数组，如果确实需要大块内存，则可以使用malloc申请动态内存。 ● 函数的嵌套层数不宜过深。 ● 递归的层数不宜太深。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>一个函数内定义的局部变量、传递的实参都是保存在栈中的。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>每个函数的栈空间都被称为栈帧（Frame Pointer，FP）。每一个栈帧都使用两个寄存器FP和SP来维护，FP指向栈帧的底部，SP指向栈帧的顶部。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>最后我们做个小结：形参只有在函数被调用时才会在函数栈帧内分配存储单元，用来接收传进来的实参值。函数运行结束后，形参单元随着栈帧的销毁而被释放</p><p>5.4 堆内存管理</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>无论使用malloc()、calloc()还是realloc()函数，申请的内存使用结束后，都要通过free()函数释放掉，将这块内存还给系统，否则就会造成内存泄漏。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>Keil编译器只是实现了一个简化版的C标准库，叫作MicroLIB库，如图5-17所示。该函数库实现了C标准规定的大部分函数功能，并针对嵌入式平台做了很多优化，使其体积更小，更适合存储资源有限的嵌入式系统</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>裸机环境下一片连续的堆内存空间，经过多次小块内存的申请和释放后，就会造成内存碎片化，在内存中留下越来越多、越来越碎片化的空闲小内存块。此时如果再去申请一片连续的大块内存就会失败。正是由于这个原因，在嵌入式裸机环境下，一般不建议使用堆内存，遇到使用大块内存的地方，可以使用一个全局数组代替。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>自己实现堆内存管理，如采用内存池，将堆内存空间划分为固定大小的内存块，自己管理与维护内存的申请和释放来避免内存碎片的产生。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>在uC&#x2F;OS的堆内存管理中，内存分区是操作系统管理堆内存的基本单元，每个内存分区使用一个结构体来表示，我们称之为内存控制块。</p><p>6.3 宏构造“利器”：语句表达式</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>typeof是GNU C新增的一个关键字，用来获取数据类型，我们不用传参进去，让typeof直接获取！</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>￼ 在这个宏定义中，我们使用了typeof关键字来自动获取宏的两个参数类型。比较难理解的是（void）（&amp;x&#x3D;&#x3D;&amp;y）；这句话，看起来很多余，仔细分析一下，你会发现这条语句很有意思。它的作用有两个：一是用来给用户提示一个警告，对于不同类型的指针比较，编译器会发出一个警告，提示两种数据的类型不同。 ￼ 二是两个数进行比较运算，运算的结果却没有用到，有些编译器可能会给出一个warning，加一个（void）后，就可以消除这个警告。</p><p>6.6 属性声明：section</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>一个可执行文件主要由代码段、数据段、BSS段构成。代码段主要存放编译生成的可执行指令代码，数据段和BSS段用来存放全局变量、未初始化的全局变量。</p><p>6.10 内联函数</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>那么为什么还要用static修饰呢？因为我们使用inline定义的内联函数，编译器不一定会内联展开，那么当一个工程中多个文件都包含这个内联函数的定义时，编译时就有可能报重定义错误。而使用static关键字修饰，则可以将这个函数的作用域限制在各自的文件内，避免重定义错误的发生。</p><p>第7章 数据存储与指针</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>如果我们不能真正地理解指针，在使用的时候就可能遇到各种问题，如内存错误、段错误、指针类型不匹配等。</p><p>7.1 数据类型与存储</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>位（bit）是最小的存储单位</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>8个bit组成一字节（Byte），字节是计算机最基本的存储单位，也是最小的寻址单元，计算机通常以字节为单位进行寻址</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>在一个32位的计算机系统中，通常4字节组成一个字（Word），字是软件开发者常用的存储单位。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>一个数据在内存中有2种存储方式：高地址存储高字节数据，低地址存储低字节数据；或者高地址存储低字节数据，而低地址则存储高字节数据</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>ARM、X86、DSP一般都采用小端模式，而IBM、Sun、PowerPC架构的处理器一般都采用大端模式。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>一般来讲，小端模式低地址存储低字节数据，比较符合人类的思维习惯；而大端模式则更适合计算机的处理习惯：不需要考虑地址和数据的对应关系，以字节为单位，把数据从左到右，按照由低到高的地址顺序直接读写即可。</p>]]></content>
      
      
      <categories>
          
          <category> Book </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2023.3.4 牛客题库</title>
      <link href="/2023/03/04/Learn/%E7%89%9B%E5%AE%A2%E9%A2%98%E5%BA%93/2023.3.4%20%E7%89%9B%E5%AE%A2%E9%A2%98%E5%BA%93/"/>
      <url>/2023/03/04/Learn/%E7%89%9B%E5%AE%A2%E9%A2%98%E5%BA%93/2023.3.4%20%E7%89%9B%E5%AE%A2%E9%A2%98%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="2023-3-4"><a href="#2023-3-4" class="headerlink" title="2023.3.4"></a>2023.3.4</h1><h2 id="1、质数因子"><a href="#1、质数因子" class="headerlink" title="1、质数因子"></a>1、质数因子</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230304084628356.png"></p><p>这题卡了好久，一直有一个案例不通过。原因是忽略了质数的质数是它本身！考虑的不够全面。</p><h3 id="My-Code"><a href="#My-Code" class="headerlink" title="My Code"></a>My Code</h3><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std;int main() &#123;    int numIn &#x3D; 0;    cin &gt;&gt; numIn;    for(int i&#x3D;2; i&lt;&#x3D;sqrt(numIn); i++)    &#123;        while(numIn % i &#x3D;&#x3D; 0)        &#123;            cout&lt;&lt; i &lt;&lt; &#39; &#39;;            numIn &#x3D; numIn&#x2F;i;        &#125;    &#125;    if(numIn!&#x3D;1)    &#123;        cout&lt;&lt; numIn &lt;&lt; &#39; &#39;;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Learn"><a href="#Learn" class="headerlink" title="Learn"></a>Learn</h3><p>想问题要全面！！先分析再写。</p><h2 id="2、取近似值"><a href="#2、取近似值" class="headerlink" title="2、取近似值"></a>2、取近似值</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230304091227629.png"></p><h3 id="My-Code-1"><a href="#My-Code-1" class="headerlink" title="My Code"></a>My Code</h3><p>思路：浮点转整型后面的小数会去掉，那如果浮点乘以10减去转型的乘以10，那么就得到了小数点后一位的数字。</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;using namespace std;int main() &#123;    double numIn &#x3D; 0;    long int num &#x3D; 0;    cin &gt;&gt; numIn;    long int numtemp &#x3D; (numIn*10);    numtemp -&#x3D; (int)numIn*10;    if(numtemp &lt; 5)&#123;        numtemp &#x3D; 0;    &#125;    else &#123;        numtemp &#x3D; 1;    &#125;    num &#x3D; (int)numIn + numtemp;    cout &lt;&lt; num;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Learn-1"><a href="#Learn-1" class="headerlink" title="Learn"></a>Learn</h3><p>乘以10%10就可以得到了….好像是。。晕</p><h2 id="3、合并表记录"><a href="#3、合并表记录" class="headerlink" title="3、合并表记录"></a>3、合并表记录</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230304100637701.png"></p><h3 id="My-Code-2"><a href="#My-Code-2" class="headerlink" title="My Code"></a>My Code</h3><p>代码出现问题如下：直接把index作为数组地址，那么就会在有限的内存内导致越界，index[11111111]太大了。此方法行不通。</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;#define Max 1111int main() &#123;    int numKey &#x3D; 0;    int index[Max]&#x3D;&#123;0&#125;;    cin &gt;&gt; numKey;    int numTemp[3]&#x3D;&#123;0&#125;;    for(int i&#x3D;0;i&lt;numKey;i++)    &#123;        cin&gt;&gt;numTemp[0];        cin&gt;&gt;numTemp[2];        index[(numTemp[0])] +&#x3D; numTemp[2];    &#125;    for(int i&#x3D;0;i&lt;Max;i++)    &#123;        if(index[i] !&#x3D; 0)        &#123;            cout &lt;&lt; i &lt;&lt; &#39; &#39; &lt;&lt; index[i]  &lt;&lt; endl;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Learn-2"><a href="#Learn-2" class="headerlink" title="Learn"></a>Learn</h3><p>使用图，如下。今天补一下STL的知识。</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;#include&lt;map&gt;using namespace std;int main()&#123;    int n;    map&lt;int,int&gt; m;    cin&gt;&gt;n;    for(int i&#x3D;0;i&lt;n;i++)    &#123;        pair&lt;int,int&gt; tmp;        cin&gt;&gt;tmp.first;        cin&gt;&gt;tmp.second;        if((m.find(tmp.first))!&#x3D;m.end())            m[tmp.first]+&#x3D;tmp.second;        else            m[tmp.first]&#x3D;tmp.second;    &#125;    for(auto it&#x3D;m.begin();it!&#x3D;m.end();it++)        cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;it-&gt;second&lt;&lt;endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4、提取不重复的整数"><a href="#4、提取不重复的整数" class="headerlink" title="4、提取不重复的整数"></a>4、提取不重复的整数</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230304111918681.png"></p><h3 id="My-Code-3"><a href="#My-Code-3" class="headerlink" title="My Code"></a>My Code</h3><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123;    string str;    getline(cin,str);    for(int i&#x3D;0;i&lt;str.length()&#x2F;2;i++)&#123;        char temp &#x3D; str[i];        str[i] &#x3D; str[str.length()-1-i];        str[str.length()-1-i] &#x3D; temp;    &#125;    for(int i&#x3D;0;i&lt;str.length();i++)&#123;        for(int j&#x3D;i+1;j&lt;str.length();j++)&#123;            if(str[i] &#x3D;&#x3D; str[j])            &#123;                str[j]&#x3D;-1;            &#125;        &#125;    &#125;    for(int i&#x3D;0;i&lt;str.length();i++)&#123;        if(str[i]!&#x3D;-1)        &#123;        cout &lt;&lt; str[i];        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Learn-3"><a href="#Learn-3" class="headerlink" title="Learn"></a>Learn</h3><p>提取最后一位，判断是否重复，不重复则打印，再提取倒数第二位。。。</p><p>判断重复方法即地址去判断，好用。</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;int main()&#123;    int n;    while(scanf(&quot;%d&quot;,&amp;n) !&#x3D; EOF)    &#123;        int a[15]&#x3D;&#123;0&#125;;        while(n !&#x3D; 0)        &#123;            int i&#x3D;n%10;            if(a[i] !&#x3D; 1)            &#123;                printf(&quot;%d&quot;,i);                a[i]&#x3D;1;            &#125;            n&#x3D;n&#x2F;10;        &#125;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5、字符个数统计"><a href="#5、字符个数统计" class="headerlink" title="5、字符个数统计"></a>5、字符个数统计</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230304112643904.png"></p><h3 id="My-Code-4"><a href="#My-Code-4" class="headerlink" title="My Code"></a>My Code</h3><p>思路：先将重复的字符置为’ ‘，再计算不是’ ‘的数量</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123;    string str;    getline(cin,str);    int Num &#x3D; 0;    for(int i&#x3D;0;i&lt;str.length();i++)    &#123;        for(int j&#x3D;i+1;j&lt;str.length();j++)        &#123;            if(str[i] &#x3D;&#x3D; str[j] &amp;&amp; str[i] !&#x3D; &#39; &#39;)            &#123;                str[j] &#x3D; &#39; &#39;;            &#125;        &#125;        if(str[i] !&#x3D; &#39; &#39;)&#123;            Num++;        &#125;    &#125;    cout &lt;&lt; Num;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Learn-4"><a href="#Learn-4" class="headerlink" title="Learn"></a>Learn</h3><p>采用set容器，使用set的insert去消除重复项，最后输出set的大小</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;int main()&#123;    char s;    set&lt;char&gt; a;    while(cin&gt;&gt;s)    &#123;        a.insert(s);    &#125;    cout&lt;&lt;a.size();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023.3.3 Note</title>
      <link href="/2023/03/03/Note/2023.3.3%E8%AE%B0/"/>
      <url>/2023/03/03/Note/2023.3.3%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>今天终于考完试了。</p><p>终结一下，好也不好。</p><p>好的是复习的还是可以的，知识点有去深入理解。</p><p>不好的是考的有点偏，填空到处挖，不会啊。</p><p>Very happy.</p><p>接下来就好好补一下代码能力和嵌入式知识吧。</p><p>加油。</p>]]></content>
      
      
      <categories>
          
          <category> Diary </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2023.3.3 牛客题库</title>
      <link href="/2023/03/03/Learn/%E7%89%9B%E5%AE%A2%E9%A2%98%E5%BA%93/2023.3.3%20%E7%89%9B%E5%AE%A2%E9%A2%98%E5%BA%93/"/>
      <url>/2023/03/03/Learn/%E7%89%9B%E5%AE%A2%E9%A2%98%E5%BA%93/2023.3.3%20%E7%89%9B%E5%AE%A2%E9%A2%98%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="2023-3-3"><a href="#2023-3-3" class="headerlink" title="2023.3.3"></a>2023.3.3</h1><h2 id="1、字符串最后一个单词的长度"><a href="#1、字符串最后一个单词的长度" class="headerlink" title="1、字符串最后一个单词的长度"></a>1、字符串最后一个单词的长度</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230303001832689.png"></p><h3 id="My-Code"><a href="#My-Code" class="headerlink" title="My Code"></a>My Code</h3><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string&gt;using namespace std;int main() &#123;    string str;    int len &#x3D; 0;    getline(cin,str);    for(int i&#x3D;0; i&lt;str.length(); i++)&#123;        if(str[i] &#x3D;&#x3D; &#39; &#39;)&#123;            len &#x3D; 0;                &#125;        else&#123;            len++;            &#125;    &#125;    cout &lt;&lt; len;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Learn"><a href="#Learn" class="headerlink" title="Learn"></a>Learn</h3><ol><li><p>包含头文件#include <string> </p><p>定义字符串String str;</p><p>字符串长度str.length()</p></li><li><p>int 后面一定要赋值！！</p></li><li><p>cin 遇空格或换行，会<strong>停止识别</strong>，如果你打算输入的字符串中带1个或多个空格，则采用getline把停止识别的符号设置为‘n’（即换行符），就能正确输入输出了。</p><p>例：getline(cin,str);</p></li><li><p>他人解法：</p></li></ol><ul><li>while(cin &gt;&gt; a)，使用一个istream的对象作为条件时，效果是检查流的状态。若流有效，则检测成功，返回true。当遇到文件结束符或者无效的输入（比如用一个字符来作为一个整型数的输入时），istream的对象状态会变为无效。</li><li>size和length这两个函数会返回 string 类型对象中的字符个数，且它们的执行效果相同。</li></ul><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;using namespace std;#include &lt;string&gt;int main() &#123;    string a;    int b;    while (cin &gt;&gt; a ) &#123; &#x2F;&#x2F; 注意 while 处理多个 case        b &#x3D; a.size();    &#125;    cout &lt;&lt; b &lt;&lt; endl;    return 0;&#125;&#x2F;&#x2F; 64 位输出请用 printf(&quot;%lld&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2、计算某字符"><a href="#2、计算某字符" class="headerlink" title="2、计算某字符"></a>2、计算某字符</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230303121425726.png"></p><h3 id="My-Code-1"><a href="#My-Code-1" class="headerlink" title="My Code"></a>My Code</h3><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123;    string str;    char str_check &#x3D; &#123;0&#125;;    int amount &#x3D; 0;    getline(cin,str);    cin &gt;&gt; str_check;    for(int i &#x3D; 0;i&lt; str.length();i++)&#123;        if(str[i] &#x3D;&#x3D; str_check )&#123;            amount++;        &#125;        else if(str_check &gt;&#x3D; 0x41 &amp;&amp; str_check &lt; 0x61)&#123;            if(str[i] &#x3D;&#x3D; str_check + 0x20 )&#123;                amount++;            &#125;        &#125;        else if(str_check &gt;&#x3D; 0x61 &amp;&amp; str_check &lt; 0x81)&#123;            if(str[i] &#x3D;&#x3D; str_check - 0x20 )&#123;                amount++;            &#125;        &#125;            &#125;    cout &lt;&lt; amount &lt;&lt;endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Learn-1"><a href="#Learn-1" class="headerlink" title="Learn"></a>Learn</h3><p>tolower(c);</p><p>函数说明：若参数 c 为大写字母则将该对应的小写字母返回。</p><p>返回值：返回转换后的小写字母，若不须转换则将参数c 值返回。</p><h2 id="3、明明的随机数"><a href="#3、明明的随机数" class="headerlink" title="3、明明的随机数"></a>3、明明的随机数</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230303195134209.png"></p><h3 id="My-Code-2"><a href="#My-Code-2" class="headerlink" title="My Code"></a>My Code</h3><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;using namespace std;int main() &#123;    int num &#x3D; 0;    int randnum[1000] &#x3D; &#123;0&#125;;    int nrepnum[500] &#x3D; &#123;0&#125;;    int k &#x3D; 0;    bool is_same;    cin &gt;&gt; num;    for(int i&#x3D;0; i &lt; num; i++)    &#123;        cin &gt;&gt; randnum[i];    &#125;    for(int j&#x3D;0; j &lt; num; j++)    &#123;        for(int a&#x3D;0; a &lt; k+1; a++)        &#123;            if(nrepnum[a] &#x3D;&#x3D; randnum[j])            &#123;                is_same &#x3D; true;                break;            &#125;        &#125;        if(is_same &#x3D;&#x3D; true)        &#123;            is_same &#x3D; false;        &#125;        else&#123;            nrepnum[k] &#x3D; randnum[j];            k++;        &#125;    &#125;    for(int g&#x3D;0; g&lt;k-1; g++)    &#123;        for(int h&#x3D;0 ; h&lt;k-1-g; h++)&#123;            if(nrepnum[h] &gt; nrepnum[h+1])&#123;                int temp &#x3D; 0;                temp &#x3D; nrepnum[h];                nrepnum[h] &#x3D; nrepnum[h+1];                nrepnum[h+1] &#x3D; temp;            &#125;        &#125;    &#125;    for(int b&#x3D;0; b&lt;k; b++)    &#123;        cout &lt;&lt; nrepnum[b] &lt;&lt;endl;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Learn-2"><a href="#Learn-2" class="headerlink" title="Learn"></a>Learn</h3><p>有点牛逼…</p><p>思路：取最大数组，循环遍历所有值</p><p><strong>将该值放入数组对应该位，使该位为true，</strong>这个操作直接删去了重复值，而且排好了序！！</p><p>循环遍历数组，判断数组对应位是否为true，是则输出。</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;using namespace std;int main() &#123;    int N, n;    while (cin &gt;&gt; N) &#123;        int a[1001] &#x3D; &#123; 0 &#125;;        while (N--) &#123;            cin &gt;&gt; n;            a[n] &#x3D; 1;        &#125;        for (int i &#x3D; 0; i &lt; 1001; i++)            if (a[i])                cout &lt;&lt; i &lt;&lt; endl;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4、字符串分隔"><a href="#4、字符串分隔" class="headerlink" title="4、字符串分隔"></a>4、字符串分隔</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230303195111093.png"></p><h3 id="My-Code-3"><a href="#My-Code-3" class="headerlink" title="My Code"></a>My Code</h3><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123;    string str;    getline(cin,str);    int j&#x3D;0;    for(int i&#x3D;0; i&lt;str.length(); i++)&#123;        cout &lt;&lt; str[i];        if( (i+1) %8 &#x3D;&#x3D; 0)        &#123;            cout &lt;&lt; endl;        &#125;    &#125;     j &#x3D; 8-str.length()%8;     if(j !&#x3D; 8)     &#123;        for(int k&#x3D;0; k&lt;j; k++)&#123;                cout &lt;&lt; &#39;0&#39;;        &#125;     &#125;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Learn-3"><a href="#Learn-3" class="headerlink" title="Learn"></a>Learn</h3><p>1.获取子字符串substr()</p><ul><li><p>函数原型: <code>string substr(size_t pos = 0, size_t len = npos) const;</code></p></li><li><p>功能: 从子字符串中获取想要的子字符串</p></li><li><p>参数：</p></li><li><ul><li>pos: 想要获取的子字符串的第一个字符的位置，如果pos等于字符串长度，则该函数返回一个空字符串，如果等于字符串长度，则该函数返回一个空的字符串，如果该长度大于字符串长度，则抛出一个out_of_range。 注：第一个字符的下标从0开始。</li><li>len： 子字符串中要包含的字符数, string::npos的值表示知道字符串末尾的所有字符。</li></ul></li><li><p>返回值：带有对象子字符串的字符串对象。</p></li></ul><p>2.insert()</p><p>basic_string&amp; insert (size_type pos, const basic_string&amp; str);</p><p>在原串下标为pos的字符前插入字符串str</p><p>basic_string&amp; insert (size_type pos, const basic_string&amp; str, size_type pos1, size_type n);</p><p>str从下标为pos1开始数的n个字符插在原串下标为pos的字符前</p><p>basic_string&amp; insert (size_type pos, size_type n, char c);</p><p>在原串下标为pos的字符前插入n个字符c</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;int main() &#123;    string s;    getline(cin, s);    while (true) &#123;        int len &#x3D; s.size();        if (len &lt;&#x3D; 8) &#123;            s.insert(s.end(), 8-len, &#39;0&#39;);            cout &lt;&lt; s &lt;&lt; endl;            if (!getline(cin, s)) break;        &#125;        else &#123;            cout &lt;&lt; s.substr(0, 8) &lt;&lt; endl;            s &#x3D; s.substr(8, len-8);        &#125;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5、进制转换"><a href="#5、进制转换" class="headerlink" title="5、进制转换"></a>5、进制转换</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230303195016718.png"></p><h3 id="My-Code-4"><a href="#My-Code-4" class="headerlink" title="My Code"></a>My Code</h3><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;math.h&gt;using namespace std;int main() &#123;    string hex;    long int dec &#x3D; 0;    getline(cin,hex);    int length &#x3D; hex.length();    for(int i&#x3D;0; i&lt;length-2 ; i++)&#123;        if(hex[length-i-1] &gt;&#x3D; &#39;A&#39; &amp;&amp; hex[length-i-1] &lt;&#x3D; &#39;F&#39;)        &#123;            hex[length-i-1] &#x3D; hex[length-i-1] - 55;        &#125;        else        &#123;            hex[length-i-1] &#x3D; hex[length-i-1] - 48;        &#125;        dec +&#x3D; pow(16,i)*hex[length-i-1];    &#125;    cout &lt;&lt; dec &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Learn-4"><a href="#Learn-4" class="headerlink" title="Learn"></a>Learn</h3><p>1、ASCII码</p><p>没有记住数字0的ASCII，注意数字0为0x30H，A为0x41H，a为0x61H</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230303195002392.png"></p><p>2、指数函数pow(x,y);</p><p>3、cin&gt;&gt;hex&gt;&gt;a; &#x2F;&#x2F;a为int</p><p>怎么看到这个答案我像个…笨….</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;using namespace std;int main()&#123;    int a;    while(cin&gt;&gt;hex&gt;&gt;a)&#123;    cout&lt;&lt;a&lt;&lt;endl;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023.2.14 Note</title>
      <link href="/2023/02/14/Note/2023.2.14%E8%AE%B0/"/>
      <url>/2023/02/14/Note/2023.2.14%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>准备开始为期两周的期末考。</p><p>提前一周准备。</p><p>考完再更！</p>]]></content>
      
      
      <categories>
          
          <category> Diary </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>QT_Chaprter1</title>
      <link href="/2023/02/12/Learn/QT/QT_Chaprter1/"/>
      <url>/2023/02/12/Learn/QT/QT_Chaprter1/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="QT-Chaprter1"><a href="#QT-Chaprter1" class="headerlink" title="QT_Chaprter1"></a>QT_Chaprter1</h1><h2 id="1、创建第一个QT程序"><a href="#1、创建第一个QT程序" class="headerlink" title="1、创建第一个QT程序"></a>1、创建第一个QT程序</h2><p>int main(int argc, char *argv[]){}</p><p>&#x2F;&#x2F;argc命令行变量的数量 argv命令行变量的数组</p><p>return a.exec();</p><p>&#x2F;&#x2F;让应用程序对象进入消息循环，点右上角×退出</p><h2 id="2、命名规范以及快捷键"><a href="#2、命名规范以及快捷键" class="headerlink" title="2、命名规范以及快捷键"></a>2、命名规范以及快捷键</h2><p>命名规范：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230212093911498.png"></p><p>快捷键：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230212093851189.png"></p><h2 id="3、QPushButton创建"><a href="#3、QPushButton创建" class="headerlink" title="3、QPushButton创建"></a>3、QPushButton创建</h2><pre class="line-numbers language-none"><code class="language-none">#include &lt;QPushButton&gt;myWidget::myWidget(QWidget *parent)    : QWidget(parent)    , ui(new Ui::myWidget)&#123;    ui-&gt;setupUi(this);    QPushButton *btn &#x3D; new QPushButton; &#x2F;&#x2F;创建一个按钮    btn-&gt;show(); &#x2F;&#x2F;show以顶层方式弹出窗口控件    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230212094311813.png" style="zoom:50%;" /><pre class="line-numbers language-none"><code class="language-none">myWidget::myWidget(QWidget *parent)    : QWidget(parent)    , ui(new Ui::myWidget)&#123;    ui-&gt;setupUi(this);    QPushButton *btn &#x3D; new QPushButton;    btn-&gt;setParent(this); &#x2F;&#x2F;让btn对象依赖在myWidget窗口中    btn-&gt;setText(&quot;第一个按钮&quot;); &#x2F;&#x2F;显示文本&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230212094428218.png" style="zoom:50%;" /><pre class="line-numbers language-none"><code class="language-none">QPushButton *btn2 &#x3D; new QPushButton(&quot;第二个按钮&quot;, this); &#x2F;&#x2F;创建第二个按钮btn2-&gt;move(100,100); &#x2F;&#x2F;移动btn2按钮resize(600,400); &#x2F;&#x2F;重置窗口大小setFixedSize(600,400); &#x2F;&#x2F;设置固定界面大小setWindowTitle(&quot;第一个窗口&quot;); &#x2F;&#x2F;设置窗口标题<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4、对象树"><a href="#4、对象树" class="headerlink" title="4、对象树"></a>4、对象树</h2><p>构造从父到子，析构从子到父。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230212100243605.png"></p><h2 id="5、QT坐标系"><a href="#5、QT坐标系" class="headerlink" title="5、QT坐标系"></a>5、QT坐标系</h2><p>以左上角为原点(0, 0)，X向右增加，Y向下增加</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230212101645676.png"></p><h2 id="6、信号和槽"><a href="#6、信号和槽" class="headerlink" title="6、信号和槽"></a>6、信号和槽</h2><p>Connect( 信号的发送者， 发送的具体信号， 信号的接受者， 信号的处理(槽) )</p><p>信号槽的优点：松散耦合，信号发送端和接受端本身是没有关联的，通过connect连接将两端耦合在一起。</p><pre class="line-numbers language-none"><code class="language-none">connect(btn2, &amp;QPushButton::clicked, this, &amp;QWidget::close);&#x2F;&#x2F;参数1 信号的发送者， 参数2 发送的信号， 参数3 信号的接受者， 参数4 处理的槽函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="7、自定义信号和槽"><a href="#7、自定义信号和槽" class="headerlink" title="7、自定义信号和槽"></a>7、自定义信号和槽</h2><p>前情：下课后，老师会触发一个信号，饿了，学生响应信号，请客吃饭。</p><pre class="line-numbers language-none"><code class="language-none">signals:    &#x2F;&#x2F;自定义信号写到signals下    &#x2F;&#x2F;返回值为void，只需要声明，不需要实现    &#x2F;&#x2F;可以有参数，可以重载    void hungry();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;slots 槽函数&#x2F;&#x2F;返回值void，需要声明，也需要实现&#x2F;&#x2F;可以有参数，可以重载void treat();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>emit 自定义信号 &#x2F;&#x2F;触发信号</p><h2 id="8、自定义信号和槽发生重载的解决"><a href="#8、自定义信号和槽发生重载的解决" class="headerlink" title="8、自定义信号和槽发生重载的解决"></a>8、自定义信号和槽发生重载的解决</h2><p>需要利用函数指针，明确指向函数的地址</p><pre class="line-numbers language-none"><code class="language-none">void(Teacher:: *teacherSingal)(QString) &#x3D; &amp;Teacher::hungry;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>QString 转成 char *</p><p>.ToUtf8() 转为 QByteArray</p><p>.Data() 转为 Char*</p><pre class="line-numbers language-none"><code class="language-none">void hungry(QString foodName);qDebug &lt;&lt; &quot;请老师吃饭，老师要吃：&quot; &lt;&lt;foodName.toUtf8().data();&#x2F;&#x2F;去掉引号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="9、Lambda表达式"><a href="#9、Lambda表达式" class="headerlink" title="9、Lambda表达式"></a>9、Lambda表达式</h2><p>C++ 11 新特性，用于定义并创建匿名的函数对象，以简化编程工作。</p><p>[]标识一个Lambda的开始，这部分必须存在，不能省略。</p><p>&#x3D; 值传递</p><p>mutalbe 修改拷贝，不修改本体</p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>80×86微处理器</title>
      <link href="/2023/02/11/Learn/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/3%E3%80%8180%C3%9786%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8/"/>
      <url>/2023/02/11/Learn/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/3%E3%80%8180%C3%9786%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="80×86微处理器"><a href="#80×86微处理器" class="headerlink" title="80×86微处理器"></a>80×86微处理器</h1><h2 id="8086-的存储器组织"><a href="#8086-的存储器组织" class="headerlink" title="8086 的存储器组织"></a>8086 的存储器组织</h2><h3 id="寻址空间和数据存储格式"><a href="#寻址空间和数据存储格式" class="headerlink" title="寻址空间和数据存储格式"></a>寻址空间和数据存储格式</h3><p>寻址空间是指<strong>存储器地址允许的最大范围</strong></p><p>当存储器按字节编址时，若地址总线为<strong>n</strong>位，CPU寻址范围位<strong>2^n^</strong>字节。</p><p>8086地址总线20位，寻址能力为1MB.</p><h3 id="存储器的分段结构和物理地址的形成"><a href="#存储器的分段结构和物理地址的形成" class="headerlink" title="存储器的分段结构和物理地址的形成"></a>存储器的分段结构和物理地址的形成</h3><p>任何一个内存单元的地址都可以用段地址和偏移地址来表示，其格式为：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230211140537957.png"></p><p>根据逻辑地址，可以求出它对应得物理地址：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230211140907181.png"></p><p>一般可将存储器划分为程序段、数据段、堆栈段和附加段。</p><p>程序段中存储程序得指令代码；</p><p>数据段和附加段中存储数据、中间结果和最后结果；</p><p>堆栈段存储压入堆栈的数据或状态信息。</p><h2 id="8086-微处理器内部结构"><a href="#8086-微处理器内部结构" class="headerlink" title="8086 微处理器内部结构"></a>8086 微处理器内部结构</h2><h3 id="8086-CPU的内部结构"><a href="#8086-CPU的内部结构" class="headerlink" title="8086 CPU的内部结构"></a>8086 CPU的内部结构</h3><p>CPU的任务是执行存放在存储器中的指令序列，即<strong>取指令</strong>和<strong>执行指令</strong></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230211152711341.png" alt="8086 CPU 逻辑结构框图"></p><h3 id="8086-CPU的寄存器结构"><a href="#8086-CPU的寄存器结构" class="headerlink" title="8086 CPU的寄存器结构"></a>8086 CPU的寄存器结构</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230211152904332.png" alt="8086 CPU内部寄存器"></p><p>标志寄存器</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230211154028224.png"></p><h2 id="8086-总线的工作周期"><a href="#8086-总线的工作周期" class="headerlink" title="8086 总线的工作周期"></a>8086 总线的工作周期</h2><p>一个时钟脉冲时间称为一个时钟周期。</p><p>CPU通过总线对存储器或外设I&#x2F;O接口进行一次访问所需要的时间称为总线周期。</p><p><strong>CPU执行一条指令完整过程：</strong></p><p>CPU执行某一个程序之前，先要把编译后的目标程序放到主存储器的某个区域。在启动执行后，CPU就发出读指令的命令，根据代码段寄存器CS和指令指针IP生成20位物理地址并将其输出到地址总线上，在存储器中读取相应的存储单元，把它送至CPU的指令寄存器中；CPU对读出指令经过译码器分析之后，发出一系列控制信号，执行指令规定的全部操作，控制各种信息在系统各部件之间传送。每条指令的执行由取指令、译码和执行等操作组成。</p><h2 id="8086-微处理器的时序"><a href="#8086-微处理器的时序" class="headerlink" title="8086 微处理器的时序"></a>8086 微处理器的时序</h2><h3 id="系统的复位与启动"><a href="#系统的复位与启动" class="headerlink" title="系统的复位与启动"></a>系统的复位与启动</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230211160442426.png" alt="image-20230211160442426"></p><p>由表可以看出，CPU复位时，代码段寄存器CS被初始化为FFFFH，而指令指针寄存器被初始化为0000H。因此，当CPU复位完成，再重新启动时，就会从主存地址为FFFF0H的位置开始执行指令。</p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微机原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>交流交流变流电路</title>
      <link href="/2023/02/10/Learn/%E7%94%B5%E5%8A%9B%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/4%E3%80%81%E4%BA%A4%E6%B5%81%E4%BA%A4%E6%B5%81%E5%8F%98%E6%B5%81%E7%94%B5%E8%B7%AF/"/>
      <url>/2023/02/10/Learn/%E7%94%B5%E5%8A%9B%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/4%E3%80%81%E4%BA%A4%E6%B5%81%E4%BA%A4%E6%B5%81%E5%8F%98%E6%B5%81%E7%94%B5%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="交流交流变流电路"><a href="#交流交流变流电路" class="headerlink" title="交流交流变流电路"></a>交流交流变流电路</h1><h2 id="交流调压电路"><a href="#交流调压电路" class="headerlink" title="交流调压电路"></a>交流调压电路</h2><h3 id="单相交流调压电路"><a href="#单相交流调压电路" class="headerlink" title="单相交流调压电路"></a>单相交流调压电路</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230210115607498.png"></p><h3 id="三相交流调压电路"><a href="#三相交流调压电路" class="headerlink" title="三相交流调压电路"></a>三相交流调压电路</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230210140146631.png"></p><h2 id="其他交流电力控制电路"><a href="#其他交流电力控制电路" class="headerlink" title="其他交流电力控制电路"></a>其他交流电力控制电路</h2><h3 id="交流调功电路"><a href="#交流调功电路" class="headerlink" title="交流调功电路"></a>交流调功电路</h3><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230210141904728.png" style="zoom:50%;" /><p><strong>工作原理：</strong></p><p>和交流调压电路的电路形式完全相同，只是控制方式不同。</p><p>通过改变接通周波数与断开周波数的比值来调节负载所消耗的平均功率。</p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电力电子技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>直流直流变流电路</title>
      <link href="/2023/02/10/Learn/%E7%94%B5%E5%8A%9B%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/3%E3%80%81%E7%9B%B4%E6%B5%81%E7%9B%B4%E6%B5%81%E5%8F%98%E6%B5%81%E7%94%B5%E8%B7%AF/"/>
      <url>/2023/02/10/Learn/%E7%94%B5%E5%8A%9B%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/3%E3%80%81%E7%9B%B4%E6%B5%81%E7%9B%B4%E6%B5%81%E5%8F%98%E6%B5%81%E7%94%B5%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="直流直流变流电路"><a href="#直流直流变流电路" class="headerlink" title="直流直流变流电路"></a>直流直流变流电路</h1><p>也称斩波电路。</p><p>功能是将直流电变为另一固定电压或可调电压的直流电。</p><h2 id="基本斩波电路"><a href="#基本斩波电路" class="headerlink" title="基本斩波电路"></a>基本斩波电路</h2><h3 id="降压斩波电路"><a href="#降压斩波电路" class="headerlink" title="降压斩波电路"></a>降压斩波电路</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230210102425262.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230210102539872.png" alt="基本数量关系"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230210104957414.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230210105024103.png"></p><h3 id="升压斩波电路"><a href="#升压斩波电路" class="headerlink" title="升压斩波电路"></a>升压斩波电路</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230210105558105.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230210105637163.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230210105826271.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230210105937868.png"></p><h3 id="升降压斩波电路和Cuk斩波电路"><a href="#升降压斩波电路和Cuk斩波电路" class="headerlink" title="升降压斩波电路和Cuk斩波电路"></a>升降压斩波电路和Cuk斩波电路</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230210110020982.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230210110645255.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230210111148519.png" alt="Cuk斩波电路及其等效电路"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230210111221459.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230210111234174.png"></p><h3 id="Sepic斩波电路和Zeta斩波电路"><a href="#Sepic斩波电路和Zeta斩波电路" class="headerlink" title="Sepic斩波电路和Zeta斩波电路"></a>Sepic斩波电路和Zeta斩波电路</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230210111337606.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230210111348429.png"></p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电力电子技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微型计算机系统基础</title>
      <link href="/2023/02/10/Learn/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/2%E3%80%81%E5%BE%AE%E5%9E%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/02/10/Learn/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/2%E3%80%81%E5%BE%AE%E5%9E%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="微型计算机系统基础"><a href="#微型计算机系统基础" class="headerlink" title="微型计算机系统基础"></a>微型计算机系统基础</h1><h2 id="微型计算机系统结构"><a href="#微型计算机系统结构" class="headerlink" title="微型计算机系统结构"></a>微型计算机系统结构</h2><h3 id="微处理器与微型计算机"><a href="#微处理器与微型计算机" class="headerlink" title="微处理器与微型计算机"></a>微处理器与微型计算机</h3><p><strong>微处理器</strong>是将运算器和控制器集成在一起的中央处理器部件。</p><p><strong>微型计算机</strong>是指以微处理器为核心，配上内存储器、输入&#x2F;输出接口电路及系统总线所组成的计算机。</p><p><strong>微型计算机系统</strong>是指以微型计算机为中心，配以相应的外围设备、电源、辅助电路，以及控制微型计算机工作的系统软件所构成的计算机系统。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230210091824141.png"></p><h3 id="微处理器中主要的寄存器"><a href="#微处理器中主要的寄存器" class="headerlink" title="微处理器中主要的寄存器"></a>微处理器中主要的寄存器</h3><p><strong>指令寄存器</strong>用来保存当前正在执行的一条指令。</p><p><strong>程序计数器</strong>指出下一条将要执行的指令在主存储器中的地址。</p><p><strong>地址寄存器</strong>用来保存CPU当前所访问的主存单元的地址。</p><h3 id="微型计算机中的存储器与地址分配"><a href="#微型计算机中的存储器与地址分配" class="headerlink" title="微型计算机中的存储器与地址分配"></a>微型计算机中的存储器与地址分配</h3><p>对I&#x2F;O端口的编址通常由两种方法：一种是I&#x2F;O端口和内存储器统一编址；另一种是I&#x2F;O端口单独编址。</p><h2 id="输入-x2F-输出系统"><a href="#输入-x2F-输出系统" class="headerlink" title="输入&#x2F;输出系统"></a>输入&#x2F;输出系统</h2><p>直接存储器存取(DMA)方式是一种<strong>完全由硬件执行</strong>I&#x2F;O交换的方式。</p><p>中断：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230210101615261.png" alt="中断处理示意图"></p><p>中断源：内部中断源和外部中断源</p><p>中断的过程一般包括中断请求、中断响应、中断处理和中断返回。</p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微机原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统概述</title>
      <link href="/2023/02/10/Learn/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/1%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
      <url>/2023/02/10/Learn/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/1%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="计算机系统概述"><a href="#计算机系统概述" class="headerlink" title="计算机系统概述"></a>计算机系统概述</h1><h2 id="计算机中的数据表示与编码"><a href="#计算机中的数据表示与编码" class="headerlink" title="计算机中的数据表示与编码"></a>计算机中的数据表示与编码</h2><p><strong>数与数制</strong></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209163055786.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209163110832.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209163124268.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209163251973.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209163850855.png"></p><p><strong>原码：</strong></p><p>对于二进制数，正数的原码就是它本身，负数的原码符号位取1，数值部分是真值的绝对值。</p><p><strong>反码：</strong></p><p>对于二进制数，正数的反码就是它本身，负数的反码符号位取1，数值部分按位取反。</p><p><strong>补码：</strong></p><p>对于二进制数，正数的补码就是它本身，负数的补码符号位取1，数值部分按位取反末位加1。</p><p><strong>ASCII码：</strong></p><p>A 十进制：65  十六进制：41</p><p>a 十进制：97  十六进制：61</p><h2 id="逻辑电路基础"><a href="#逻辑电路基础" class="headerlink" title="逻辑电路基础"></a>逻辑电路基础</h2><p>数电学了。略。</p><p><strong>触发器</strong>是计算机<strong>记忆装置的基本单元</strong>，也是构成<strong>时序电路的基础</strong>。</p><p>由n个触发器可以组成一个n位寄存器。</p><h2 id="计算机系统概述-1"><a href="#计算机系统概述-1" class="headerlink" title="计算机系统概述"></a>计算机系统概述</h2><p><strong>计算机系统的组成</strong></p><p>计算机由运算器、存储器、控制器、输入设备和输出设备五大基本部件组成。</p><p>冯诺依曼结构的计算机是以<strong>运算器</strong>为中心的，输入&#x2F;输出设备与存储器之间的数据传送都要通过运算器。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209202254324.png" alt="图1.14 以运算器为中心的计算机结构"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209202327580.png"></p><p>将早期运算器和控制器集成在一片集成电路中，称为中央处理器。(CPU)</p><p>CPU和内存构成计算机的主机。</p><p>主机以外的其他硬件设备都称为外设。</p><p>现代计算机系统是以<strong>存储器</strong>为中心的，采用总线结构，在系统总线上配置一定容量的存储器和一定数目的I&#x2F;O接口电路，以及相对应的I&#x2F;O设备而构成的。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209203518589.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209203607434.png"></p><p><strong>存储系统</strong></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230210090915755.png"></p><p><strong>内存容量</strong></p><p>内存容量是以字节为单位计算的。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230210091143510.png"></p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微机原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆变电路</title>
      <link href="/2023/02/09/Learn/%E7%94%B5%E5%8A%9B%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2%E3%80%81%E9%80%86%E5%8F%98%E7%94%B5%E8%B7%AF/"/>
      <url>/2023/02/09/Learn/%E7%94%B5%E5%8A%9B%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2%E3%80%81%E9%80%86%E5%8F%98%E7%94%B5%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="逆变电路"><a href="#逆变电路" class="headerlink" title="逆变电路"></a>逆变电路</h1><h2 id="换流方式"><a href="#换流方式" class="headerlink" title="换流方式"></a>换流方式</h2><h3 id="逆变电路的基本工作原理"><a href="#逆变电路的基本工作原理" class="headerlink" title="逆变电路的基本工作原理"></a>逆变电路的基本工作原理</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209121740519.png"></p><h3 id="换流方式分类"><a href="#换流方式分类" class="headerlink" title="换流方式分类"></a>换流方式分类</h3><p>换流：电流从一个支路向另一个支路转移的过程，也称为换相。</p><p>研究换流方式主要是研究如何使器件关断。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209121959959.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209122123624.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209122204002.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209122225353.png"></p><p><strong>换流方式</strong></p><ol><li>器件换流</li><li>电网换流</li><li>负载换流</li><li>强迫换流</li></ol><p><strong>换流方式总结</strong></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209122254783.png"></p><h2 id="电压型逆变电路"><a href="#电压型逆变电路" class="headerlink" title="电压型逆变电路"></a>电压型逆变电路</h2><h3 id="单相电压型逆变电路"><a href="#单相电压型逆变电路" class="headerlink" title="单相电压型逆变电路"></a>单相电压型逆变电路</h3><h4 id="半桥逆变电路"><a href="#半桥逆变电路" class="headerlink" title="半桥逆变电路"></a>半桥逆变电路</h4><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209143902543.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209144005971.png"></p><h4 id="全桥逆变电路"><a href="#全桥逆变电路" class="headerlink" title="全桥逆变电路"></a>全桥逆变电路</h4><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209144218865.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209144801708.png"></p><h4 id="带中心抽头变压器的逆变电路"><a href="#带中心抽头变压器的逆变电路" class="headerlink" title="带中心抽头变压器的逆变电路"></a>带中心抽头变压器的逆变电路</h4><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209144940822.png"></p><h3 id="三相电压型逆变电路"><a href="#三相电压型逆变电路" class="headerlink" title="三相电压型逆变电路"></a>三相电压型逆变电路</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209145815895.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209150542037.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209150604537.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209150651633.png" alt="基本数量关系"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209151911980.png"></p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209152355444.png"></p><h2 id="电流型逆变电路"><a href="#电流型逆变电路" class="headerlink" title="电流型逆变电路"></a>电流型逆变电路</h2><h3 id="单相电流型逆变电路"><a href="#单相电流型逆变电路" class="headerlink" title="单相电流型逆变电路"></a>单相电流型逆变电路</h3><h4 id="单相桥式电流型逆变电路"><a href="#单相桥式电流型逆变电路" class="headerlink" title="单相桥式电流型逆变电路"></a>单相桥式电流型逆变电路</h4><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209152535263.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209152616819.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209152653652.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209152714375.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209152729764.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209152748304.png"></p><h3 id="三相电流型逆变电路"><a href="#三相电流型逆变电路" class="headerlink" title="三相电流型逆变电路"></a>三相电流型逆变电路</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209152844759.png"></p><h2 id="多重逆变电路和多电平逆变电路"><a href="#多重逆变电路和多电平逆变电路" class="headerlink" title="多重逆变电路和多电平逆变电路"></a>多重逆变电路和多电平逆变电路</h2><h3 id="多重逆变电路"><a href="#多重逆变电路" class="headerlink" title="多重逆变电路"></a>多重逆变电路</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209153240116.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209153315196.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209153426115.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209153437525.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209153456740.png"></p><h3 id="多电平逆变电路"><a href="#多电平逆变电路" class="headerlink" title="多电平逆变电路"></a>多电平逆变电路</h3><p>略</p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电力电子技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整流电路</title>
      <link href="/2023/02/09/Learn/%E7%94%B5%E5%8A%9B%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/1%E3%80%81%E6%95%B4%E6%B5%81%E7%94%B5%E8%B7%AF/"/>
      <url>/2023/02/09/Learn/%E7%94%B5%E5%8A%9B%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/1%E3%80%81%E6%95%B4%E6%B5%81%E7%94%B5%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="整流电路"><a href="#整流电路" class="headerlink" title="整流电路"></a>整流电路</h1><h2 id="单相可控整流电路"><a href="#单相可控整流电路" class="headerlink" title="单相可控整流电路"></a>单相可控整流电路</h2><h3 id="单相半波可控整流电路"><a href="#单相半波可控整流电路" class="headerlink" title="单相半波可控整流电路"></a>单相半波可控整流电路</h3><h4 id="带电阻负载工作"><a href="#带电阻负载工作" class="headerlink" title="带电阻负载工作"></a>带电阻负载工作</h4><p>电阻负载的特点是电压与电流成正比，两者波形相同。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208131556763.png" alt="单相半波可控整流电路"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208131819686.png" alt="电路波形"></p><p>变压器T起变换电压和隔离的作用。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208133731101.png" alt="基本数量关系"></p><h4 id="带阻感负载工作"><a href="#带阻感负载工作" class="headerlink" title="带阻感负载工作"></a>带阻感负载工作</h4><p>阻感负载的特点是电感对电流变化有抗拒作用，使得流过电感的电流不能发生突变。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208134428496.png" alt="带阻感负载的单相半波可控整流电路及其波形"></p><p>电路分析：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208135120122.png"></p><p>在整流电路的负载两端并联一个二极管，称为续流二极管，用VD<del>R</del>表示。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208145000292.png" alt="单相半波带阻感负载有续流二极管的电路及波形"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208145053071.png" alt="电路分析"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208150626105.png" alt="基本数量关系"></p><p>单相半波可控整流电路的特点是简单，但输出脉冲大，变压器二次侧电流中含直流分量，造成变压器铁芯<strong>直接磁化</strong>。为使变压器铁芯不饱和，需增大铁芯截面积，增大了设备的容量。</p><h3 id="单相桥式全控整流电路"><a href="#单相桥式全控整流电路" class="headerlink" title="单相桥式全控整流电路"></a>单相桥式全控整流电路</h3><h4 id="带电阻负载工作-1"><a href="#带电阻负载工作-1" class="headerlink" title="带电阻负载工作"></a>带电阻负载工作</h4><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208151911944.png" alt="单相全控桥式带电阻负载时的电路及波形"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208151956112.png" alt="电路分析"></p><p><strong>基本数量关系：</strong></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208152356937.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208152624495.png"></p><h4 id="带阻感负载工作-1"><a href="#带阻感负载工作-1" class="headerlink" title="带阻感负载工作"></a>带阻感负载工作</h4><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208152924294.png" alt="单相桥式全控整流电路带阻感负载时的电路及波形"></p><p><strong>电路分析：</strong></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208153455205.png"></p><p><strong>数量关系：</strong></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208154044578.png"></p><h4 id="带反电动势负载工作"><a href="#带反电动势负载工作" class="headerlink" title="带反电动势负载工作"></a>带反电动势负载工作</h4><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208160515079.png" alt="单相桥式全控整流电路接反电动势——电阻负载时的电路及波形"></p><p><strong>工作情况：</strong></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208160617766.png"></p><p><strong>电流断续：</strong></p><ul><li>i<del>d</del>波形在一周期内有部分时间为0的情况，称为电流断续。</li><li>负载为直流电动机时，如果出现电流断续，则电动机的机械特性很软。</li><li>为了克服此缺点，一般在主电路中直流输出侧串联一个平波电抗器。</li><li>为保证电流连续所需的电感量L可由下式求出：</li></ul><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208161815024.png"></p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208161931826.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208161944131.png"></p><h3 id="单相全波可控整流电路"><a href="#单相全波可控整流电路" class="headerlink" title="单相全波可控整流电路"></a>单相全波可控整流电路</h3><h4 id="带电阻负载工作-2"><a href="#带电阻负载工作-2" class="headerlink" title="带电阻负载工作"></a>带电阻负载工作</h4><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208162303847.png" alt="单相全波可控整流电路及波形"></p><p><strong>电路分析</strong></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208162401109.png"></p><p><strong><u>单相全波与单相全控桥的区别：</u></strong></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208162540902.png"></p><p>从上述后两点考虑，单相全波电路有利于在低输出电压的场合应用。</p><h3 id="单相桥式半控整流电路"><a href="#单相桥式半控整流电路" class="headerlink" title="单相桥式半控整流电路"></a>单相桥式半控整流电路</h3><p>与全控电路在电阻负载时的工作情况相同。</p><h4 id="带阻感负载工作-2"><a href="#带阻感负载工作-2" class="headerlink" title="带阻感负载工作"></a>带阻感负载工作</h4><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208163145575.png" alt="单相桥式半控整流电路，有续流二极管，阻感负载时的电路及波形"></p><p><strong>电路分析：</strong></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208165245605.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208171926755.png"></p><p><strong>单相桥式半控整流电路的另一种解法：</strong></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208172041729.png" alt="单相桥式半控整流电路的另一种接法"></p><p>这样可以省去续流二极管VD<del>R</del>，续流由VD<del>3</del>和VD<del>4</del>来实现。</p><p>这种接法的两个晶闸管阴极电位不同，二者的触发电路需要隔离。</p><h2 id="三相可控整流电路"><a href="#三相可控整流电路" class="headerlink" title="三相可控整流电路"></a>三相可控整流电路</h2><h3 id="三相半波可控整流电路"><a href="#三相半波可控整流电路" class="headerlink" title="三相半波可控整流电路"></a>三相半波可控整流电路</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208195144548.png" alt="三相半波可控整流电路共阴极接法电阻负载时的电路及α=0°时的波形"></p><p><strong>电路分析：</strong></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208195731714.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208212739385.png" alt="三相半波可控整流电路，电阻负载，α=30°时的波形"></p><p>当α&#x3D;30°时，负载电流处于连续和断续的临界状态，各相仍导电120°。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208213425241.png" alt="三相半波可控整流电路，电阻负载，α=60°时的波形"></p><p>当α&gt;30°时，负载电流断续。</p><p><strong>基本数量关系：</strong></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208213629214.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208215556971.png"></p><h4 id="阻感负载"><a href="#阻感负载" class="headerlink" title="阻感负载"></a>阻感负载</h4><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208220607031.png"></p><p><strong>基本数量关系：</strong></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208220944083.png" alt="image-20230208220944083"></p><p> <img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208225103313.png"></p><h3 id="三相桥式全控整流电路"><a href="#三相桥式全控整流电路" class="headerlink" title="三相桥式全控整流电路"></a>三相桥式全控整流电路</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209093710352.png" alt="三相桥式全控整流电路原理图"></p><h4 id="带电阻负载工作-3"><a href="#带电阻负载工作-3" class="headerlink" title="带电阻负载工作"></a>带电阻负载工作</h4><p>电路分析：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209093905989.png"></p><p><strong>一些特点：</strong></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209095354972.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209095437316.png"></p><h4 id="带阻感负载工作-3"><a href="#带阻感负载工作-3" class="headerlink" title="带阻感负载工作"></a>带阻感负载工作</h4><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209095518445.png" alt="电路分析"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209095532687.png" alt="基本数量关系"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209095552645.png"></p><h2 id="变压器漏感对整流电路的影响"><a href="#变压器漏感对整流电路的影响" class="headerlink" title="变压器漏感对整流电路的影响"></a>变压器漏感对整流电路的影响</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209101227701.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209101539090.png" alt="基本数量关系"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209102415733.png" alt="换向重叠角"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209102518736.png"></p><h2 id="整流电路的谐波和功率因数"><a href="#整流电路的谐波和功率因数" class="headerlink" title="整流电路的谐波和功率因数"></a>整流电路的谐波和功率因数</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209105533862.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209105556310.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209110551864.png"></p><h2 id="整流电路的有源逆变工作状态"><a href="#整流电路的有源逆变工作状态" class="headerlink" title="整流电路的有源逆变工作状态"></a>整流电路的有源逆变工作状态</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209112146759.png"></p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电力电子技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电力电子课设</title>
      <link href="/2023/02/09/Learn/%E7%94%B5%E5%8A%9B%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/%E7%94%B5%E5%8A%9B%E7%94%B5%E5%AD%90%E8%AF%BE%E8%AE%BE/"/>
      <url>/2023/02/09/Learn/%E7%94%B5%E5%8A%9B%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/%E7%94%B5%E5%8A%9B%E7%94%B5%E5%AD%90%E8%AF%BE%E8%AE%BE/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="电力电子课设"><a href="#电力电子课设" class="headerlink" title="电力电子课设"></a>电力电子课设</h1><h2 id="一、选题背景与设计指标"><a href="#一、选题背景与设计指标" class="headerlink" title="一、选题背景与设计指标"></a><strong>一、</strong>选题背景与设计指标</h2><h3 id="1-选题背景介绍"><a href="#1-选题背景介绍" class="headerlink" title="1.选题背景介绍"></a>1.选题背景介绍</h3><p>本课程作为本学院《电力电子技术》课程的配套课程设计课，以开放式、学生实践的形式开出。课程从理论联系实际的角度出发，掌握各种电力电子电路的结构、工作原理、控制方法、设计计算方法及实验技能，并将各种变换电路组合实现电能的变换和控制，让学生体会将理论知识运用于实际的过程和团队合作的意义，同时培养学生的创新精神、激发学生的创新意识、增强学生的动手和实践能力。</p><p>通过本次课程设计，学生将学会利用仿真平台实现整流电路、Buck斩波电路和逆变电路的设计，本在各自的课程要求上通过对电路参数的调节实现整流电路输出软启动、降压斩波和单相逆变输出期望电压波形。</p><h3 id="2-电路设计指标"><a href="#2-电路设计指标" class="headerlink" title="2.电路设计指标"></a>2.电路设计指标</h3><p>根据课程设计相关课程要求，本报告所需要实现的设计指标如下表所示：</p><table><thead><tr><th><strong>设计指标</strong></th><th><strong>要求</strong></th></tr></thead><tbody><tr><td>可控整流输出电压</td><td>150V</td></tr><tr><td>可控整流软启动时间</td><td>2.6s</td></tr><tr><td>降压斩波输出电压</td><td>80V</td></tr><tr><td>降压斩波开关频率</td><td>15KHz</td></tr><tr><td>逆变输出频率</td><td>150Hz</td></tr><tr><td>逆变输出幅值</td><td>38V</td></tr><tr><td>逆变开关频率</td><td>26KHz</td></tr></tbody></table><h2 id="二、设计思路"><a href="#二、设计思路" class="headerlink" title="二、设计思路"></a>二、设计思路</h2><p>本次课程设计的相关电路按照功能可以划分为：</p><p>1）触发脉冲产生电路：通过电压比较器和晶体管积分电路实现整流电路移相触发脉冲的产生。</p><p>2）单相整流电路：通过全桥整流和滤波环节实现将220V&#x2F;50Hz的交流输入电压转化为直流电压，并实现2.6s的电路软启动。</p><p>3）直流斩波电路：利用Buck斩波电路和电容元件将整流电路的输出电压降低为要求输出值；</p><p>4）单相逆变电路：通过PWM调制的方式将斩波电路的输出直流电压转化为要求幅值和频率的正弦交流电输出；</p><h2 id="三、过程论述"><a href="#三、过程论述" class="headerlink" title="三、过程论述"></a>三、过程论述</h2><h3 id="1-仿真电路的主要组成"><a href="#1-仿真电路的主要组成" class="headerlink" title="1.仿真电路的主要组成"></a>1.仿真电路的主要组成</h3><p>由本报告“二、设计思路”分析可得，本课程设计的仿真电路主要由四个部分组成，方框图表示如下：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209114715959.png" alt="图3-1：基本仿真电路方框图">                    </p><h3 id="2-基本仿真实验"><a href="#2-基本仿真实验" class="headerlink" title="2.基本仿真实验"></a>2.基本仿真实验</h3><h4 id="1）可控整流仿真Simulink图与仿真波形"><a href="#1）可控整流仿真Simulink图与仿真波形" class="headerlink" title="1）可控整流仿真Simulink图与仿真波形"></a>1）可控整流仿真Simulink图与仿真波形</h4><h5 id="i-主电路原理及仿真电路图"><a href="#i-主电路原理及仿真电路图" class="headerlink" title="i.主电路原理及仿真电路图"></a>i.主电路原理及仿真电路图</h5><p>典型的单相桥式全控整流电路由晶闸管构成桥式开关，其原理图及其输出电压ud波形如下图所示：</p><p> <img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209114740144.png" alt="图3-2：典型的单相桥式全控整流电路及其相关波形"></p><p>由图可知，若在电路的输出侧加上大电容进行低频滤波，则可以从电容两端取得一个较为平缓的直流输出电压。因此，Simulink中对该电路的仿真原理图如下图所示：</p><p> <img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209114755917.png" alt="图3-3：Simulink中搭建的单相桥式全控整流电路"></p><p>其中，与电容并接的二极管起续流作用；</p><h5 id="ii-相触发电路原理及仿真电路图"><a href="#ii-相触发电路原理及仿真电路图" class="headerlink" title="ii.相触发电路原理及仿真电路图"></a>ii.相触发电路原理及仿真电路图</h5><p>移相触发电路将为整流电路提供合适的触发脉冲，通过改变整流电路晶闸管的导通角，使整流电路输出不同的整流电压。</p><p>典型的移相触发电路由以下几个部分组成：</p><p>1）同步环节</p><p>2）锯齿波产生环节</p><p>3）触发脉冲产生环节</p><p>经过课本的电路分析可知，从模块的角度上看，该触发电路对外暴露X、Y端子，利用这两个端子可将同类型的触发电路进行串联，实现双触发脉冲的产生。<br>考虑到本次课设所采用的触发电路是针对单相整流电路的，因此，本课设将采用另一种形式的触发电路实现，其Simulink电路仿真原理图如下图所示：</p><p> <img src="C:/Users/Zunrong%20Guo/AppData/Roaming/Typora/typora-user-images/image-20230209114812164.png" alt="图3-4：本课设所采用的移相触发电路"></p><p>下面对该电路的工作原理进行详细分析：</p><p>1）同步环节：将电源电压通过变压器同步到触发电路侧，并利用电压比较器产生两路矩形波；</p><p>2）锯齿波产生环节：</p><p>将同步环节的两路矩形波送入由晶体管构成的积分电路中，即可从电容侧得到锯齿波；</p><p>积分电路原理：晶体管与射极电阻、以及与be极相并联的二极管构成了简易恒流源电路。当电压比较器输出负电压时，电容将与二极管、电压比较器的输出端构成放电回路，电容迅速放电，电容电压uc &#x3D; 0；当电压比较器输出正电压时，二极管截止，集电极回路的电容被恒流源充电，故uc线性增长，从而在电容正极得到锯齿波。</p><p>3）脉冲产生环节</p><p>将锯齿波与一个恒定的可调直流电压送入电压比较器，即可得到触发脉冲，脉冲前沿由锯齿波斜坡与直流电压的交点位置决定。STW1、STW2为锯齿波波形，峰值为5V。Ref_U为输入电压比较器的直流电压；波形图下方为触发脉冲输出。可见触发脉冲的脉宽由锯齿波和直流电压共同决定 ；</p><h5 id="iii-软启动实现"><a href="#iii-软启动实现" class="headerlink" title="iii.软启动实现"></a>iii.软启动实现</h5><p>由上述分析可以联想到：实现电路软启动要求整流电路的触发角α能随时间改变，即触发脉冲产生电路能产生一组脉冲前沿随时间变化的触发脉冲；</p><p>故软启动问题可以简化为求取一条电压值随时间发生变化的直流电压，并将该直流电压输入到脉冲产生环节的电压比较器即可。</p><p>利用Simulink中的可变电阻及斜坡信号模型，即可完成时变直流电压的产生，相关电路仿真原理图如下：</p><p> <img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209114828903.png" alt="图3-5：软启动部分的电路仿真原理图"></p><p>​       iv.     相关参数整定</p><p>1）整流输出电压相关参数：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209114846161.png" alt="图3-6：整流输出的电路参数计算"></p><p>由前述对电路原理的分析可知：影响整流输出电压的参数实际上为饱和非线性环节的限幅下限值。由二分法试凑可迅速得出限幅下限为0.175。</p><p>通过试凑方式的参数整定，本人也感受到了Simulink进行电路仿真的优势所在。</p><p>2）软启动时间相关参数：</p><p>观察整流电路的输出波形可知，输出波形增大到达稳态的转折处大致与时变直流电压的转折点在同一个时间点上。而当触发角α &#x3D; 180°时，此时直流电压的幅值应为锯齿波电压的幅值，即5V，对应斜坡信号值为0.5；</p><p>根据软启动时间的定义可知：整流电路需在t &#x3D; 3s时输出150 * 80% V &#x3D; 120V的直流电压。故先计算使输出为120V时的限幅下限值为0.21598，之后计算0到2.6秒内的斜坡环节斜率：</p><p> <img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209114859931.png" alt="图3-7：软启动部分的电路参数计算"></p><p>将计算值代入Simulink斜坡环节，同时限幅下限更改为0.175（150V电压输出对应的下限值），微调参数k &#x3D; -0.1095，即可使t &#x3D; 2.6s时输出电压为120V，达到要求； </p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209114922477.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209114933908.png" alt="图3-8：软启动部分的电路仿真图"></p><h4 id="2）Buck斩波仿真Simulink图与波形"><a href="#2）Buck斩波仿真Simulink图与波形" class="headerlink" title="2）Buck斩波仿真Simulink图与波形"></a>2）Buck斩波仿真Simulink图与波形</h4><h5 id="i-Buck降压斩波电路原理及仿真电路图"><a href="#i-Buck降压斩波电路原理及仿真电路图" class="headerlink" title="i.Buck降压斩波电路原理及仿真电路图"></a>i.Buck降压斩波电路原理及仿真电路图</h5><p>典型的Buck降压斩波电路由全控型电力电子器件、续流二极管以及电感元件组成，全控器件采用PWM调制控制开关动作。其电路原理及输出波形图如下：</p><p> <img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209114952065.png" alt="图3-9：Buck降压斩波电路原理图及输出波形图"></p><p>该电路的输出电压均值Ud与输入电压E的关系为：</p><p>Ud &#x3D; αE</p><p>其中，α为PWM波的导通占空比，通过调节PWM占空比，即可调节输出电压的平均值；</p><p> <img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209115006150.png" alt="图3-10：Buck部分的电路仿真图"></p><h5 id="ii-相关参数整定"><a href="#ii-相关参数整定" class="headerlink" title="ii.相关参数整定"></a>ii.相关参数整定</h5><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209115032026.png"></p><p>降压斩波开关频率为15KHz，周期为Period&#x3D;1&#x2F;15KHz&#x3D;0.00006667</p><p>   输入电压为150V，输出电压为80V。由降压斩波电路的输入、输出电压关系：Ud &#x3D; αE可得，当要求输出电压为80V直流电时，理想占空比应为 α &#x3D; 53.33%。</p><p>设置PWM占空比为该值，并在此基础上利用二分法试凑进行小范围调整，可得该电路模块在 α &#x3D; 61%时，恰能输出80V直流电，其测量波形可见下方的“仿真波形展示”。</p><h5 id="iii-仿真波形展示"><a href="#iii-仿真波形展示" class="headerlink" title="iii.仿真波形展示"></a>iii.仿真波形展示</h5><p> Buck斩波电路的仿真波形图如下图所示，其中由测量结果可知，该电路模块达到输出80V直流电压的指标要求：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209115051084.png" alt="图3-11：Buck斩波电路的Simulink仿真波形"></p><h4 id="3）单相逆变仿真Simulink图与波形"><a href="#3）单相逆变仿真Simulink图与波形" class="headerlink" title="3）单相逆变仿真Simulink图与波形"></a>3）单相逆变仿真Simulink图与波形</h4><h5 id="i-双极性PWM调制原理"><a href="#i-双极性PWM调制原理" class="headerlink" title="i.双极性PWM调制原理"></a>i.双极性PWM调制原理</h5><p>接下来以单相桥式逆变电路为例，分析双极性PWM调制的原理：</p><p>1）PWM调制的原理保证：面积等效原理。即对于感性电路，在窄脉冲电压源作用之后，回路上的电流响应规律与脉冲电压的形状基本无关；</p><p>2）PWM调制：PWM调制即将信号波所蕴含的规律“加载”到一组PWM波上，信号波在某一时刻附近的幅值由PWM在这里时刻附近的占空比大小进行表征。</p><p>3）基本的PWM调制由单极性调制和双极性调制，两者对正弦信号进行调制时产生的PWM波对比如下图所示。其中左图为单极性调制（信号波在一个极性周期内，对应的PWM幅值只能有两种取值，例如0和+Ud）、右图为双极性调制（信号波在一个极性周期内，对应的PWM幅值有三种取值：0和±Ud）：</p><p> <img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209115104407.png" alt="图3-12：单极性PWM调制（左）与双极性PWM调制（右）"></p><h5 id="ii-单相桥式逆变电路的原理"><a href="#ii-单相桥式逆变电路的原理" class="headerlink" title="ii.单相桥式逆变电路的原理"></a>ii.单相桥式逆变电路的原理</h5><p>若将经过正弦波调制后的PWM波（称为SPWM）作用于由全控型器件（例如IGBT）组成的全控桥，全控桥输入直流电压，并使全控桥带阻感负载，则负载输出的电流波形将近似为正弦波，且该正弦波与被调制的正弦信号基本同步，这即为单相桥式逆变电路的原理。</p><p>Simulink中的单相桥式逆变电路仿真图如下图所示：</p><p> <img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209115118824.png" alt="图3-13：Simulink中的单相桥式逆变电路仿真图"></p><p>其中，仿真图下方的电路部分利用逻辑运算电路，实现了SPWM双极性调制。IGBT全控桥带阻感负载，并在电阻两端取电压输出。由上述分析可知，输出电流近似正弦波时，经过电阻负载上的电压也应为近似正弦波的波形；</p><h5 id="iii-相关参数整定"><a href="#iii-相关参数整定" class="headerlink" title="iii.相关参数整定"></a>iii.相关参数整定</h5><p>1）逆变开关频率：1&#x2F;26KHz&#x3D;0.00003846</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209115147988.png"></p><p>2） 逆变输出频率：Frequency&#x3D;150<em>2</em>Π</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209115158697.png"></p><p>3）逆变输出赋值：信号波幅值&#x2F;载波幅值&#x3D;输出电压&#x2F;输入电压</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209115222099.png"></p><h5 id="iv-仿真波形展示"><a href="#iv-仿真波形展示" class="headerlink" title="iv.仿真波形展示"></a>iv.仿真波形展示</h5><p>​<br> 双极性PWM调制电路及单相逆变电路的Simulink仿真波形图如下图所示，且由图示测量结果可知，电路输出电压达到指标要求：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209115234903.png" alt="图3-14：Simulink中的单相桥式逆变电路波形图"></p><h4 id="4）综合仿真Simulink图与波形"><a href="#4）综合仿真Simulink图与波形" class="headerlink" title="4）综合仿真Simulink图与波形"></a>4）综合仿真Simulink图与波形</h4><p> 综合电路仿真图和波形如下图所示：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209115249551.png" alt="图3-15：Simulink综合电路仿真图"></p><p> <img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209115302556.png"></p><p> <img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209115314954.png" alt="图3-16：Simulink综合电路波形图"></p><h3 id="3-附加扩展"><a href="#3-附加扩展" class="headerlink" title="3.   附加扩展"></a><strong>3.</strong>   <strong>附加扩展</strong></h3><p>本设计采用PI闭环形式对Buck电路进行闭环控制，让斩波输出电压与80V做差，为偏差信号，因为I是波形在时间上的积分，在软启动阶段有较大的偏差，导致PI控制器的输出在短时间内无法到达稳定，所以在0时刻加入P控制，在3s后再加入I控制减少误差。如图所示：</p><p> <img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209115330546.png" alt="图3-17：Buck电路闭环仿真图"></p><p>仿真效果较好，波形如图所示。</p><p> <img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209115343868.png" alt="图3-18：Buck电路闭环波形图"></p><h2 id="四、结果分析"><a href="#四、结果分析" class="headerlink" title="四、结果分析"></a>四、结果分析</h2><p>由综合电路的仿真波形图测量可知，仿真电路的各项实际指标与期望指标的对比如下表所示：</p><table><thead><tr><th><strong>设计指标</strong></th><th><strong>要求</strong></th><th><strong>实际指标</strong></th></tr></thead><tbody><tr><td>可控整流输出电压</td><td>150V</td><td>150.18V</td></tr><tr><td>可控整流软启动时间</td><td>2.6s</td><td>2.64s</td></tr><tr><td>降压斩波输出电压</td><td>80V</td><td>79.85V</td></tr><tr><td>降压斩波开关频率</td><td>15KHz</td><td>15.0KHz</td></tr><tr><td>逆变输出频率</td><td>150Hz</td><td>150.0Hz</td></tr><tr><td>逆变输出幅值</td><td>38V</td><td>38.84V</td></tr><tr><td>逆变开关频率</td><td>26KHz</td><td>26KHz</td></tr></tbody></table><p>   对比可知，本课程设计所设计的仿真电路基本符合指标要求；</p><h2 id="五、课程设计总结"><a href="#五、课程设计总结" class="headerlink" title="五、课程设计总结"></a>五、课程设计总结</h2><p>在本次课程设计中，我学会将课程上所学到的各种分散的电路功能模块结合到一起，在Simulink仿真平台进行各个模块的设计与调参，并且最终实现了一个简易的AC-AC变频电路（市电到190Hz正弦交流电）。</p><p>通过本次课程设计，我对各个电路环节在实际工程中的用法有了一个初步的了解，并且通过仿真平台学习到了一些工程上的知识，例如整流电路的输出接大电容进行输出滤波、单相桥式PWM逆变电路输出接小电容滤去输出电压的高频毛刺……。</p><p>另外，本次课程设计将PWM调制和移相调制巧妙地结合起来，而我通过对这两种调制方式的电路实现中也直观感受出了PWM调制的优势所在（上一次这么深刻的感悟是在电力电子技术的第一次实验课上，用PWM调制控制一个单相全控整流桥）。</p><p>最后，在Simulink上设计电路以及调参的过程还是挺有趣的。</p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电力电子技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Front-matter</title>
      <link href="/2023/02/09/Learn/%E6%9D%82/blog%20title/"/>
      <url>/2023/02/09/Learn/%E6%9D%82/blog%20title/</url>
      
        <content type="html"><![CDATA[<h2 id="文章-Front-matter-介绍"><a href="#文章-Front-matter-介绍" class="headerlink" title="文章 Front-matter 介绍"></a>文章 Front-matter 介绍</h2><h3 id="Front-matter-选项详解"><a href="#Front-matter-选项详解" class="headerlink" title="Front-matter 选项详解"></a>Front-matter 选项详解</h3><p><code>Front-matter</code> 选项中的所有内容均为<strong>非必填</strong>的。但我仍然建议至少填写 <code>title</code> 和 <code>date</code> 的值。</p><table><thead><tr><th>配置选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td><code>Markdown</code> 的文件标题</td><td>文章标题，强烈建议填写此选项</td></tr><tr><td>date</td><td>文件创建时的日期时间</td><td>发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td>author</td><td>根 <code>_config.yml</code> 中的 <code>author</code></td><td>文章作者</td></tr><tr><td>img</td><td><code>featureImages</code> 中的某个值</td><td>文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <code>http://xxx.com/xxx.jpg</code></td></tr><tr><td>top</td><td><code>true</code></td><td>推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td></tr><tr><td>hide</td><td><code>false</code></td><td>隐藏文章，如果<code>hide</code>值为<code>true</code>，则文章不会在首页显示</td></tr><tr><td>cover</td><td><code>false</code></td><td><code>v1.0.2</code>版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td>coverImg</td><td>无</td><td><code>v1.0.2</code>版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td>password</td><td>无</td><td>文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td>toc</td><td><code>true</code></td><td>是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td></tr><tr><td>mathjax</td><td><code>false</code></td><td>是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td></tr><tr><td>summary</td><td>无</td><td>文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td>categories</td><td>无</td><td>文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td>tags</td><td>无</td><td>文章标签，一篇文章可以多个标签</td></tr><tr><td>keywords</td><td>文章标题</td><td>文章关键字，SEO 时需要</td></tr><tr><td>reprintPolicy</td><td>cc_by</td><td>文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个</td></tr></tbody></table><blockquote><p><strong>注意</strong>:</p><ol><li>如果 <code>img</code> 属性不填写的话，文章特色图会根据文章标题的 <code>hashcode</code> 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章的特色图<strong>各有特色</strong>。</li><li><code>date</code> 的值尽量保证每篇文章是唯一的，因为本主题中 <code>Gitalk</code> 和 <code>Gitment</code> 识别 <code>id</code> 是通过 <code>date</code> 的值来作为唯一标识的。</li><li>如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 <code>_config.yml</code> 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：<a href="http://tool.oschina.net/encrypt?type=2">开源中国在线工具</a>、<a href="http://encode.chahuo.com/">chahuo</a>、<a href="http://tool.chinaz.com/tools/hash.aspx">站长工具</a>。</li><li>您可以在文章md文件的 front-matter 中指定 reprintPolicy 来给单个文章配置转载规则</li></ol></blockquote><p>以下为文章的 <code>Front-matter</code> 示例。</p><h3 id="最简示例"><a href="#最简示例" class="headerlink" title="最简示例"></a>最简示例</h3><pre class="line-numbers language-none"><code class="language-none">---title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="最全示例"><a href="#最全示例" class="headerlink" title="最全示例"></a>最全示例</h3><pre class="line-numbers language-none"><code class="language-none">---title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00author: 赵奇img: &#x2F;source&#x2F;images&#x2F;xxx.jpgtop: truehide: falsecover: truecoverImg: &#x2F;images&#x2F;1.jpgpassword: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92toc: falsemathjax: falsesummary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要categories: Markdowntags:  - Typora  - Markdown---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解决图床问题：</p><meta name="referrer" content="no-referrer" />]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter8 操作臂的机构设计</title>
      <link href="/2023/02/08/Learn/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6%E5%AF%BC%E8%AE%BA/Chapter8%20%E6%93%8D%E4%BD%9C%E8%87%82%E7%9A%84%E6%9C%BA%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
      <url>/2023/02/08/Learn/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6%E5%AF%BC%E8%AE%BA/Chapter8%20%E6%93%8D%E4%BD%9C%E8%87%82%E7%9A%84%E6%9C%BA%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="Chapter8-操作臂的机构设计"><a href="#Chapter8-操作臂的机构设计" class="headerlink" title="Chapter8 操作臂的机构设计"></a>Chapter8 操作臂的机构设计</h1><p>机器人系统的组成大体可分为四部分：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208113440567.png"></p><h2 id="基于任务需求的设计"><a href="#基于任务需求的设计" class="headerlink" title="基于任务需求的设计"></a>基于任务需求的设计</h2><h3 id="自由度的数目"><a href="#自由度的数目" class="headerlink" title="自由度的数目"></a>自由度的数目</h3><p>操作臂的自由度数目应该与所要完成的任务相匹配。</p><h3 id="工作空间"><a href="#工作空间" class="headerlink" title="工作空间"></a>工作空间</h3><p>在执行工作任务时，操作臂必须能够抓取到若干工件或夹具。</p><h3 id="负载能力"><a href="#负载能力" class="headerlink" title="负载能力"></a>负载能力</h3><p>操作臂的负载能力与其结构尺寸、传动系统和驱动器有关。</p><h3 id="速度"><a href="#速度" class="headerlink" title="速度"></a>速度</h3><p>在设计操作臂时，一个明显的目标是使操作臂具有越来越高的速度。</p><h3 id="重复精度与精度"><a href="#重复精度与精度" class="headerlink" title="重复精度与精度"></a>重复精度与精度</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208113808042.png"></p><h2 id="运动学构型"><a href="#运动学构型" class="headerlink" title="运动学构型"></a>运动学构型</h2><h3 id="直角坐标型"><a href="#直角坐标型" class="headerlink" title="直角坐标型"></a>直角坐标型</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208113934738.png" alt="直角坐标型操作臂"></p><p><strong>优点与缺点：</strong></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208114155706.png"></p><h3 id="铰接型"><a href="#铰接型" class="headerlink" title="铰接型"></a>铰接型</h3><p>减少了操作臂侵入工作空间的可能性，使操作臂能够到达受限制的空间位置。它们的总体结构比直角坐标操作臂小，当应用于较小工作空间的场合时，可谓物美价廉。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208114241065.png" alt="铰接型机器人"></p><h3 id="SCARA型"><a href="#SCARA型" class="headerlink" title="SCARA型"></a>SCARA型</h3><p>这种结构的最大优点是前三个关节不必支撑任何操作臂或负载的重量。这类结构最适合于执行平面内的任务。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208114401573.png" alt="SCARA操作臂"></p><h3 id="极坐标型"><a href="#极坐标型" class="headerlink" title="极坐标型"></a>极坐标型</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208114533938.png" alt="极坐标型操作臂"></p><h3 id="圆柱坐标型"><a href="#圆柱坐标型" class="headerlink" title="圆柱坐标型"></a>圆柱坐标型</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208114608229.png"></p><h2 id="位置检测"><a href="#位置检测" class="headerlink" title="位置检测"></a>位置检测</h2><ol><li>旋转光学编码器</li><li>旋转变压器</li><li>电位计</li><li>转速计</li></ol>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器人学导论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter7 轨迹生成</title>
      <link href="/2023/02/07/Learn/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6%E5%AF%BC%E8%AE%BA/Chapter7%20%E8%BD%A8%E8%BF%B9%E7%94%9F%E6%88%90/"/>
      <url>/2023/02/07/Learn/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6%E5%AF%BC%E8%AE%BA/Chapter7%20%E8%BD%A8%E8%BF%B9%E7%94%9F%E6%88%90/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="Chapter7-轨迹生成"><a href="#Chapter7-轨迹生成" class="headerlink" title="Chapter7 轨迹生成"></a>Chapter7 轨迹生成</h1><h2 id="关节空间的规划方法"><a href="#关节空间的规划方法" class="headerlink" title="关节空间的规划方法"></a>关节空间的规划方法</h2><h3 id="三次多项式"><a href="#三次多项式" class="headerlink" title="三次多项式"></a>三次多项式</h3><p>由初始值和最终值可得到对函数值的两个约束条件：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230207194244309.png"></p><p>在初始时刻和终止时刻关节速度为零：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230207194316528.png"></p><p>该三次多项式具有如下形式：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230207195506054.png"></p><p>解方程可得：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230207195540457.png"></p><p>但是该解仅适用于起始关节角速度与终止关节角速度均为零的情况。</p><h3 id="具有中间点的路径的三次多项式"><a href="#具有中间点的路径的三次多项式" class="headerlink" title="具有中间点的路径的三次多项式"></a>具有中间点的路径的三次多项式</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230207195856031.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230207195901363.png"></p><p>上式，可求出符合任何起始和终止位置以及任何起始和终止速度的三次多项式。</p><h3 id="高次多项式"><a href="#高次多项式" class="headerlink" title="高次多项式"></a>高次多项式</h3><p>如果要确定在路径曲线段的起始点和终止点的位置、速度和加速度，则需要用一个五次多项式进行插值，即：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230207203926123.png"></p><p>解方程可得：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230207203942341.png"></p><h3 id="带由抛物线过渡的线性函数"><a href="#带由抛物线过渡的线性函数" class="headerlink" title="带由抛物线过渡的线性函数"></a>带由抛物线过渡的线性函数</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230207220048119.png" alt="带有抛物线过渡的直线段"></p><h2 id="笛卡尔空间规划方法"><a href="#笛卡尔空间规划方法" class="headerlink" title="笛卡尔空间规划方法"></a>笛卡尔空间规划方法</h2><h3 id="笛卡尔直线运动"><a href="#笛卡尔直线运动" class="headerlink" title="笛卡尔直线运动"></a>笛卡尔直线运动</h3><h3 id="笛卡尔路径的几何问题"><a href="#笛卡尔路径的几何问题" class="headerlink" title="笛卡尔路径的几何问题"></a>笛卡尔路径的几何问题</h3><h4 id="1、无法到达中间点"><a href="#1、无法到达中间点" class="headerlink" title="1、无法到达中间点"></a>1、无法到达中间点</h4><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230207222006079.png"></p><h4 id="2、在奇异点附近关节速度增大"><a href="#2、在奇异点附近关节速度增大" class="headerlink" title="2、在奇异点附近关节速度增大"></a>2、在奇异点附近关节速度增大</h4><p>在操作臂的工作空间中存在某些位置，无法用有限的关节速度来实现末端执行器在笛卡尔空间中的期望速度。因此，有某些路径（在笛卡尔空间中描述）是操作臂所无法执行的。例如，一个操作臂沿笛卡尔直线路径接近某个奇异位形时，机器人的一个或多个关节可能激增至无穷大。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230207222043695.png"></p><h4 id="3、起始点和终止点有不同的解"><a href="#3、起始点和终止点有不同的解" class="headerlink" title="3、起始点和终止点有不同的解"></a>3、起始点和终止点有不同的解</h4><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230207222924982.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230207222915309.png" alt="图7-14"></p><h2 id="路径的实时生成"><a href="#路径的实时生成" class="headerlink" title="路径的实时生成"></a>路径的实时生成</h2><h3 id="关节空间路径的生成"><a href="#关节空间路径的生成" class="headerlink" title="关节空间路径的生成"></a>关节空间路径的生成</h3><p>在直线区段，对每个关节的轨迹计算如下：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230207223811161.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230207223842889.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230207223856636.png"></p><h3 id="笛卡尔空间路径的生成"><a href="#笛卡尔空间路径的生成" class="headerlink" title="笛卡尔空间路径的生成"></a>笛卡尔空间路径的生成</h3><p>使用符号x来表示笛卡尔位姿矢量的一个分量。</p><p>在曲线的直线区段，x中的每个自由度按下式计算：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230207223955659.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230207224010801.png"></p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器人学导论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter6 操作臂动力学</title>
      <link href="/2023/02/04/Learn/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6%E5%AF%BC%E8%AE%BA/Chapter6%20%E6%93%8D%E4%BD%9C%E8%87%82%E5%8A%A8%E5%8A%9B%E5%AD%A6/"/>
      <url>/2023/02/04/Learn/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6%E5%AF%BC%E8%AE%BA/Chapter6%20%E6%93%8D%E4%BD%9C%E8%87%82%E5%8A%A8%E5%8A%9B%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="Chapter6-操作臂动力学"><a href="#Chapter6-操作臂动力学" class="headerlink" title="Chapter6 操作臂动力学"></a>Chapter6 操作臂动力学</h1><h2 id="刚体的加速度"><a href="#刚体的加速度" class="headerlink" title="刚体的加速度"></a>刚体的加速度</h2><h3 id="线加速度"><a href="#线加速度" class="headerlink" title="线加速度"></a>线加速度</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230205164333594.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230205164348471.png"></p><h3 id="角加速度"><a href="#角加速度" class="headerlink" title="角加速度"></a>角加速度</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230205164434766.png"></p><h2 id="质量分布"><a href="#质量分布" class="headerlink" title="质量分布"></a>质量分布</h2><p>对于定轴旋转的情况，经常用到<strong>惯性矩</strong>这个概念。</p><p>在一个刚体绕任意轴做旋转运动时，我们需要一种能够表征刚体质量分布的方式。在这里，引入<strong>惯性张量</strong>。</p><p>坐标系{A}中的惯性张量可用3×3矩阵表示如下</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230205165112173.png"></p><p>各元素：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230205165125375.png" alt="、"></p><h2 id="牛顿方程和欧拉方程"><a href="#牛顿方程和欧拉方程" class="headerlink" title="牛顿方程和欧拉方程"></a>牛顿方程和欧拉方程</h2><p>如果知道了连杆质心的位置和惯性张量，那么它的质量分布特征就完全确定了。</p><p>连杆运动所需的力是关于连杆期望加速度及其质量分布的函数。</p><p>牛顿方程以及描述旋转运动的欧拉方程描述了力、惯量和加速度之间的关系。</p><h3 id="牛顿方程"><a href="#牛顿方程" class="headerlink" title="牛顿方程"></a>牛顿方程</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230205165304745.png"></p><h3 id="欧拉方程"><a href="#欧拉方程" class="headerlink" title="欧拉方程"></a>欧拉方程</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230205165319817.png"></p><h2 id="牛顿-欧拉递推动力学方程"><a href="#牛顿-欧拉递推动力学方程" class="headerlink" title="牛顿-欧拉递推动力学方程"></a>牛顿-欧拉递推动力学方程</h2><h3 id="牛顿-欧拉递推动力学算法"><a href="#牛顿-欧拉递推动力学算法" class="headerlink" title="牛顿-欧拉递推动力学算法"></a>牛顿-欧拉递推动力学算法</h3><p>对于转动关节来说，这个算法归纳如下：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230205170101776.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230205170114338.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230205170138047.png"></p><h3 id="考虑重力的动力学算法"><a href="#考虑重力的动力学算法" class="headerlink" title="考虑重力的动力学算法"></a>考虑重力的动力学算法</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230205170336208.png"></p><h2 id="操作臂动力学的拉格朗日方程"><a href="#操作臂动力学的拉格朗日方程" class="headerlink" title="操作臂动力学的拉格朗日方程"></a>操作臂动力学的拉格朗日方程</h2><p>牛顿-欧拉公式可以被认为是一种解决动力学问题的力平衡方法，而拉格朗日公式则是一种基于能量的动力学方法。</p><p>首先讨论操作臂动能的表达式。第i个连杆的动能k<del>i</del>可以表示为：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230205172901519.png"></p><p>式中第一项是基于连杆质心线速度的动能，第二项是连杆的角速度动能。</p><p>整个操作臂的动能是各个连杆功能之和，即：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230205172955433.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230207185335730.png"></p><p>拉格朗日动力学公式给出了一种从标量函数推导动力学方程的方法，我们称这个标量函数为拉格朗日函数，即一个机械系统的动能和势能的差值。这里，操作臂的拉格朗日函数表示为：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230207185715196.png"></p><p>则操作臂的运动方程为：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230207185749283.png"></p><p>这里，t是n×1的激励力矩矢量。对于操作臂来说，方程变为：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230207185822085.png"></p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器人学导论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter5 雅可比：速度与静力</title>
      <link href="/2023/02/02/Learn/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6%E5%AF%BC%E8%AE%BA/Chapter5%20%E9%9B%85%E5%8F%AF%E6%AF%94%EF%BC%9A%E9%80%9F%E5%BA%A6%E4%B8%8E%E9%9D%99%E5%8A%9B/"/>
      <url>/2023/02/02/Learn/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6%E5%AF%BC%E8%AE%BA/Chapter5%20%E9%9B%85%E5%8F%AF%E6%AF%94%EF%BC%9A%E9%80%9F%E5%BA%A6%E4%B8%8E%E9%9D%99%E5%8A%9B/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="Chapter5-雅可比：速度与静力"><a href="#Chapter5-雅可比：速度与静力" class="headerlink" title="Chapter5 雅可比：速度与静力"></a>Chapter5 雅可比：速度与静力</h1><h2 id="时变位置和姿态的符号表示"><a href="#时变位置和姿态的符号表示" class="headerlink" title="时变位置和姿态的符号表示"></a>时变位置和姿态的符号表示</h2><h3 id="位置矢量的导数"><a href="#位置矢量的导数" class="headerlink" title="位置矢量的导数"></a>位置矢量的导数</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230129111318491.png"></p><p>位置矢量的速度可以看出用位置矢量描述的空间一点的线速度。</p><p>如果相对于坐标系{B}，Q不随时间变化，那么速度就为零，尽管在其他一些坐标系中Q是变化的。因此必须说明的是一个矢量相对于哪个坐标系求导。</p><h3 id="角速度矢量"><a href="#角速度矢量" class="headerlink" title="角速度矢量"></a>角速度矢量</h3><p>^A^Ω<del>B</del>描述了坐标系{B}相对于坐标系{A}的旋转。</p><p>从物理意义上讲，方向就是{B}相对于{A}的瞬时旋转轴，大小表示旋转速率。</p><h2 id="刚体的线速度和角速度"><a href="#刚体的线速度和角速度" class="headerlink" title="刚体的线速度和角速度"></a>刚体的线速度和角速度</h2><h3 id="线速度"><a href="#线速度" class="headerlink" title="线速度"></a>线速度</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230129125351226.png"></p><p>求解坐标系{A}中的点Q的线速度是非常简单的。只要写出坐标系{A}中的两个速度分量，求其和为：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230129125441676.png"></p><h3 id="角速度"><a href="#角速度" class="headerlink" title="角速度"></a>角速度</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230129165443814.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230129165510017.png"></p><h2 id="对角速度的进一步研究"><a href="#对角速度的进一步研究" class="headerlink" title="对角速度的进一步研究"></a>对角速度的进一步研究</h2><h3 id="正交矩阵的性质"><a href="#正交矩阵的性质" class="headerlink" title="正交矩阵的性质"></a>正交矩阵的性质</h3><p>对于任何n*n正交矩阵R，有：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230129172404461.png"></p><p>对上式求导得：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230129172427335.png"></p><p>定义：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230129172517138.png"></p><p>有：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230129172533544.png"></p><p>S为反对称矩阵，因此正交阵的导数与反对称矩阵之间存在如下特性，可写为：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230129172642286.png"></p><h3 id="旋转参考系的点速度"><a href="#旋转参考系的点速度" class="headerlink" title="旋转参考系的点速度"></a>旋转参考系的点速度</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230129185335240.png"></p><h3 id="反对称矩阵和矢量叉积"><a href="#反对称矩阵和矢量叉积" class="headerlink" title="反对称矩阵和矢量叉积"></a>反对称矩阵和矢量叉积</h3><p>反对称矩阵S的各元素如下：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230129204755299.png"></p><p>容易证明：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230129205608664.png"></p><p>上述式子与式5.23联立可得：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230129211459122.png"></p><h3 id="角速度矢量的物理意义"><a href="#角速度矢量的物理意义" class="headerlink" title="角速度矢量的物理意义"></a>角速度矢量的物理意义</h3><p>角速度矢量Ω的物理意义是在任一时刻，旋转坐标系姿态的变化可以看作是绕某个轴K^的旋转。这个顺时旋转轴，可作为单位矢量，与绕这个轴的旋转速度标量(θ*)构成角速度矢量。</p><h2 id="连杆之间的速度“传递”"><a href="#连杆之间的速度“传递”" class="headerlink" title="连杆之间的速度“传递”"></a>连杆之间的速度“传递”</h2><p>连杆i+1的角速度相对于坐标系{i+1}的表达式：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230130154448332.png"></p><p>速度：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230130154523330.png"></p><p>对应关节i+1为移动关节时，相应的关系为：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230130154958247.png"></p><h2 id="雅可比"><a href="#雅可比" class="headerlink" title="雅可比"></a>雅可比</h2><p>可以将雅可比矩阵看成X中的速度向Y中速度的映射：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230202163734972.png"></p><p>在任一瞬间，X都有一个确定的值，J(X)是个线性变换。在每一个新时刻，如果X改变，线性变换也会随之而变。所以，雅可比是时变的线性变换。</p><p>雅可比矩阵的行数等于操作臂在笛卡尔空间中的自由度数量，雅可比矩阵的列数等于操作臂的关节数量。</p><p>在机器人学中，通常使用雅可比将关节速度与操作臂末端的笛卡尔速度联系起了，例如</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230204224512176.png"></p><h3 id="雅可比矩阵参考坐标系的变换"><a href="#雅可比矩阵参考坐标系的变换" class="headerlink" title="雅可比矩阵参考坐标系的变换"></a>雅可比矩阵参考坐标系的变换</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230202174342664.png"></p><h2 id="奇异性"><a href="#奇异性" class="headerlink" title="奇异性"></a>奇异性</h2><p>可逆矩阵又叫非奇异矩阵。如果线性变换矩阵是非奇异的，已知笛卡尔坐标系，就可以对矩阵求逆计算出关节的速度：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230204231223370.png"></p><p>大多数操作臂都有使得雅可比矩阵奇异的Θ值。这些位置就称为机构的奇异位形或简称奇异性。</p><p>当操作臂处于奇异位形时，它会失去一个或多个自由度。这也就是说，在笛卡尔空间的某个方向上，无论选择什么样的关节速度，都不能使机器人手臂运动。</p><h2 id="操作臂的静力"><a href="#操作臂的静力" class="headerlink" title="操作臂的静力"></a>操作臂的静力</h2><p>我们为相邻杆件所施加的力和力矩定义以下特殊的符号：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230205155041240.png"></p><p>连杆之间的静力传递表达式</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230205155009359.png"></p><p>为了平衡施加在连杆上的力和力矩，需要施加在关节上的力矩有多大？除了绕关节轴的力矩之外，力和力矩矢量的所有分量都可以由操作臂机构本身来平衡。因此，为求出保持系统静平衡的关节力矩，应计算关节轴矢量和施加在连杆上的力矩矢量的点乘：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230205160612487.png"></p><h2 id="力域中的雅可比"><a href="#力域中的雅可比" class="headerlink" title="力域中的雅可比"></a>力域中的雅可比</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230205161632020.png" alt="image-20230205161632020"></p><p>F是一个作用在末端执行器上的6×1维笛卡尔力-力矩矢量，t是6×1维关节力矩矢量。</p><p>上式说明：雅可比矩阵的转置将作用在手臂上的笛卡尔力映射成了等效关节力矩。</p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器人学导论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter 4 操作臂逆运动学</title>
      <link href="/2023/01/29/Learn/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6%E5%AF%BC%E8%AE%BA/Chapter4%20%E6%93%8D%E4%BD%9C%E8%87%82%E9%80%86%E8%BF%90%E5%8A%A8%E5%AD%A6/"/>
      <url>/2023/01/29/Learn/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6%E5%AF%BC%E8%AE%BA/Chapter4%20%E6%93%8D%E4%BD%9C%E8%87%82%E9%80%86%E8%BF%90%E5%8A%A8%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="Chapter4-操作臂逆运动学"><a href="#Chapter4-操作臂逆运动学" class="headerlink" title="Chapter4 操作臂逆运动学"></a>Chapter4 操作臂逆运动学</h1><h2 id="解的存在性"><a href="#解的存在性" class="headerlink" title="解的存在性"></a>解的存在性</h2><h3 id="操作臂的工作空间"><a href="#操作臂的工作空间" class="headerlink" title="操作臂的工作空间"></a>操作臂的工作空间</h3><p>简单地说，工作空间是操作臂末端执行器所能到达的范围。若要求解存在，则被指定的目标点必须在工作空间内。</p><p><strong>灵巧工作空间</strong>：机器人的末端执行器能够从各个方向到达的空间区域。</p><p><strong>可达工作空间</strong>：机器人至少从一个方向上可以到达的空间。</p><p>可见，灵巧工作空间是可达工作空间的子集。</p><h3 id="多解问题"><a href="#多解问题" class="headerlink" title="多解问题"></a>多解问题</h3><p>如图所示，到达同一个点可以有多种解。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230128174656415.png"></p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>我们把操作臂的全部求解方法分为两大类：<strong>封闭解</strong>和<strong>数值解</strong>。</p><p>下面主要讨论封闭解方法。在本章中，“封闭形式”意指基于解析形式的解法，或者对于不高于4次的多项式不用迭代便可完全求解。</p><p>可将封闭解的求解方法分为两类：<strong>代数法</strong>和<strong>几何法</strong>。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230128193455070.png"></p><h4 id="Pieper解法"><a href="#Pieper解法" class="headerlink" title="Pieper解法"></a>Pieper解法</h4><p>特殊解法</p><p><a href="https://zhuanlan.zhihu.com/p/106632144">机器人学——学习笔记11(Pieper’s Solution) - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器人学导论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter3 操作臂运动学</title>
      <link href="/2023/01/28/Learn/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6%E5%AF%BC%E8%AE%BA/Chapter3%20%E6%93%8D%E4%BD%9C%E8%87%82%E8%BF%90%E5%8A%A8%E5%AD%A6/"/>
      <url>/2023/01/28/Learn/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6%E5%AF%BC%E8%AE%BA/Chapter3%20%E6%93%8D%E4%BD%9C%E8%87%82%E8%BF%90%E5%8A%A8%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="Chapter3-操作臂运动学"><a href="#Chapter3-操作臂运动学" class="headerlink" title="Chapter3 操作臂运动学"></a>Chapter3 操作臂运动学</h1><h2 id="连杆的描述"><a href="#连杆的描述" class="headerlink" title="连杆的描述"></a>连杆的描述</h2><p>操作臂可以看成由一系列通过关节连接成运动链的刚体。我们将这些刚体称为连杆。当两个刚体之间的相对运动是两个平面相互之间的相对滑动时，连接相邻两个刚体的运动副称为低副。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230112172810077.png" alt="6种常见的低副关节"></p><p>为了确定末端执行器在三维空间的位置和姿态，操作臂至少需要6个关节。</p><p>三维空间中的任意两个轴之间的距离是固定的，即为两轴之间公垂线的长度。</p><p>如图，关节轴i-1和关节轴i之间公垂线的长度为a<del>i-1</del>，a<del>i-1</del>即为连杆长度。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230116220205755.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230116220623404.png"></p><h2 id="连杆连接的描述"><a href="#连杆连接的描述" class="headerlink" title="连杆连接的描述"></a>连杆连接的描述</h2><p>在研究机器人运动学时，仅需要考虑两个参数，这两个参数完全确定了所有连杆时如何连接的。</p><p>沿两个相邻连杆公共轴线方向的距离可以用一个参数描述，该参数称为连杆偏距，在关节轴i上的连杆偏距记为d<del>i</del> 。用另一个参数描述两相邻连杆绕公共轴线旋转的夹角，该参数称为关节角，记为Θ<del>i</del>。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230126114600090.png"></p><h2 id="连杆参数"><a href="#连杆参数" class="headerlink" title="连杆参数"></a>连杆参数</h2><p>因此，机器人的每个连杆都可以用4个运动学参数来描述，其中两个参数用于描述连杆本身，另两个参数用于描述连杆之间的连接关系。通常，对于转动关节，Θ<del>i</del>为关节变量，其他三个连杆参数是固定不变的；对于移动关节，d<del>i</del>为关节变量，其他三个连杆参数是固定不变的。这种用连杆参数描述机构运动关系的规则称为DH法。</p><h2 id="连杆坐标系的定义"><a href="#连杆坐标系的定义" class="headerlink" title="连杆坐标系的定义"></a>连杆坐标系的定义</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230128144122352.png"></p><h3 id="连杆参数在连杆坐标系中的表示方法"><a href="#连杆参数在连杆坐标系中的表示方法" class="headerlink" title="连杆参数在连杆坐标系中的表示方法"></a>连杆参数在连杆坐标系中的表示方法</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230128144235355.png"></p><h3 id="建立连杆坐标系的步骤"><a href="#建立连杆坐标系的步骤" class="headerlink" title="建立连杆坐标系的步骤"></a>建立连杆坐标系的步骤</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230128150718420.png"></p><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230128155509861.png"></p><h2 id="操作臂运动学"><a href="#操作臂运动学" class="headerlink" title="操作臂运动学"></a>操作臂运动学</h2><h3 id="连杆变换的推导"><a href="#连杆变换的推导" class="headerlink" title="连杆变换的推导"></a>连杆变换的推导</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230128165201317.png"></p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器人学导论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023.1.25 Note</title>
      <link href="/2023/01/25/Note/2023.1.25%E8%AE%B0/"/>
      <url>/2023/01/25/Note/2023.1.25%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="过年"><a href="#过年" class="headerlink" title="过年"></a>过年</h1><p>过年了过年了！</p><p>估摸有四五年没回家过年了。</p><p>今年终于back back。</p><h2 id="红包"><a href="#红包" class="headerlink" title="红包"></a>红包</h2><p>不知道从什么时候开始，我不喜欢收人家红包了。</p><p>可能是长大了吧，变得不好意思了。</p><h2 id="麻将"><a href="#麻将" class="headerlink" title="麻将"></a>麻将</h2><p>打了三回麻将，寄了三回。</p><p>我也不造啊，可能是我太菜了。</p><p>确实，没怎么打过。</p><p>手气也不怎么好。</p><h2 id="烟花"><a href="#烟花" class="headerlink" title="烟花"></a>烟花</h2><p>买了好多烟花，放了一个小时，累了。</p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230125144442885.png" alt="" style="zoom: 50%;" /><h2 id="吃饭"><a href="#吃饭" class="headerlink" title="吃饭"></a>吃饭</h2><p>吃了好多东西。</p><p>念念不忘的，还是一碗牛肉粿。</p><p>还有，烧烤。</p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230125145008883.png" alt="" style="zoom:50%;" /><h2 id="住宿"><a href="#住宿" class="headerlink" title="住宿"></a>住宿</h2><p>今年没回家里住。住在公寓宾馆。</p><p>挺好的，回老家不用带很多东西，也不用收拾了。</p><p>晚上太晚回家，老人也不用担心。</p><h2 id="小孩"><a href="#小孩" class="headerlink" title="小孩"></a>小孩</h2><p>不知不觉，我们都已经长大了。</p><p>两个堂姐都已经结婚，也有了小孩。</p><p>很可爱的。</p><h2 id="走亲戚"><a href="#走亲戚" class="headerlink" title="走亲戚"></a>走亲戚</h2><p>今年见了上百个亲戚，认识了好多人。</p><p>逃不了的问题。</p><p>多大了，工作没，在哪里读书……</p><p>别急。</p><h2 id="家"><a href="#家" class="headerlink" title="家"></a>家</h2><p>慢慢长大，越来越爱自己的家。</p><p>我的父母是十分善良的，和蔼的。</p><p>待人做事一直是我的榜样。</p><p>他们以身作则，教会了我很多。</p><p>我也要成为他们的骄傲。</p><p>有空多陪伴家人！家人是永远的依靠。</p>]]></content>
      
      
      <categories>
          
          <category> Diary </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Freertos基础知识</title>
      <link href="/2023/01/13/Learn/Freertos/FreeRTOS/"/>
      <url>/2023/01/13/Learn/Freertos/FreeRTOS/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="Freertos基础知识"><a href="#Freertos基础知识" class="headerlink" title="Freertos基础知识"></a>Freertos基础知识</h2><h3 id="什么是Freertos？"><a href="#什么是Freertos？" class="headerlink" title="什么是Freertos？"></a>什么是Freertos？</h3><p>​Free 就是免费的、RTOS 全称是 Real Time Operating System，中文名就是实时操作系统。可以看出 FreeROTS 就是一个免费的 RTOS 类系统。</p><p>​操作系统允许多个任务同时运行，这个叫做多任务，实际上，一个处理器核心在某一时刻只能运行一个任务。操作系统中任务调度器的责任就是决定在某一时刻究竟运行哪个任务，任务调度在各个任务之间的切换非常快！这就给人们造成了同一时刻有多个任务同时运行的错觉。</p><p>​FreeRTOS 由用户给每个任务分配一个任务优先级，任务调度器就可以根据此优先级来决定下一刻应该运行哪个任务。</p><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><h4 id="什么是多任务系统？"><a href="#什么是多任务系统？" class="headerlink" title="什么是多任务系统？"></a>什么是多任务系统？</h4><p>​回想一下我们以前在使用 51、STM32 单片机裸机(未使用系统)的时候一般都是在 main 函数里面用 while(1)做一个大循环来完成所有的处理，即应用程序是一个无限的循环，循环中调用相应的函数完成所需的处理。有时候我们也需要中断中完成一些处理。相对于多任务系统而言，这个就是单任务系统，也称作前后台系统，中断服务函数作为前台程序，大循环 while(1)作为后台程序。如图所示。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221003003311071.png"></p><p>​可以看到，前后台系统各个任务都是排队等着轮流执行，不管你这个程序现在有多紧急，没轮到你就只能等着！相当于所有任务的优先级都是一样的。</p><p>​FreeRTOS 是一个抢占式的实时多任务系统，那么其任务调度器也是抢占式的。如图所示。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221003003616795.png"></p><h4 id="任务状态"><a href="#任务状态" class="headerlink" title="任务状态"></a>任务状态</h4><ol><li>运行态<br>当一个任务正在运行时，那么就说这个任务处于运行态，处于运行态的任务就是当前正在使用处理器的任务。如果使用的是单核处理器的话那么不管在任何时刻永远都只有一个任务处于运行态。</li><li>就绪态<br>处于就绪态的任务是那些已经准备就绪(这些任务没有被阻塞或者挂起)，可以运行的任务， 但是处于就绪态的任务还没有运行，因为有一个同优先级或者更高优先级的任务正在运行！</li><li>阻塞态<br>如果一个任务当前正在等待某个外部事件的话就说它处于阻塞态，比如说如果某个任务调 用了函数 vTaskDelay()的话就会进入阻塞态，直到延时周期完成。任务在等待队列、信号量、事 件组、通知或互斥信号量的时候也会进入阻塞态。任务进入阻塞态会有一个超时时间，当超过 这个超时时间任务就会退出阻塞态，即使所等待的事件还没有来临！</li><li>挂起态<br>像阻塞态一样，任务进入挂起态以后也不能被调度器调用进入运行态，但是进入挂起态的 任务没有超时时间。任务进入和退出挂起态通过调用函数 vTaskSuspend()和 xTaskResume()。</li></ol><h4 id="任务优先级"><a href="#任务优先级" class="headerlink" title="任务优先级"></a>任务优先级</h4><p>​每个任务都可以分配一个从 0~(configMAX_PRIORITIES-1) 的优先级，宏 configMAX_PRIORITIES 不能超过 32！优先级数字越低表示任务的优先级越低，0 的优先级最低，configMAX_PRIORITIES-1 的优先级最高。空闲任务的优先级最低，为 0。 FreeRTOS 调度器确保处于就绪态或运行态的高优先级的任务获取处理器使用权，换句话说就是处于就绪态的最高优先级的任务才会运行。</p><p>​当宏 configUSE_TIME_SLICING 定义为 1 的时候多个任务可以共用一个优先级，数量不限。此时处于就绪态的优先级相同的任务就会使用时间片轮转调度器获取运行时间，一个时间片的长度就是滴答定时器的中断周期，由宏configTICK_RATE_HZ确定。</p><h4 id="任务堆栈"><a href="#任务堆栈" class="headerlink" title="任务堆栈"></a>任务堆栈</h4><p>​FreeRTOS 之所以能正确的恢复一个任务的运行就是因为有任务堆栈在保驾护航，任务调度器在进行任务切换的时候会将当前任务的现场(CPU 寄存器值等)保存在此任务的任务堆栈中， 等到此任务下次运行的时候就会先用堆栈中保存的值来恢复现场，恢复现场以后任务就会接着从上次中断的地方开始运行。</p><p>​基于RTOS的应用中，每个任务都拥有自己的<a href="https://so.csdn.net/so/search?q=%E5%A0%86%E6%A0%88&spm=1001.2101.3001.7020">堆栈</a>空间。堆栈设置过大，会造成内存资源浪费；设置过小，可能导致运行过程中的任务栈溢出，从而导致一些奇怪的系统行为。</p><p>​一般来说，任务堆栈可以从一个比较大的堆栈空间开始，如需进而开发出更高质量的代码：在运行时监视堆栈空间的使用情况，以查看应用程序运行一段时间后实际使用了多少堆栈空间。基于可视化分析，用户可以更清晰直观的掌握系统中内存的使用情况。</p><p><a href="https://strongerhuang.blog.csdn.net/article/details/125108922?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-125108922-blog-103144501.pc_relevant_3mothn_strategy_and_data_recovery&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-125108922-blog-103144501.pc_relevant_3mothn_strategy_and_data_recovery&utm_relevant_index=2">(46条消息) 如何设置RTOS任务的堆栈大小？_strongerHuang的博客-CSDN博客</a></p><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>​看个定义：<a href="https://zhuanlan.zhihu.com/p/81018602">算法一看就懂之「 队列 」 - 知乎 (zhihu.com)</a></p><p>​队列在这里是为了任务与任务、任务与中断之间的通信而准备的，可以在任务与任务、任务与中断之间传递消息，队列中可以存储有限的、大小固定的数据项目。任务与任务、任务与中断之间要交流的数据保存在队列中，叫做队列项目。队列所能保存的最大数据项目数量叫做队列的 长度，创建队列的时候会指定数据项目的大小和队列的长度。由于队列用来传递消息的，所以也称为消息队列。FreeRTOS 中的信号量的也是依据队列实现的。</p><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>​信号量是操作系统中重要的一部分，信号量一般用来进行资源管理和任务同步，FreeRTOS 中信号量又分为二值信号量、计数型信号量、互斥信号量和递归互斥信号量。</p><p>​详细了解请自己查资料。</p><h2 id="实战篇"><a href="#实战篇" class="headerlink" title="实战篇"></a>实战篇</h2><h3 id="在CubeMX上配置FreeRTOS"><a href="#在CubeMX上配置FreeRTOS" class="headerlink" title="在CubeMX上配置FreeRTOS"></a>在CubeMX上配置FreeRTOS</h3><p>（一）首先，像往常一样需要先设置RCC、SYS以及时钟树，这里不做详细介绍。</p><p>需要提醒一点的是：裸机的时钟源默认是SysTick，但是开启FreeRTOS后，FreeRTOS会占用SysTick，所以需要需要为其他总线提供另外的时钟源。具体步骤如下图（以TIM7例）</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221003013440220.png"></p><p>（二）开启FreeRTOS</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221003013556891.png"></p><blockquote><p>vTaskDelay：任务A每次延时都是从调用延时函数vTaskDelay()开始算起的，延时是相对于这一时刻开始的，所以叫做相对延时函数。如果执行任务A的过程中发生中断，那么任务A执行的周期就会变长，所以使用相对延时函数vTaskDelay()，不能周期性的执行任务A。 </p><p>vTaskDelayUntil：从调用函数vTaskDelayUntil()开始，每隔固定周期，任务B的主体代码就会被执行一次，即使任务B在执行过程中发生中断，也不会影响这个周期性，只是会缩短其它任务的执行时间。所以这个函数被称为绝对延时函数，它可以用于周期性的执行任务B的主体代码。</p></blockquote><p><strong>config parameters</strong>系统内核配置：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221003013959738.png"></p><h3 id="Keil中代码实现"><a href="#Keil中代码实现" class="headerlink" title="Keil中代码实现"></a>Keil中代码实现</h3><ol><li>创建任务</li></ol><p>创建任务函数：</p><pre><code>BaseType_t xTaskCreate(                        TaskFunction_t pxTaskCode,//函数指针，指向任务函数的入口                        const char * const pcName,//任务描述。主要用于调试                        const configSTACK_DEPTH_TYPE usStackDepth,//指定任务堆栈大小，能够支持的堆栈变量数量（堆栈深度），而字节数=堆栈深度*宽度（比如，在 16 位宽度的堆栈下，usStackDepth 定义为 100，则实际使用 200 字节堆栈存储空间）                        void * const pvParameters,//参数指针，当任务创建时，作为一个参数传递给任务，一般传进NULL                        UBaseType_t uxPriority,//任务优先级                        TaskHandle_t * const pxCreatedTask //回传句柄，创建任务后用这个句柄引用任务                      )</code></pre><p>应用举例：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;宏定义各任务的堆栈大小及优先级#define TASK1_STK_SIZE     128#define TASK1_TASK_PRIO    2#define TASK2_STK_SIZE     128#define TASK2_TASK_PRIO    1&#x2F;&#x2F;定义任务句柄TaskHandle_t    Task1_Handler;    TaskHandle_t    Task2_Handler;&#x2F;&#x2F;函数声明void task1_(void * arg);void task2_(void * arg);void System_Task_Init(void);&#x2F;&#x2F;任务创建void System_Task_Init(void)&#123;xTaskCreate(task1_, &quot;task1_&quot;, TASK1_STK_SIZE, NULL, TASK1_TASK_PRIO, &amp;Task1_Handler);xTaskCreate(task2_, &quot;task2_&quot;, TASK2_STK_SIZE, NULL, TASK2_TASK_PRIO, &amp;Task2_Handler);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.任务函数</p><pre class="line-numbers language-none"><code class="language-none">void task1_(void * arg)&#123;int i1 &#x3D; 0;vTaskSuspend(Task2_Handler);&#x2F;&#x2F;一的优先级高于二，先挂起二for(;;)&#123;i1++;printf(&quot;任务一已执行次数：%d\r\n&quot;, i1);vTaskDelay(1000);if(i1 &gt; 3)&#123; vTaskResume(Task2_Handler); &#125;&#x2F;&#x2F;当一执行4次之后解挂二&#125;&#125;void task2_(void * arg)&#123;int i2 &#x3D; 0;vTaskDelete(Task1_Handler);&#x2F;&#x2F;第一次运行二时删除一for(;;)&#123;i2++;printf(&quot;任务二已执行次数：%d\r\n&quot;, i2);vTaskDelay(1000);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.开启任务</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221003014555435.png"></p><blockquote><p>注意：</p><p>1.在任务调度器开启前创建任务：</p><p>初始化函数放在main函数MX_FREERTOS_Init()前面</p><p>2.在任务调度器开启后创建任务：</p><p>初始化函数放在 StartDefaultTask任务中。</p></blockquote><p>结果：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221003014528997.png"></p><h3 id="队列的使用"><a href="#队列的使用" class="headerlink" title="队列的使用"></a>队列的使用</h3><p>结构体定义</p><pre class="line-numbers language-none"><code class="language-none">typedef struct&#123;  uint8_t port_num;  uint16_t len;  void* address;&#125; USART_COB;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>·1、存储队列定义和初始化</p><pre class="line-numbers language-none"><code class="language-none">QueueHandle_t  USART_RxPort; &#x2F;&#x2F;全局变量USART_RxPort &#x3D; xQueueCreate(4,sizeof(USART_COB));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>原型：</p><p>xQueueHandle xQueueCreate( </p><p>unsigned portBASE_TYPE uxQueueLength,    &#x2F;&#x2F;队列中包含最大项目数量</p><p>unsigned portBASE_TYPE uxItemSize   &#x2F;&#x2F;队列中每个项目所需的字节数。</p><p>);</p></blockquote><p>2、定义回调函数</p><pre class="line-numbers language-none"><code class="language-none">uint32_t User_UART1_RxCpltCallback(uint8_t* Recv_Data, uint16_t ReceiveLen)&#123;  static USART_COB Usart_RxCOB;  &#x2F;&#x2F;Send To UART Receive Queue  if(USART_RxPort !&#x3D; NULL)  &#123;    Usart_RxCOB.port_num &#x3D; 1;    Usart_RxCOB.len      &#x3D; ReceiveLen;    Usart_RxCOB.address  &#x3D; Recv_Data;    xQueueSendFromISR(USART_RxPort,&amp;Usart_RxCOB,0); &#x2F;&#x2F;在中断中调用，需要中断保护版本，故此处不能用xQueueSend。  &#125;  return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>原型：</p><p>xQueueSendFromISR(</p><p>QueueHandle_t xQueue,   &#x2F;&#x2F;目标队列的句柄。</p><p>const void *pvItemToQueue,   &#x2F;&#x2F;发送数据的指针。</p><p>BaseType_t *pxHigherPriorityTaskWoken   </p><p>&#x2F;&#x2F;如果入队导致一个任务解锁，并且解锁的任务优先级高于当前被中断的任务，则将*pxHigherPriorityTaskWoken 设置成 pdTRUE。</p><p>);</p></blockquote><p>3、定义处理函数</p><pre class="line-numbers language-none"><code class="language-none">void Task_UsartRecieve(void *arg)&#123;   USART_COB Usart_RxCOB;   for(;;)  &#123;    &#x2F;* Usart Recevice Port *&#x2F;                                                                                                                                                                                                              if(xQueueReceive(USART_RxPort,&amp;Usart_RxCOB,portMAX_DELAY) &#x3D;&#x3D; pdPASS)      &#123;          &#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>原型：</p><p>xQueueReceive(</p><p>QueueHandle_t xQueue,&#x2F;&#x2F;被读队列的句柄。这个句柄即是调用 xQueueCreate() 创建该队列时的返回值。</p><p> void *pvBuffer,&#x2F;&#x2F;接收缓存指针。其指向一段内存区域，用于接收从队列中拷贝来的数据。</p><p> TickType_t xTicksToWait&#x2F;&#x2F;队列空时，阻塞超时的最大时间。如果该参数设置为 0，函数立刻返回。延时为 portMAX_DELAY 将导致任务无限阻塞。</p><p>);</p><p>返回值：队列项接收成功返回 pdTRUE，否则返回 pdFALSE。</p></blockquote><h1 id="上位机培训"><a href="#上位机培训" class="headerlink" title="上位机培训"></a>上位机培训</h1><h2 id="UpperMonitor库使用"><a href="#UpperMonitor库使用" class="headerlink" title="UpperMonitor库使用"></a>UpperMonitor库使用</h2><p>软件上位机：<a href="https://gitee.com/ennishsu/upper-monitor.git">https://gitee.com/ennishsu/upper-monitor.git</a></p><p>打开 ~.cpp 文件可以看到以下注释</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221003124726584.png"></p><p>1、</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;* Private variables ---------------------------------------------------------*&#x2F;extern moto_info_t motor_info;extern int target_speed;extern double kp;extern double ki;extern double kd;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：</p><p>uint8_t USART0_Sent_Choose_Data[9]&#x3D;{0,1,2,3,0,1,2,3,0};  此处也需要修改。需要观察n个数据就输入0-(n-1)，不足九位补齐九位。输入0-8也可。</p><p>2、</p><pre class="line-numbers language-none"><code class="language-none">void UpperMonitor_Sent_Choose(float * data)&#123;  uint8_t i;  for(i&#x3D;0;i&lt;Sent_Data_Num;i++)  &#123;    switch(USART0_Sent_Choose_Data[i])    &#123;      &#x2F;* ÒÔÏÂ²¿·ÖÓÃÓÚ¹Û²ì²ÎÊýÇúÏß *&#x2F;      case 0: data[i]&#x3D; motor_info.rotor_speed;          break;      case 1: data[i]&#x3D; target_speed;          break;      case 2: data[i]&#x3D; target_speed*1.05;         break;case 3: data[i]&#x3D; target_speed*0.95;         break;      default:break;  &#x2F;* ÒÔÉÏ²¿·ÖÓÃÓÚ¹Û²ì²ÎÊýÇúÏß *&#x2F;    &#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3、</p><pre class="line-numbers language-none"><code class="language-none">void PARAMETER_MODIFICATION(uint8_t * PARAMETER)&#123;  switch(PARAMETER[0])  &#123;    &#x2F;* ÒÔÏÂ²¿·ÖÓÃÓÚÐÞ¸Ä²ÎÊýÄÚÈÝ *&#x2F;case 0x00: kp &#x3D; PARAMETER_Change_float(PARAMETER+1);         break;case 0x01: ki &#x3D; PARAMETER_Change_float(PARAMETER+1); break;case 0x02: kd &#x3D; PARAMETER_Change_float(PARAMETER+1); break;&#x2F;* ÒÔÉÏ²¿·ÖÓÃÓÚÐÞ¸Ä²ÎÊýÄÚÈÝ *&#x2F;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4、在中断中</p><pre class="line-numbers language-none"><code class="language-none">#define BUFFERSIZE 255    &#x2F;&#x2F;可接收最大数据量extern uint8_t Rx_len,bootfirst;extern uint8_t ReceiveBuff[BUFFERSIZE]; &#x2F;&#x2F;接收缓存区void USART1_IRQHandler(void)&#123;  &#x2F;* USER CODE BEGIN USART1_IRQn 0 *&#x2F;  &#x2F;* USER CODE END USART1_IRQn 0 *&#x2F;  HAL_UART_IRQHandler(&amp;huart1);  &#x2F;* USER CODE BEGIN USART1_IRQn 1 *&#x2F;uint32_t temp;if(USART1 &#x3D;&#x3D; huart1.Instance)&#123;if(RESET !&#x3D; __HAL_UART_GET_FLAG(&amp;huart1,UART_FLAG_IDLE))&#x2F;&#x2F;如果串口1为空闲&#123;__HAL_UART_CLEAR_IDLEFLAG(&amp;huart1);&#x2F;&#x2F;清除中断标志位HAL_UART_DMAStop(&amp;huart1);&#x2F;&#x2F;停止DMA接收temp  &#x3D; __HAL_DMA_GET_COUNTER(&amp;hdma_usart1_rx);&#x2F;&#x2F;获取DMA当前还有多少未填充Rx_len &#x3D;  BUFFERSIZE - temp; &#x2F;&#x2F;计算串口接收到的数据个数RecHandle(ReceiveBuff,Rx_len);HAL_UART_Transmit_DMA(&amp;huart1,ReceiveBuff,Rx_len);&#x2F;&#x2F;发送数据Rx_len &#x3D; 0;&#x2F;&#x2F;接收数据长度清零HAL_UART_Receive_DMA(&amp;huart1,ReceiveBuff,BUFFERSIZE);&#x2F;&#x2F;开启下一次接收&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>5、在任务中调用</p><pre class="line-numbers language-none"><code class="language-none">Sent_Contorl(&amp;huart2);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="上位机界面使用"><a href="#上位机界面使用" class="headerlink" title="上位机界面使用"></a>上位机界面使用</h2><h3 id="上位机调参"><a href="#上位机调参" class="headerlink" title="上位机调参"></a>上位机调参</h3><p>1、打开临时指令指令表，修改变量名</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221010162048056.png"></p><p>2、打开上位机软件</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221003133231406.png"></p><h3 id="曲线显示"><a href="#曲线显示" class="headerlink" title="曲线显示"></a>曲线显示</h3><p>鼠标移到右上角，即可显示相关曲线</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221003133600904.png"></p><h3 id="光标调节"><a href="#光标调节" class="headerlink" title="光标调节"></a>光标调节</h3><p>右键黑屏，可以调出光标</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221003133629067.png"></p><h3 id="曲线横向放大-x2F-纵向放大"><a href="#曲线横向放大-x2F-纵向放大" class="headerlink" title="曲线横向放大&#x2F;纵向放大"></a>曲线横向放大&#x2F;纵向放大</h3><p>Shift+滚轮</p><p>Ctrl+滚轮</p><p>滚轮</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1]STM32F1 FreeRTOS开发手册  ALIENTEK</p><p>[2]FreeRTOS系列 CSDN：冬瓜~</p><p>[3]FreeRTOS学习笔记 by Tzrrr</p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter2 空间描述和变换</title>
      <link href="/2023/01/12/Learn/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6%E5%AF%BC%E8%AE%BA/Chapter2%20%E7%A9%BA%E9%97%B4%E6%8F%8F%E8%BF%B0%E5%92%8C%E5%8F%98%E6%8D%A2/"/>
      <url>/2023/01/12/Learn/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6%E5%AF%BC%E8%AE%BA/Chapter2%20%E7%A9%BA%E9%97%B4%E6%8F%8F%E8%BF%B0%E5%92%8C%E5%8F%98%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="Chapter2-空间描述和变换"><a href="#Chapter2-空间描述和变换" class="headerlink" title="Chapter2 空间描述和变换"></a>Chapter2 空间描述和变换</h1><h2 id="描述：位置、姿态与位姿"><a href="#描述：位置、姿态与位姿" class="headerlink" title="描述：位置、姿态与位姿"></a>描述：位置、姿态与位姿</h2><h3 id="位置描述"><a href="#位置描述" class="headerlink" title="位置描述"></a>位置描述</h3><p>^A^P,是指^A^P的元素数值是在坐标系{A}的轴线方向的距离。沿着坐标轴的每个距离可被认为是矢量在相应坐标轴上的投影。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230111162226899.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230111162731102.png"></p><h3 id="姿态描述"><a href="#姿态描述" class="headerlink" title="姿态描述"></a>姿态描述</h3><p>点的位置可用矢量描述，物体的姿态可用固定在物体上的坐标系来描述。</p><p>描述坐标系B的一种方法是利用坐标系A的三个主轴单位矢量来表示。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230111163604444.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230111163930715.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230111164141647.png"></p><h3 id="位姿描述"><a href="#位姿描述" class="headerlink" title="位姿描述"></a>位姿描述</h3><p>位置和姿态成对出现，我们将此组合称为位姿。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230111164544025.png"></p><h2 id="映射：从一个坐标系到另一个坐标系"><a href="#映射：从一个坐标系到另一个坐标系" class="headerlink" title="映射：从一个坐标系到另一个坐标系"></a>映射：从一个坐标系到另一个坐标系</h2><h3 id="坐标平移"><a href="#坐标平移" class="headerlink" title="坐标平移"></a>坐标平移</h3><p>平移下可用矢量^A^P<del>BORG</del>表示{B}的原点相对于{A}的位置。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230111175753238.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230111180730512.png"></p><h3 id="坐标旋转"><a href="#坐标旋转" class="headerlink" title="坐标旋转"></a>坐标旋转</h3><p>旋转矩阵各列的模均为1，并且这些单位矢量均相互正交。如前所述，可得：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230111181449677.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230111181941068.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230111184034737.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230111184354658.png"></p><p>上式进行了映射——它是矢量变换的描述——将空间某点相对于{B}的描述^B^P转换成了该点相对于{A}的描述^A^P。</p><h3 id="Example-2-1"><a href="#Example-2-1" class="headerlink" title="Example 2.1"></a>Example 2.1</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230111184858973.png"></p><h3 id="一般变换"><a href="#一般变换" class="headerlink" title="一般变换"></a>一般变换</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230111190906556.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230111191231909.png"></p><p>引入一个新概念：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230111191639010.png"></p><p>等效如下：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230111191647832.png"></p><p>容易看出该式可写成：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230111192833265.png"></p><h3 id="Example-2-2"><a href="#Example-2-2" class="headerlink" title="Example 2.2"></a>Example 2.2</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230111192931300.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230111192946168.png"></p><h2 id="算子：平移、旋转和变换"><a href="#算子：平移、旋转和变换" class="headerlink" title="算子：平移、旋转和变换"></a>算子：平移、旋转和变换</h2><h3 id="平移算子"><a href="#平移算子" class="headerlink" title="平移算子"></a>平移算子</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230111194615448.png"></p><h3 id="旋转算子"><a href="#旋转算子" class="headerlink" title="旋转算子"></a>旋转算子</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230111194710066.png"></p><h3 id="Example-2-3"><a href="#Example-2-3" class="headerlink" title="Example 2.3"></a>Example 2.3</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230111194738553.png"></p><h3 id="变换算子"><a href="#变换算子" class="headerlink" title="变换算子"></a>变换算子</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230111195524783.png"></p><p>跟上述式子相同。</p><h3 id="Example-2-4"><a href="#Example-2-4" class="headerlink" title="Example 2.4"></a>Example 2.4</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230111195637494.png"></p><h2 id="变换的计算"><a href="#变换的计算" class="headerlink" title="变换的计算"></a>变换的计算</h2><h3 id="复合变换"><a href="#复合变换" class="headerlink" title="复合变换"></a>复合变换</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230111200521027.png"></p><p>因此可得：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230111200641295.png"></p><h3 id="逆变换"><a href="#逆变换" class="headerlink" title="逆变换"></a>逆变换</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230111201148394.png"></p><p>如上，可以看到：R相对应的是矩阵的转置。T相对应的是矩阵的逆。</p><p><strong><u>特别注意位移部分</u></strong></p><h3 id="Example-2-5"><a href="#Example-2-5" class="headerlink" title="Example 2.5"></a>Example 2.5</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230112111313113.png"></p><h2 id="变换方程"><a href="#变换方程" class="headerlink" title="变换方程"></a>变换方程</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230112112822855.png"></p><p>没有什么特别的地方，跟上文差不多。变换的最后左边和右边上下标相同。</p><h2 id="其他姿态描述"><a href="#其他姿态描述" class="headerlink" title="其他姿态描述"></a>其他姿态描述</h2><h3 id="X-Y-Z固定角"><a href="#X-Y-Z固定角" class="headerlink" title="X-Y-Z固定角"></a>X-Y-Z固定角</h3><p>每次旋转都是绕着参考坐标系各轴的。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230112114043671.png" alt="条件前提"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230112114027343.png" alt="旋转矩阵"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230112114106015.png" alt="X-Y-Z旋转矩阵"></p><p>要记住这里给定的三个旋转顺序，仅当旋转是按照这个顺序进行时方程才是正确的。</p><p>旋转一般时不满足交换律的，即<img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230112114240450.png">二者是不同的。</p><p>常令人感兴趣的是逆问题，即从旋转矩阵等价推出X-Y-Z固定角。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230112114420312.png" alt="旋转矩阵求X-Y-Z固定角"></p><h3 id="Z-Y-X欧拉角"><a href="#Z-Y-X欧拉角" class="headerlink" title="Z-Y-X欧拉角"></a>Z-Y-X欧拉角</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230112115945625.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230112115955223.png" alt="前提条件"></p><p>每次都是绕运动坐标系{B}的各轴旋转而不是绕固定坐标系{A}的各轴旋转。这样三个一组的旋转被称为<strong>欧拉角</strong>。</p><p>由于三个旋转分别是绕着Z^^^、Y^^^、X^^^，所以称这种表示法为Z-Y-X欧拉角。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230112114855946.png" alt="Z-Y-X欧拉角"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230112114919928.png" alt="旋转矩阵"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230112114946855.png" alt="Z-Y-X旋转矩阵"></p><p><strong>注意：这个结果与以相反顺序绕固定轴旋转三次得到的结果完全相同！总之，这是一个不太直观的结果：三次绕固定轴旋转的最终姿态和以相反顺序绕运动坐标轴转动的最终姿态相同。</strong></p><h3 id="Z-Y-Z欧拉角"><a href="#Z-Y-Z欧拉角" class="headerlink" title="Z-Y-Z欧拉角"></a>Z-Y-Z欧拉角</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230112115919163.png" alt="前提条件"></p><p>按照推导，可得等价矩阵</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230112120053799.png" alt="旋转矩阵"></p><p>如果sinβ !&#x3D; 0，有</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230112120142270.png" alt="逆解"></p><h3 id="其他转角组合"><a href="#其他转角组合" class="headerlink" title="其他转角组合"></a>其他转角组合</h3><h4 id="等效角度-轴线表示法"><a href="#等效角度-轴线表示法" class="headerlink" title="等效角度-轴线表示法"></a>等效角度-轴线表示法</h4><p>略</p><h4 id="欧拉参数"><a href="#欧拉参数" class="headerlink" title="欧拉参数"></a>欧拉参数</h4><p>此处已做过讨论：[四元数与欧拉角与旋转矩阵](<a href="https://potzrrr.top/2023/01/11/%E5%9B%9B%E5%85%83%E6%95%B0%E4%B8%8E%E6%AC%A7%E6%8B%89%E8%A7%92%E4%B8%8E%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5/">四元数与欧拉角与旋转矩阵 | ZRong’s Blog (potzrrr.top)</a>)</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230112120330489.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230112120459255.png" alt="四维超球面"></p><p>这个关系总是保持不变。因此，姿态可以看作是四维空间中单位超球面上的一点。</p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器人学导论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kalman Filter</title>
      <link href="/2023/01/11/Learn/%E7%AE%97%E6%B3%95/Kalman%20Filter/"/>
      <url>/2023/01/11/Learn/%E7%AE%97%E6%B3%95/Kalman%20Filter/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="Kalman-Filter"><a href="#Kalman-Filter" class="headerlink" title="Kalman Filter"></a>Kalman Filter</h1><p>Learn by DR_CAN</p><h2 id="Part1-Recursive-Algorithm-递归算法"><a href="#Part1-Recursive-Algorithm-递归算法" class="headerlink" title="Part1 Recursive Algorithm 递归算法"></a>Part1 Recursive Algorithm 递归算法</h2><h3 id="1-1-一句话概括"><a href="#1-1-一句话概括" class="headerlink" title="1.1 一句话概括"></a>1.1 一句话概括</h3><p>Optimal Recursive Data Processing Algorithm 最优化递归数字处理算法</p><h3 id="1-2-不确定性"><a href="#1-2-不确定性" class="headerlink" title="1.2 不确定性"></a>1.2 不确定性</h3><ul><li>不存在完美的数学模型</li><li>系统的扰动不可控，也很难建模</li><li>测量传感器存在误差</li></ul><h3 id="1-3-Example"><a href="#1-3-Example" class="headerlink" title="1.3 Example"></a>1.3 Example</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20220913220448956.png"></p><p><strong>由上式可知，随着k的增加，测量结果不再重要。</strong></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20220913220418191.png"></p><h3 id="1-4-Step"><a href="#1-4-Step" class="headerlink" title="1.4 Step"></a>1.4 Step</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20220914170031982.png"></p><h2 id="Part2-Data-Fusion-数据融合"><a href="#Part2-Data-Fusion-数据融合" class="headerlink" title="Part2 Data Fusion 数据融合"></a>Part2 Data Fusion 数据融合</h2><h3 id="1-1-Example"><a href="#1-1-Example" class="headerlink" title="1.1 Example"></a>1.1 Example</h3><p>Use math to solve a ploblem which has two sets of data.</p><p>假设有两把秤，测重量。</p><p>其中一把秤得到30g，已知其标准差为2g；另一把秤得到32g，标准差为4g。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20220914202400147.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20220914202448915.png"></p><h3 id="1-2-Covariance-Matrix-协方差矩阵"><a href="#1-2-Covariance-Matrix-协方差矩阵" class="headerlink" title="1.2 Covariance Matrix 协方差矩阵"></a>1.2 Covariance Matrix 协方差矩阵</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20220914210137551.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20220914210229505.png"></p><h3 id="1-3-State-Space-Representation"><a href="#1-3-State-Space-Representation" class="headerlink" title="1.3 State Space Representation"></a>1.3 State Space Representation</h3><p><strong>见现代控制理论状态空间方程的表示。</strong></p><h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20220914210510464.png"></h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20220914210749768.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20220914211339976.png"></p><h2 id="Part3-Step-by-Step-Derivation-of-Kalman-Gain"><a href="#Part3-Step-by-Step-Derivation-of-Kalman-Gain" class="headerlink" title="Part3 Step by Step Derivation of Kalman Gain"></a>Part3 Step by Step Derivation of Kalman Gain</h2><p><a href="https://www.bilibili.com/video/BV1hC4y1b7K7?spm_id_from=333.999.0.0&vd_source=dc5a7d7190173a321a8ae3df82a10d84">【卡尔曼滤波器】3_卡尔曼增益超详细数学推导 ～全网最完整_哔哩哔哩_bilibili</a></p><p><u><strong>跟着学一遍</strong></u></p><h3 id="1-1-建立状态空间方程"><a href="#1-1-建立状态空间方程" class="headerlink" title="1.1 建立状态空间方程"></a>1.1 建立状态空间方程</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20220915191708100.png"></p><h3 id="1-2-寻找增益k值，使得方差最小"><a href="#1-2-寻找增益k值，使得方差最小" class="headerlink" title="1.2 寻找增益k值，使得方差最小"></a>1.2 寻找增益k值，使得方差最小</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20220916001619736.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20220916001603500.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20220916002220270.png"></p><h2 id="Part4-Priori-x2F-Posterrori-Error-Covariance-Matrix-先验-x2F-后验误差协方差矩阵"><a href="#Part4-Priori-x2F-Posterrori-Error-Covariance-Matrix-先验-x2F-后验误差协方差矩阵" class="headerlink" title="Part4 Priori&#x2F;Posterrori Error Covariance Matrix 先验&#x2F;后验误差协方差矩阵"></a>Part4 Priori&#x2F;Posterrori Error Covariance Matrix 先验&#x2F;后验误差协方差矩阵</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20220917005157630.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20220917004952941.png"></p><h2 id="Part5-An-Example"><a href="#Part5-An-Example" class="headerlink" title="Part5 An Example"></a>Part5 An Example</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20220917010043597.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20220917011807619.png"></p><h3 id="如果测量误差小"><a href="#如果测量误差小" class="headerlink" title="如果测量误差小"></a>如果测量误差小</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20220917011914629.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20220917011853695.png"></p><h3 id="如果测量误差大"><a href="#如果测量误差大" class="headerlink" title="如果测量误差大"></a>如果测量误差大</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20220917012021251.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20220917012032856.png"></p><h2 id="Part6-Extended-Kalman-Filter-扩展卡尔曼滤波器"><a href="#Part6-Extended-Kalman-Filter-扩展卡尔曼滤波器" class="headerlink" title="Part6 Extended Kalman Filter 扩展卡尔曼滤波器"></a>Part6 Extended Kalman Filter 扩展卡尔曼滤波器</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20220917012759494.png"></p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cubeide移植到vscode</title>
      <link href="/2023/01/11/Learn/%E6%9D%82/cubeide%E7%A7%BB%E6%A4%8D%E5%88%B0vscode/"/>
      <url>/2023/01/11/Learn/%E6%9D%82/cubeide%E7%A7%BB%E6%A4%8D%E5%88%B0vscode/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="1、首先用vscode打开工程文件夹"><a href="#1、首先用vscode打开工程文件夹" class="headerlink" title="1、首先用vscode打开工程文件夹"></a>1、首先用vscode打开工程文件夹</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230106104756153.png"></p><h2 id="2、按ctrl-P，输入-gt-c-x2F-c-，选择第一个，Edit-Configurations-UI"><a href="#2、按ctrl-P，输入-gt-c-x2F-c-，选择第一个，Edit-Configurations-UI" class="headerlink" title="2、按ctrl+P，输入&gt;c&#x2F;c++，选择第一个，Edit Configurations(UI)"></a>2、按ctrl+P，输入&gt;c&#x2F;c++，选择第一个，Edit Configurations(UI)</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230106105124576.png"></p><h2 id="3、打开左边json文件"><a href="#3、打开左边json文件" class="headerlink" title="3、打开左边json文件"></a>3、打开左边json文件</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230106110828297.png"></p><h2 id="4、配置代码如下"><a href="#4、配置代码如下" class="headerlink" title="4、配置代码如下"></a>4、配置代码如下</h2><pre class="line-numbers language-none"><code class="language-none">&#123;    &quot;configurations&quot;: [        &#123;            &quot;name&quot;: &quot;STM32&quot;,            &quot;includePath&quot;: [                &quot;$&#123;workspaceFolder&#125;&#x2F;**&quot;,                     &quot;$&#123;workspaceFolder&#125;&#x2F;Drivers&#x2F;STM32F7xx_HAL_Driver&#x2F;Inc&#x2F;&quot;,                &quot;$&#123;workspaceFolder&#125;&#x2F;Drivers&#x2F;STM32F7xx_HAL_Driver&#x2F;Inc&#x2F;Legacy&#x2F;&quot;,                &quot;$&#123;workspaceFolder&#125;&#x2F;Drivers&#x2F;CMSIS&#x2F;Device&#x2F;ST&#x2F;STM32F7xx&#x2F;Include&#x2F;&quot;,                &quot;$&#123;workspaceFolder&#125;&#x2F;Drivers&#x2F;CMSIS&#x2F;Include&#x2F;&quot;,                &quot;$&#123;workspaceFolder&#125;&#x2F;USER&#x2F;drivers&#x2F;&quot;,                &quot;$&#123;workspaceFolder&#125;&#x2F;Core&#x2F;Inc&#x2F;&quot;,                &quot;$&#123;workspaceFolder&#125;&#x2F;Middlewares&#x2F;Third_Party&#x2F;FreeRTOS&#x2F;Source&#x2F;include&#x2F;&quot;,                &quot;$&#123;workspaceFolder&#125;&#x2F;Middlewares&#x2F;Third_Party&#x2F;FreeRTOS&#x2F;Source&#x2F;CMSIS_RTOS_V2&#x2F;&quot;,                &quot;$&#123;workspaceFolder&#125;&#x2F;Middlewares&#x2F;Third_Party&#x2F;FreeRTOS&#x2F;Source&#x2F;portable&#x2F;GCC&#x2F;ARM_CM7&#x2F;r0p1&#x2F;&quot;,                &quot;$&#123;workspaceFolder&#125;&#x2F;USER&#x2F;drivers&quot;,                &quot;$&#123;workspaceFolder&#125;&#x2F;USER&#x2F;modules&quot;,                &quot;$&#123;workspaceFolder&#125;&#x2F;eigen3&#x2F;Eigen&quot;,                &quot;D:&#x2F;ST&#x2F;STM32CubeIDE_1.5.0&#x2F;STM32CubeIDE&#x2F;plugins&#x2F;com.st.stm32cube.ide.mcu.externaltools.gnu-tools-for-stm32.7-2018-q2-update.win32_1.5.0.202011040924&#x2F;tools&#x2F;arm-none-eabi&#x2F;include&#x2F;**&quot;,                &quot;D:&#x2F;ST&#x2F;STM32CubeIDE_1.5.0&#x2F;STM32CubeIDE&#x2F;plugins&#x2F;com.st.stm32cube.ide.mcu.externaltools.gnu-tools-for-stm32.7-2018-q2-update.win32_1.5.0.202011040924&#x2F;tools&#x2F;lib&#x2F;gcc&#x2F;arm-none-eabi&#x2F;7.3.1&#x2F;include&#x2F;**&quot;            ],            &quot;defines&quot;: [                &quot;__CC_ARM&quot;,                &quot;USE_HAL_DRIVER&quot;,                &quot;STM32F767xx&quot;,            ],            &quot;compilerPath&quot;: &quot;D:\\ST\\STM32CubeIDE_1.5.0\\STM32CubeIDE\\plugins\\com.st.stm32cube.ide.mcu.externaltools.gnu-tools-for-stm32.7-2018-q2-update.win32_1.5.0.202011040924\\tools\\arm-none-eabi\\include\\machine\\_default_types.h&quot;,            &quot;cStandard&quot;: &quot;c99&quot;,            &quot;cppStandard&quot;: &quot;c++11&quot;,            &quot;intelliSenseMode&quot;: &quot;$&#123;default&#125;&quot;        &#125;    ],    &quot;version&quot;: 4&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意修改几个地方，如下所示</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230106142814849.png"></p><h3 id="此处踩坑！坑如下"><a href="#此处踩坑！坑如下" class="headerlink" title="此处踩坑！坑如下"></a>此处踩坑！坑如下</h3><h4 id="1、uint32-t"><a href="#1、uint32-t" class="headerlink" title="1、uint32_t"></a>1、uint32_t</h4><p>解决方案：添加_CC_ARM如图</p><h4 id="2、LL库报错"><a href="#2、LL库报错" class="headerlink" title="2、LL库报错"></a>2、LL库报错</h4><p>理由是添加了USE_FULL_LL_DRIVER</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230106142951618.png"></p><p>注意，不能加！</p><h4 id="3、没有stdint-h-stddef-h文件"><a href="#3、没有stdint-h-stddef-h文件" class="headerlink" title="3、没有stdint.h   stddef.h文件"></a>3、没有stdint.h   stddef.h文件</h4><p>问题原因：这个是ide本身的文件，Workspace里没有，要手动添加</p><p>解决方案：找到电脑中文件的位置，添加路径</p><p>“D:&#x2F;ST&#x2F;STM32CubeIDE_1.5.0&#x2F;STM32CubeIDE&#x2F;plugins&#x2F;com.st.stm32cube.ide.mcu.externaltools.gnu-tools-for-stm32.7-2018-q2-update.win32_1.5.0.202011040924&#x2F;tools&#x2F;arm-none-eabi&#x2F;include&#x2F;“,<br> “D:&#x2F;ST&#x2F;STM32CubeIDE_1.5.0&#x2F;STM32CubeIDE&#x2F;plugins&#x2F;com.st.stm32cube.ide.mcu.externaltools.gnu-tools-for-stm32.7-2018-q2-update.win32_1.5.0.202011040924&#x2F;tools&#x2F;lib&#x2F;gcc&#x2F;arm-none-eabi&#x2F;7.3.1&#x2F;include&#x2F;“</p><h2 id="正常移植到此完美结束"><a href="#正常移植到此完美结束" class="headerlink" title="正常移植到此完美结束"></a>正常移植到此完美结束</h2>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多旋翼飞行器控制与设计</title>
      <link href="/2023/01/11/Learn/UAV/%E5%A4%9A%E6%97%8B%E7%BF%BC%E9%A3%9E%E8%A1%8C%E5%99%A8%E6%8E%A7%E5%88%B6%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
      <url>/2023/01/11/Learn/UAV/%E5%A4%9A%E6%97%8B%E7%BF%BC%E9%A3%9E%E8%A1%8C%E5%99%A8%E6%8E%A7%E5%88%B6%E4%B8%8E%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="动态模型和参数测量"><a href="#动态模型和参数测量" class="headerlink" title="动态模型和参数测量"></a>动态模型和参数测量</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221019163939091.png"></p><h3 id="刚体运动学模型"><a href="#刚体运动学模型" class="headerlink" title="刚体运动学模型"></a>刚体运动学模型</h3><p>运动学与质量和受力无关，只研究位置、速度、姿态和角速度等变量。</p><p>输入为速度和角速度，输出为位置和姿态。</p><h4 id="欧拉角模型"><a href="#欧拉角模型" class="headerlink" title="欧拉角模型"></a>欧拉角模型</h4><h4 id="旋转矩阵模型"><a href="#旋转矩阵模型" class="headerlink" title="旋转矩阵模型"></a>旋转矩阵模型</h4><h4 id="四元数模型"><a href="#四元数模型" class="headerlink" title="四元数模型"></a>四元数模型</h4><h3 id="刚体动力学模型"><a href="#刚体动力学模型" class="headerlink" title="刚体动力学模型"></a>刚体动力学模型</h3><p>动力学既涉及运动又涉及受力情况，与物体的质量和转动惯量有关。</p><p>输入为拉力和力矩（俯仰力矩、滚转力矩和偏航力矩），输出为速度和角速度。</p><h4 id="位置运动学模型"><a href="#位置运动学模型" class="headerlink" title="位置运动学模型"></a>位置运动学模型</h4><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221021152223230.png"></p><p>进一步，可以得到</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221021152245888.png"></p><p>f表示螺旋桨拉力总大小，g为重力加速度</p><h4 id="姿态动力学模型"><a href="#姿态动力学模型" class="headerlink" title="姿态动力学模型"></a>姿态动力学模型</h4><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221021152307960.png"></p><p>Ga表示陀螺力矩，t表示螺旋桨在机体轴上产生的力矩。</p><h3 id="多旋翼飞行控制刚体模型"><a href="#多旋翼飞行控制刚体模型" class="headerlink" title="多旋翼飞行控制刚体模型"></a>多旋翼飞行控制刚体模型</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221021152006578.png"></p><h3 id="控制效率模型"><a href="#控制效率模型" class="headerlink" title="控制效率模型"></a>控制效率模型</h3><p>输入是螺旋桨转速，输出是拉力和力矩。</p><p>控制效率模型的逆过程成为控制分配模型，即当通过控制器设计得到期望的拉力和力矩时，可以通过控制分配模型解出所需的螺旋桨转速。</p><h4 id="单个螺旋桨拉力和反扭距模型"><a href="#单个螺旋桨拉力和反扭距模型" class="headerlink" title="单个螺旋桨拉力和反扭距模型"></a>单个螺旋桨拉力和反扭距模型</h4><p>当多旋翼在无风情况下悬停时，其螺旋桨拉力表示为：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221021152934201.png"></p><p>其中，<img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221021152954025.png">。</p><p>反扭矩大小静态模型表示为：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221021153023683.png"></p><p>其中，<img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221021153102833.png">。</p><p>反扭距大小动态模型：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221021153218027.png"></p><h4 id="拉力和力矩模型"><a href="#拉力和力矩模型" class="headerlink" title="拉力和力矩模型"></a>拉力和力矩模型</h4><p>作用在四旋翼上的总拉力：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221021153323008.png"></p><p>对于**<u>十字形四旋翼</u>**，螺旋桨产生的力矩为：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221021153350931.png"></p><p>于是，联立以上两式有：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221021153419530.png"></p><p>对于**<u>X字形四旋翼</u>**，螺旋桨产生的力矩为：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221021153842065.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221021153854395.png"></p><p>对于**<u>多旋翼</u>**：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221021172735390.png"></p><h3 id="动力单元模型"><a href="#动力单元模型" class="headerlink" title="动力单元模型"></a>动力单元模型</h3><p>动力单元是以无刷直流电机、电调和螺旋桨为一组的整个动力机构。</p><p>输入是油门指令，输出是螺旋桨拉力的模型。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221022101946961.png"></p><p>完整的动力单元模型如下：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221022102209331.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221022103551683.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221022103609861.png" alt="image-20221022103609861"></p><blockquote><p>一阶低通滤波：</p><p><a href="https://zhuanlan.zhihu.com/p/42935576">一阶低通滤波（LPF）的原理及应用（以APM&#x2F;PX4飞控为例） - 知乎 (zhihu.com)</a></p></blockquote><h3 id="桨叶挥舞"><a href="#桨叶挥舞" class="headerlink" title="桨叶挥舞"></a>桨叶挥舞</h3><p>桨叶挥舞是旋转桨叶的上下运动。如图所示，逆风飞行的前行桨叶会获得更大的相对速度，而速度增加将产生更大的拉力，同时产生向上挥舞速度。向上挥舞速度会减小迎角，进而减小拉力。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221023093815547.png"></p><h2 id="传感器"><a href="#传感器" class="headerlink" title="传感器"></a>传感器</h2><h3 id="三轴加速度计"><a href="#三轴加速度计" class="headerlink" title="三轴加速度计"></a>三轴加速度计</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221012155505721.png"></p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>当加速度计保持静止时，加速度计能够感知重力加速度，而整体加速度为零</li><li>在自由落体运动中，整体加速度就是重力加速度，但加速度计内部处于失重状态，而此时三轴加速度计输出为零</li><li>在自由落体运动中，三轴加速度计的输出并不是它的真实加速度，而是它的加速度去掉重力后的整体加速度。因此，三轴加速度计可以测量物体的比力。</li></ul><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221012160117959.png"></p><p>加速度计能够精确的测量俯仰角和滚转角，且没有累计误差。</p><h4 id="MEMS三轴加速度计"><a href="#MEMS三轴加速度计" class="headerlink" title="MEMS三轴加速度计"></a>MEMS三轴加速度计</h4><p>采用压阻式、压电式和电容式工作原理，产生的比力分别正比于电阻、电压和电容的变化。</p><p>这种变化可以通过相应<strong>放大</strong>和<strong>滤波</strong>电路进行采集。</p><ul><li>缺点：受振动影响较大。</li><li>优点：可以做到很小</li></ul><h4 id="校正"><a href="#校正" class="headerlink" title="校正"></a>校正</h4><p>（1）校正</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221012162158405.png"></p><p>（2）自动校正</p><p>一般校正：需要外部标定设备，麻烦但精确</p><p>自动校正：不需要外部标定设备，简单 ，精度略微差</p><h5 id="误差模型"><a href="#误差模型" class="headerlink" title="误差模型"></a>误差模型</h5><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221012211946087.png"></p><p> <img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221012215248194.png"></p><h5 id="测量模型"><a href="#测量模型" class="headerlink" title="测量模型"></a>测量模型</h5><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221012220347761.png"></p><blockquote><p>何为高斯白噪声？</p><p>百度百科上解释为“<strong>高斯白噪声，幅度分布服从高斯分布，功率谱密度服从均匀分布</strong>”。</p><p>白噪声，如同白光一样，是所有颜色的光叠加而成，不同颜色的光本质区别是的它们的频率各不相同（如红色光波长长而频率低，相应的，紫色光波长短而频率高）。白噪声在功率谱上（若以频率为横轴，信号幅度的平方为功率）趋近为常值，即噪声频率丰富，在整个频谱上都有成分，即从低频到高频，<strong>低频指的是信号不变或缓慢变化，高频指的是信号突变</strong>。</p><p>白噪声信号是“随机”的。</p><p>那么，回到文章开头的解释：<strong>高斯白噪声，幅度分布服从高斯分布，功率谱密度服从均匀分布。</strong>它的意义就很明确了，上半句是从空域(幅值)角度描述“高斯噪声”，而下半句是从频域角度描述“白噪声”。</p></blockquote><blockquote><p>为什么产生漂移？</p><p>大部分MEMS均是以半导体材料为基础加工的，半导体对温度敏感，再加上安装、电路设计等因素的影响。</p></blockquote><h3 id="三轴陀螺仪"><a href="#三轴陀螺仪" class="headerlink" title="三轴陀螺仪"></a>三轴陀螺仪</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>MEMS三轴陀螺仪用到的一个基本的物理原理：科里奥利力</p><p> <img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221013155545058.png"></p><p>在陀螺仪中，两个质量块运动的速度方向相反，大小相同，如图所示。</p><p>从而产生的科里奥利力方向相反，压迫两块对应的电容板移动，产生电容差分变化，电容的变化正比于旋转的角速度。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221013160705853.png"></p><ul><li>电容的变化正比于旋转角速度</li><li>纯加速度并不能使陀螺仪产生读数</li></ul><h4 id="校正-1"><a href="#校正-1" class="headerlink" title="校正"></a>校正</h4><h5 id="误差模型-1"><a href="#误差模型-1" class="headerlink" title="误差模型"></a>误差模型</h5><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221013161722841.png"></p><h5 id="校正方法"><a href="#校正方法" class="headerlink" title="校正方法"></a>校正方法</h5><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221013163003155.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221013164814176.png"></p><blockquote><p>龙格库塔法</p></blockquote><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221014155923500.png"></p><h5 id="测量模型-1"><a href="#测量模型-1" class="headerlink" title="测量模型"></a>测量模型</h5><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221014155641676.png"></p><h3 id="三轴磁力计"><a href="#三轴磁力计" class="headerlink" title="三轴磁力计"></a>三轴磁力计</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221014164233288.png"></p><h3 id="超声波测距仪"><a href="#超声波测距仪" class="headerlink" title="超声波测距仪"></a>超声波测距仪</h3><p>超声波是一种频率超出人耳听觉频率的声波，大于20kHz。具有良好的方向性和强大的穿透性。</p><h3 id="气压计"><a href="#气压计" class="headerlink" title="气压计"></a>气压计</h3><p>如果多旋翼悬停高度距离地面过大，超声波测距仪就会失效，这时应当使用气压计。</p><h2 id="可观性和卡尔曼滤波器"><a href="#可观性和卡尔曼滤波器" class="headerlink" title="可观性和卡尔曼滤波器"></a>可观性和卡尔曼滤波器</h2><p>略</p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UAV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>涵道无人机建模</title>
      <link href="/2023/01/11/Learn/UAV/%E6%B6%B5%E9%81%93%EF%BC%9A%E6%B6%B5%E9%81%93%E6%97%A0%E4%BA%BA%E6%9C%BA%E5%BB%BA%E6%A8%A1/"/>
      <url>/2023/01/11/Learn/UAV/%E6%B6%B5%E9%81%93%EF%BC%9A%E6%B6%B5%E9%81%93%E6%97%A0%E4%BA%BA%E6%9C%BA%E5%BB%BA%E6%A8%A1/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="无人机建模及运动方程"><a href="#无人机建模及运动方程" class="headerlink" title="无人机建模及运动方程"></a>无人机建模及运动方程</h2><h3 id="坐标系定义及运动方程"><a href="#坐标系定义及运动方程" class="headerlink" title="坐标系定义及运动方程"></a>坐标系定义及运动方程</h3><h4 id="坐标系定义"><a href="#坐标系定义" class="headerlink" title="坐标系定义"></a>坐标系定义</h4><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230108103216237.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230108103159942.png" alt="-"></p><p>坐标如图所示：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230108103712962.png"></p><h4 id="运动学方程"><a href="#运动学方程" class="headerlink" title="运动学方程"></a>运动学方程</h4><p>六自由度刚体的运动学方程：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230108102927616.png"></p><p>旋转矩阵的导数：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230108103007669.png"></p><h4 id="动力学方程"><a href="#动力学方程" class="headerlink" title="动力学方程"></a>动力学方程</h4><p>动量定理和角动量定理只有在惯性系(NED系)中才成立，因此在非惯性系(机体系)中表示的动力学方程需要通过旋转变换得到。</p><p>在NED系中由动量定理，有</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230108105110754.png"></p><p>其实，G&#x3D;mg为无人机所受重力，F为除重力外其他力的矢量和。</p><p>在非惯性系下表示该方程：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230108105210913.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230108105220625.png"></p><p>代入NED系动量定理，可得</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230108105227121.png"></p><p>欧拉动力学方程：</p><p>惯性张量在NED中的表示是一个变量，而在机体系中的表示是一个常量，因此旋转动力学方程一般在机体系中表示。</p><p>推导见论文P24</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230108112255632.png"></p><p>整理合并，得涵道无人机得非线性模型：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230108113242454.png"></p><h2 id="单涵道动力学分析"><a href="#单涵道动力学分析" class="headerlink" title="单涵道动力学分析"></a>单涵道动力学分析</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230108114441049.png"></p><h3 id="空气阻力"><a href="#空气阻力" class="headerlink" title="空气阻力"></a>空气阻力</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230108114623458.png"></p><blockquote><p>飞机的升力公式详解<br>Y&#x3D;1&#x2F;2ρCSv²<br>式中：<br>Y是总升力，（单位是：牛顿，即N，1千克力约等于10牛顿）</p><p>C是升力系数，是个不名数，没有单位，是通过风洞实验测出的系数，但一般可按1进行粗略计算，升力系数和机翼的翼型（就是机翼断面的形状，一般前圆后尖、上曲下平、较厚的，例如达到弦长的15%的翼型具有较大的升力系数）、迎角（就是翼弦与气流的夹角，升力系数与迎角正相关，较厚的机翼允许迎角较大，例如10～12°，较薄的机翼不允许大迎角，只能6～8°，太大就会因升力系数迅速减小而失速）、展弦比（展弦比越大，升力系数越大）、机翼表面的光滑程度（越光滑升力系数越大）有关。</p><p>展弦比：翼长的平方除以翼的面积</p><p>S是机翼的面积（单位是：平方米，即m2）。</p><p>v是飞机的速度（单位是：米&#x2F;秒，即m&#x2F;s，如果的公里&#x2F;小时就要除以3.6，换算成米&#x2F;秒；如果是顶风，就要用飞机的速度加风速，如果是顺风，就要用飞机的速度减风速，单位都用米&#x2F;秒）。注意，公式里是平方。速度大三倍，升力大九倍。</p><p>ρ是大气密度（和当地海拔高度、气温、湿度有关，海拔500米之下可按1.2计算，单位是：千克&#x2F;立方米，即Kg&#x2F;m3）。</p></blockquote><h3 id="涵道内部风扇"><a href="#涵道内部风扇" class="headerlink" title="涵道内部风扇"></a>涵道内部风扇</h3><p>假设流动为管流，建立涵道风扇轴流状态的管流模型。气体在无穷远处速度为Vc，经过风扇桨盘时加速至Vc+Vi，最终以Vc+V2形成尾迹。如图所示。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230108161630475.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230108163843366.png"></p><blockquote><p>涵道体上产生的拉力？</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230108163946929.png"></p></blockquote><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230108164543358.png"></p><blockquote><p>理想正压流体在有势体积力作用下作定常运动时，运动方程(即欧拉方程)沿流线积分而得到的表达运动流体机械能守恒的方程。因著名的瑞士科学家D.伯努利于1738年提出而得名。对于重力场中的不可压缩均质流体 ，方程为p+ρgh+(1&#x2F;2)*ρv^2&#x3D;c　式中p、ρ、v分别为流体的压强、密度和速度；h为铅垂高度；g为重力加速度ρgh和动能(1&#x2F;2)*ρv ^2，在沿流线运动过程中，总和保持不变，即总能量守恒。但各流线之间总能量（即上式中的常量值）可能不同。对于气体，可忽略重力，方程简化为p+(1&#x2F;2)*ρv ^2&#x3D;常量(p0)，各项分别称为静压 、动压和总压。</p></blockquote><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230108164621695.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230108170557006.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230108170706121.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230108170838419.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230108170936059.png"></p><h3 id="涵道动力学"><a href="#涵道动力学" class="headerlink" title="涵道动力学"></a>涵道动力学</h3><p> 略</p><h3 id="涵道底部控制舵"><a href="#涵道底部控制舵" class="headerlink" title="涵道底部控制舵"></a>涵道底部控制舵</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230109213745427.png"></p><p>每个操纵面上产生的升力可表示为：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230109221947035.png"></p><p>其中，k为操纵面气动升力系数，和攻角有关。Vi+Vc为涵道出口气流流速。</p><blockquote><p>攻角，指的是飞机机翼弦线与相对风的夹角。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230109222150764.png"></p></blockquote><p>由操纵面产生的作用于机体的力和力矩可分别表示为：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230109223101909.png"></p><p>其中，Mc为驱动力矩，Tx、Ty、Tz为驱动力矩在机体系坐标轴上的投影。</p><h3 id="固定气动面动力学和陀螺力矩"><a href="#固定气动面动力学和陀螺力矩" class="headerlink" title="固定气动面动力学和陀螺力矩"></a>固定气动面动力学和陀螺力矩</h3><p>单涵道无人机内部设计固定气动面以平衡悬停状态下风扇反扭距的影响。</p><p>固定气动面对涵道轴得到力矩可近似为：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230109224911130.png"></p><p>如图所示：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230109224921143.png"></p><p>在悬停点附近，涵道风扇转速几乎恒定，只有在剧烈的机动飞行中，转速变化才会比较明显了。为简单起见，假设风扇转速的变换可以忽略不计。因此，由风扇的旋转产生陀螺力矩可表示为：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230109225201109.png"></p><p>其中，Ib为风扇转动惯量，Lr为风扇角动量。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1]基于自抗扰控制的涵道无人机控制分配_蒙超恒</p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UAV </tag>
            
            <tag> 建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动手学ROS2</title>
      <link href="/2023/01/11/Learn/ROS/%E5%8A%A8%E6%89%8B%E5%AD%A6ROS2/"/>
      <url>/2023/01/11/Learn/ROS/%E5%8A%A8%E6%89%8B%E5%AD%A6ROS2/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><strong>原文作者链接：<a href="https://fishros.com/d2lros2/#/">https://fishros.com/d2lros2/#/</a></strong></p><h2 id="ROS介绍"><a href="#ROS介绍" class="headerlink" title="ROS介绍"></a>ROS介绍</h2><h3 id="ROS与ROS2对比"><a href="#ROS与ROS2对比" class="headerlink" title="ROS与ROS2对比"></a>ROS与ROS2对比</h3><h4 id="Ros的问题举例"><a href="#Ros的问题举例" class="headerlink" title="Ros的问题举例"></a>Ros的问题举例</h4><p>ROS的设计目标是简化机器人的开发，如何简化呢？ROS为此设计了一整套通信机制（话题、服务、参数、动作）。</p><p>通过这些通信机制，ROS实现了将机器人的各个组件给的连接起来，在设计这套通信机制的时候就设计了一个叫做<code>Ros Master</code>的东西，所有节点（可以理解为某一个组件，比如：激光雷达）的通信建立必须经过这个主节点。</p><p>这种组合结构图如下：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20220918171101672.png"></p><p>主节点激光雷达节点避障检测节点底盘驱动节点</p><p>一旦<code>Ros Master</code>主节点挂掉后，就会<strong>造成整个系统通信的异常</strong>,此时避障策略将会失效，如果机器人正在运行，碰到障碍物会径直装上去，机毁人亡！</p><blockquote><p>ROS的不稳定这个问题在虽然对大家做机器人研究问题不大，但如果是想基于ROS做商业化机器人（比如无人驾驶汽车），就会造成非常严重的后果，小鱼在工作中可没为这个问题发愁</p></blockquote><p>除了不稳定这个问题，ROS还有很多其他地方存在着问题：</p><ul><li>通信基于TCP实现，实时性差、系统开销大</li><li>对Python3支持不友好，需要重新编译</li><li>消息机制不兼容</li><li>没有加密机制、安全性不高</li></ul><h4 id="ROS与ROS2架构对比"><a href="#ROS与ROS2架构对比" class="headerlink" title="ROS与ROS2架构对比"></a>ROS与ROS2架构对比</h4><p>所以在ROS2中，首当其冲的将ROS的主节点干掉了，这里放一张网上流传最广的ROS&#x2F;ROS2架构图。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20220918171819801.png"></p><p><u><strong>OS层：</strong></u>从原来的只支持linux平台变成了支持windows、mac甚至是嵌入式RTOS平台，多平台！</p><p><u><strong>MiddleWare中间件层：</strong></u>那么中间层ROS2到底相对于ROS做了哪些优化呢？</p><ol><li><p>去中心化master，ROS和ROS2中间件不同之处在于，ROS2取消了master节点。</p><p>去中心化后，各个节点之间可以通过DDS的节点相互发现，各个节点都是平等的，且可以1对1、1对n、n对n进行互相通信。</p></li><li><p>不造通信的轮子，通信直接更换为DDS进行实现采用DDS通信，使得ROS2的实时性、可靠性和连续性上都有了增强。</p></li></ol><p><u><strong>应用层：</strong></u>对于应用层来说ROS2也做了很大的改进，上面那张图没有体现出来。</p><p>​ROS2进行改进有：</p><ol><li>python2到pyhton3的支持</li><li>编译系统的改进（catkin到ament）</li><li>C++标准更新到c++11</li><li>可以使用相同 API 的进程间和进程内通信</li></ol><p><strong><u>新概念举例：</u></strong></p><ul><li>可用Python编写的Launch文件</li><li>多机器人协同通信支持</li><li>支持安全加密通信</li><li>同一个进程支持多个节点、</li><li>支持Qos服务质量</li><li>支持节点生命周期管理</li><li>高效的进程间通信</li></ul><h3 id="ROS2初体验"><a href="#ROS2初体验" class="headerlink" title="ROS2初体验"></a>ROS2初体验</h3><h4 id="1-游戏1：你说我听"><a href="#1-游戏1：你说我听" class="headerlink" title="1.游戏1：你说我听"></a>1.游戏1：你说我听</h4><p>游戏内容：很简单，我们启动两个节点，一个节点负责发消息(说)，一个节点负责收消息（听）。</p><ol><li><p>启动一个终端Ctrl+Alt+T</p></li><li><p>启动倾听者</p><pre class="line-numbers language-none"><code class="language-none">ros2 run demo_nodes_py listenerCopy to clipboardErrorCopied<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>启动一个新终端Ctrl+Alt+T</p></li><li><p>启动说话者</p><pre class="line-numbers language-none"><code class="language-none">ros2 run demo_nodes_cpp talkerCopy to clipboardErrorCopied<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p>观察一下现象，talker节点每数一个输，倾听节点每一次都能听到一个，是不是很神奇。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20220603124845382.png"></p><h4 id="2-游戏2-涂鸦乌龟"><a href="#2-游戏2-涂鸦乌龟" class="headerlink" title="2.游戏2:涂鸦乌龟"></a>2.游戏2:涂鸦乌龟</h4><p>游戏内容：启动海龟模拟器，启动海龟遥控器，控制海龟在地图上画出任意轨迹即可。</p><blockquote><p>本来是控制海龟画个五角星的，但经过手动多次尝试，发现太难了。大家有时间可以试试，有搞定的可以发个图在群里分享一下。</p></blockquote><p>2.1 启动海龟模拟器</p><p>打开终端Ctrl+Alt+T,输入下面的指令</p><pre class="line-numbers language-none"><code class="language-none">ros2 run turtlesim turtlesim_nodeCopy to clipboardErrorCopied<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>就可以看到这样的界面</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20210720123734477.png"></p><p>2.2 启动海龟遥控器</p><p>点一下原来的终端输入Ctrl+Shift+T 打开一个新的标签页输入</p><pre class="line-numbers language-none"><code class="language-none">ros2 run turtlesim turtle_teleop_keyCopy to clipboardErrorCopied<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>你可以看到这样子的界面</p><p><img src="https://fishros.com/d2lros2/humble/chapt1/get_started/4.ROS2%E5%88%9D%E4%BD%93%E9%AA%8C/imgs/image-20210720124022925.png"></p><p>这个时候你就可以使用上下左右去遥控海龟了，快试一试吧。</p><p><img src="https://fishros.com/d2lros2/humble/chapt1/get_started/4.ROS2%E5%88%9D%E4%BD%93%E9%AA%8C/imgs/image-20210720125026860.png"></p><h4 id="3-RQT可视化"><a href="#3-RQT可视化" class="headerlink" title="3. RQT可视化"></a>3. RQT可视化</h4><p>保持前面两个游戏在运行状态，打开终端，输入rqt。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rqtCopy to clipboardErrorCopied<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>打开之后的窗口如下图，空空如也，不要担心，因为我们没有选插件的原因。</p><p><img src="https://fishros.com/d2lros2/humble/chapt1/get_started/4.ROS2%E5%88%9D%E4%BD%93%E9%AA%8C/imgs/image-20220603124701935.png"></p><p>选择插件</p><p>这里我们可以选择现有的几个RQT插件来试一试，可以看到和话题、参数、服务、动作四大通信组件相关的工具都有，还有一些可视化、日志和系统计算图等相关的。</p><p><img src="https://fishros.com/d2lros2/humble/chapt1/get_started/4.ROS2%E5%88%9D%E4%BD%93%E9%AA%8C/imgs/image-20220603124722852.png"></p><p>Introspection &#x2F; Node Graph</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20220603124722852.png"></p><p>打开后就可以看到上面几个节点之间的数据关系了，是不是很方便的工具。</p><p><img src="https://fishros.com/d2lros2/humble/chapt1/get_started/4.ROS2%E5%88%9D%E4%BD%93%E9%AA%8C/imgs/image-20220603125332498.png"></p><h3 id="ROS2系统架构"><a href="#ROS2系统架构" class="headerlink" title="ROS2系统架构"></a>ROS2系统架构</h3><h4 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h4><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20220602204152352.png"></p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>磁力计与地磁场</title>
      <link href="/2023/01/11/Learn/%E6%9D%82/%E7%A3%81%E5%8A%9B%E8%AE%A1&amp;%E5%9C%B0%E7%A3%81%E5%9C%BA/"/>
      <url>/2023/01/11/Learn/%E6%9D%82/%E7%A3%81%E5%8A%9B%E8%AE%A1&amp;%E5%9C%B0%E7%A3%81%E5%9C%BA/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h3 id="1、地球磁场分布图："><a href="#1、地球磁场分布图：" class="headerlink" title="1、地球磁场分布图："></a>1、地球磁场分布图：</h3><p> 地球磁场：地球的磁场象一个条形磁体一样由磁南极指向磁北极。在磁极点处磁场和当地的水平面垂直，在赤道磁场和当地的水平面平行，所以在北半球磁场方向倾斜指向地面。用来衡量磁感应强度大小的单位是Tesla或者Gauss（1Tesla&#x3D;10000Gauss）。随着地理位置的不同，通常地磁场的强度是0.4-0.6Gauss。需要注意的是，磁北极和地理上的北极并不重合，通常他们之间有11.5度左右的夹角。</p><p>单位：</p><p>1Tesla&#x3D;10000Gauss</p><p>1高斯 &#x3D;100000 nT</p><p>1高斯 &#x3D;1000 mGauss</p><p>1mGauss&#x3D;100nT<br><img src="https://img-blog.csdnimg.cn/2020042015072466.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d1d3VrdTEyMw==,size_16,color_FFFFFF,t_70"></p><h3 id="2、-地磁要素图："><a href="#2、-地磁要素图：" class="headerlink" title="2、 地磁要素图："></a><strong>2、 地磁要素图：</strong></h3><p>设观测点在O处，并以O点为原点建立地理坐标系OXYZ，X轴指向北，Y轴指向东，Z轴垂直指向地。</p><p><a href="https://img-blog.csdnimg.cn/20200420150740771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d1d3VrdTEyMw==,size_16,color_FFFFFF,t_70"><img src="https://img-blog.csdnimg.cn/20200420150740771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d1d3VrdTEyMw==,size_16,color_FFFFFF,t_70"></a></p><p>   地磁场强度T在X轴上的投影Bn称为地磁场的北向分量；T在Y轴上的投影Be称为东向分量；T在Z轴上的投影Bz称为地磁场的垂向分量。T在水平面O-XY的投影Bh称为地磁场的水平分量。地磁水平分量Bh和垂向分量Bz所在平面称为磁子午面，磁子午面和地理子午面O-XZ平面的夹角称为磁偏角，用D表示，并规定其东偏为正，西偏为负。地磁场强度T与水平面O-XY的夹角称为磁倾角，用I表示。上述，T、Bh、Bn、Be、Bz、D、I统称为地磁场七要素，可作为定位定向的参考量。七要素只要知道三个独立的要素，就可以求其余的要素，常用的是磁倾角、磁偏角和水平分量。七要素间有如下关系：<br><a href="https://img-blog.csdnimg.cn/20200420152053240.png"><img src="https://img-blog.csdnimg.cn/20200420152053240.png"></a></p><p>3、中国地磁要素变化：<br>    中国的地磁要素大致分布情况：国境内地磁强度总量范围0.41~0.60Gauss(1 Gauss &#x3D; 10^-4T)；水平分量Bh由南至北从0.4降至0.21；垂直分量Bz由南至北从-0.1增至0.56；磁倾角I由南至北从-10°增至70°；磁偏角D由东向西从-11°增至5°，零偏线在中国中部偏西处，由北向南经过甘肃的安西以及西藏的得宋。</p><p>4、地磁场的一级近似：<br>对地磁场的一种近似，如下图所示：<br><a href="https://img-blog.csdnimg.cn/20200420153133439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d1d3VrdTEyMw==,size_16,color_FFFFFF,t_70"><img src="https://img-blog.csdnimg.cn/20200420153133439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d1d3VrdTEyMw==,size_16,color_FFFFFF,t_70"></a></p><p>不考虑地磁轴与地球自转轴的偏离问题，地磁强度分量可用以下解析式来描述：</p><p><img src="https://img-blog.csdnimg.cn/2020042015332184.png"></p><p>其中，东向地磁分量为0；在实际运算中，将磁力计在水平面X、Y轴的测量值，全部投影到北向，并将东向置零。</p><h1 id="二、计算"><a href="#二、计算" class="headerlink" title="二、计算"></a>二、计算</h1><p>[<a href="https://zinghd.gitee.io/knowledge-point-1/">知识点]基于加速度计与磁力计的姿态解算方法(加计补偿偏航) | 曾同学的思考 (gitee.io)</a></p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四元数与欧拉角与旋转矩阵</title>
      <link href="/2023/01/11/Learn/%E6%95%B0%E5%AD%A6/%E5%9B%9B%E5%85%83%E6%95%B0%E4%B8%8E%E6%AC%A7%E6%8B%89%E8%A7%92%E4%B8%8E%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5/"/>
      <url>/2023/01/11/Learn/%E6%95%B0%E5%AD%A6/%E5%9B%9B%E5%85%83%E6%95%B0%E4%B8%8E%E6%AC%A7%E6%8B%89%E8%A7%92%E4%B8%8E%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a href="https://www.cnblogs.com/21207-iHome/p/6894128.html">四元数与欧拉角（RPY角）的相互转换 - XXX已失联 - 博客园 (cnblogs.com)</a></p><p>关于四元数旋转矩阵的推导：</p><p><a href="https://blog.csdn.net/u014265928/article/details/117170481">(66条消息) 【机器人学】绕空间任意轴的旋转矩阵推导_whu木小易的博客-CSDN博客_绕任意轴旋转的旋转矩阵</a></p><p>四元数与旋转矩阵的转换：</p><p><a href="https://blog.csdn.net/u014265928/article/details/117161701">(66条消息) 【机器人学】四元数与旋转矩阵的相互转换_whu木小易的博客-CSDN博客_四元数与旋转矩阵转换</a></p><p>结论：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230111230403340.png" alt="旋转矩阵"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230107160428256.png" alt="四元数解欧拉角"></p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>矩阵的伪逆</title>
      <link href="/2023/01/11/Learn/%E6%95%B0%E5%AD%A6/%E7%9F%A9%E9%98%B5%E7%9A%84%E4%BC%AA%E9%80%86/"/>
      <url>/2023/01/11/Learn/%E6%95%B0%E5%AD%A6/%E7%9F%A9%E9%98%B5%E7%9A%84%E4%BC%AA%E9%80%86/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="满秩-x2F-列满秩-x2F-行满秩"><a href="#满秩-x2F-列满秩-x2F-行满秩" class="headerlink" title="满秩&#x2F;列满秩&#x2F;行满秩"></a>满秩&#x2F;列满秩&#x2F;行满秩</h2><p>设A是n阶矩阵, 若r（A） &#x3D; n, 则称A为满秩矩阵。但满秩不局限于n阶矩阵。</p><p>若矩阵秩等于行数，称为行满秩；若矩阵秩等于列数，称为列满秩。既是行满秩又是列满秩则为n阶矩阵即n阶方阵。行满秩矩阵就是行向量线性无关，列满秩矩阵就是列向量线性无关；所以如果是方阵,行满秩矩阵与列满秩矩阵是等价的。</p><h3 id="左逆与右逆"><a href="#左逆与右逆" class="headerlink" title="左逆与右逆"></a>左逆与右逆</h3><h4 id="左逆（Left-inverse）"><a href="#左逆（Left-inverse）" class="headerlink" title="左逆（Left inverse）"></a>左逆（Left inverse）</h4><p>　　如果<strong>A</strong>是一个m×n的列满秩矩阵，意味着<strong>A</strong>的各列线性无关，<strong>A</strong>的秩和列数相等，r &#x3D; n，但<strong>A</strong>可能存在更多的行，m ≥ n，此时<strong>A</strong>的零空间只有零向量，并且<strong>Ax</strong> &#x3D; <strong>b</strong>有唯一解（m &#x3D; n时）或无解（m &gt; n时）。</p><p>　　对于列满秩矩阵来说，对称矩阵<strong>ATA</strong>是一个n×n的满秩方阵，因此<strong>ATA</strong>可逆，此时：</p><p><img src="https://img2018.cnblogs.com/blog/1203675/201912/1203675-20191219212030618-546806398.png"></p><p>　　</p><p>　　我们称<strong>A</strong>-1left为<strong>A</strong>的左逆，是一个n×m的矩阵，左逆也是讨论最小二乘问题的核心。</p><h4 id="右逆（Right-inverse）"><a href="#右逆（Right-inverse）" class="headerlink" title="右逆（Right inverse）"></a>右逆（Right inverse）</h4><p>　　如果<strong>A</strong>是一个m×n的行满秩矩阵，意味着<strong>A</strong>的各行线性无关，<strong>A</strong>的秩和行数相等，r &#x3D; m，但<strong>A</strong>可能存在更多的列，m ≤ n。<strong>A</strong>的左零空间只有零向量，<strong>A</strong>的零空间是n - r维，因此有n – r个自由变量，当n &gt; m时，<strong>Ax</strong> &#x3D; <strong>b</strong>有无数解。</p><p>　　对于行满秩矩阵来说，对称矩阵<strong>AAT</strong>是一个m×m的满秩方阵，因此<strong>AAT</strong>可逆，此时：</p><p><img src="https://img2018.cnblogs.com/blog/1203675/201912/1203675-20191219212047065-958765262.png"></p><p>　　通常来说，右乘左逆得不到单位矩阵，仅在m &#x3D; n时才有<strong>AA</strong>-1left &#x3D; <strong>I</strong>。对于列满秩的m×n矩阵来说，<strong>AA</strong>-1left &#x3D; <strong>A</strong>(<strong>A</strong>T<strong>A</strong>)-1<strong>A</strong>T &#x3D; <strong>P</strong>，<strong>P</strong>是<strong>A</strong>的列空间的投影矩阵。同理，左乘右逆也得不到单位矩阵，<strong>A</strong>-1right<strong>A</strong>是<strong>A</strong>的行空间的投影矩阵。</p><p>From Wikipedia:</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230107165213444.png"></p><p>列满秩对应有左逆。行满秩对应右逆。</p><h3 id="Question-为何列满秩，Atranspose-A一定可逆？"><a href="#Question-为何列满秩，Atranspose-A一定可逆？" class="headerlink" title="Question:为何列满秩，Atranspose A一定可逆？"></a>Question:为何列满秩，Atranspose A一定可逆？</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230107171325994.png"></p><h2 id="伪逆性质"><a href="#伪逆性质" class="headerlink" title="伪逆性质"></a>伪逆性质</h2><p><img src="https://img2018.cnblogs.com/blog/1203675/201912/1203675-20191219212655293-2111508311.png"></p><h2 id="伪逆与SVD"><a href="#伪逆与SVD" class="headerlink" title="伪逆与SVD"></a>伪逆与SVD</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230107175536979.png"></p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
