<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2023.3.7 牛客题库</title>
      <link href="/2023/03/07/Learn/%E7%89%9B%E5%AE%A2%E9%A2%98%E5%BA%93/2023.3.7%20%E7%89%9B%E5%AE%A2%E9%A2%98%E5%BA%93/"/>
      <url>/2023/03/07/Learn/%E7%89%9B%E5%AE%A2%E9%A2%98%E5%BA%93/2023.3.7%20%E7%89%9B%E5%AE%A2%E9%A2%98%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="2023-3-7"><a href="#2023-3-7" class="headerlink" title="2023.3.7"></a>2023.3.7</h1><h2 id="1、简单密码"><a href="#1、简单密码" class="headerlink" title="1、简单密码"></a>1、简单密码</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230307101720665.png"></p><h3 id="My-Code"><a href="#My-Code" class="headerlink" title="My Code"></a>My Code</h3><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123;    string str;    getline(cin,str);    for(int i&#x3D;0;i&lt;str.length();i++)&#123;        if(str[i] &gt;&#x3D; &#39;A&#39; &amp;&amp; str[i] &lt; &#39;Z&#39;)        &#123;            str[i] &#x3D; str[i] - (&#39;A&#39; - &#39;a&#39;) + 1;        &#125;        else if(str[i] &#x3D;&#x3D; &#39;Z&#39;)        &#123;            str[i] &#x3D; &#39;a&#39;;        &#125;        else if(str[i] &gt;&#x3D; &#39;a&#39; &amp;&amp; str[i]&lt;&#x3D;&#39;o&#39;)&#123;            str[i] &#x3D; ((str[i]-1)&#x2F;3 - 30) + &#39;0&#39;;        &#125;        else if(str[i] &gt;&#x3D; &#39;p&#39; &amp;&amp; str[i]&lt;&#x3D;&#39;s&#39;)&#123;            str[i] &#x3D; &#39;7&#39;;        &#125;        else if(str[i] &gt;&#x3D; &#39;t&#39; &amp;&amp; str[i]&lt;&#x3D;&#39;v&#39;)&#123;            str[i] &#x3D; &#39;8&#39;;        &#125;        else if(str[i] &gt;&#x3D; &#39;w&#39; &amp;&amp; str[i]&lt;&#x3D;&#39;z&#39;)&#123;            str[i] &#x3D; &#39;9&#39;;        &#125;    &#125;    cout &lt;&lt; str ;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2、汽水瓶"><a href="#2、汽水瓶" class="headerlink" title="2、汽水瓶"></a>2、汽水瓶</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230307101833632.png"></p><h3 id="My-Code-1"><a href="#My-Code-1" class="headerlink" title="My Code"></a>My Code</h3><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;using namespace std;int count &#x3D; 0;int bottleChange(int k)&#123;    while(k !&#x3D; 0)&#123;        if(k&lt;2)&#123;            k &#x3D; 0; &#x2F;&#x2F;如果小于两个空瓶子，换不了        &#125;        else if(k &#x3D;&#x3D; 2)&#123;            count ++;            k &#x3D; 0;&#x2F;&#x2F;如果有两个空瓶子，可以换一个        &#125;        else if( k &gt;&#x3D; 3)&#123;            count +&#x3D; k&#x2F;3;            k &#x3D; (k&#x2F;3)+(k%3);&#x2F;&#x2F;如果有三个以上的空瓶子，先换在加没换的，再循环        &#125;    &#125;    return 0;&#125;int main() &#123;    int n &#x3D; 0;    while(cin &gt;&gt; n) &#123;        if(n&#x3D;&#x3D;0)        &#123;            return 0;        &#125;        bottleChange(n);        cout &lt;&lt; count &lt;&lt;endl;        count &#x3D; 0;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Learn"><a href="#Learn" class="headerlink" title="Learn"></a>Learn</h3><p>直呼牛逼，空瓶两瓶换一瓶即没有空瓶，直接&#x2F;2…结束。</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;using namespace std;int main() &#123;    int n &#x3D; 0;    while(cin &gt;&gt; n) &#123;        if(n&#x3D;&#x3D;0)        &#123;            return 0;        &#125;        cout &lt;&lt; n&#x2F;2 &lt;&lt;endl;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3、删除字符串中出现次数最少的字符"><a href="#3、删除字符串中出现次数最少的字符" class="headerlink" title="3、删除字符串中出现次数最少的字符"></a>3、删除字符串中出现次数最少的字符</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230307105838622.png"></p><h3 id="My-Code-2"><a href="#My-Code-2" class="headerlink" title="My Code"></a>My Code</h3><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123;    string str;        while(cin&gt;&gt;str)    &#123;        int min&#x3D;20;        vector&lt;int&gt; Hash(26,0);        for(int i&#x3D;0;i&lt;str.size();i++)        &#123;            Hash[str[i]-&#39;a&#39;]++;        &#125;        for(int i&#x3D;0;i&lt;26;i++)        &#123;            if(min&gt;Hash[i]&amp;&amp;Hash[i]&gt;0)                min&#x3D;Hash[i];        &#125;        for(int i&#x3D;0;i&lt;str.size();i++)        &#123;            if(Hash[str[i]-&#39;a&#39;]!&#x3D;min)                cout&lt;&lt;str[i];        &#125;        cout&lt;&lt;endl;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4、合唱队"><a href="#4、合唱队" class="headerlink" title="4、合唱队"></a>4、合唱队</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230307112640954.png"></p><h3 id="My-Code-3"><a href="#My-Code-3" class="headerlink" title="My Code"></a>My Code</h3><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;using namespace std;int main() &#123;    int n;    cin &gt;&gt; n;    int str[n];    for(int i&#x3D;0;i&lt;n;i++)&#123;        cin &gt;&gt; str[i];    &#125;    int left[n];    int right[n];    int left_min &#x3D; 0;    int left_count &#x3D; 0;    int right_min &#x3D; 0;    int right_count &#x3D; 0;     int count &#x3D; n;    for(int i&#x3D;0,j&#x3D;n-i-1;i&lt;n;i++,j--)&#123;        left[i]&#x3D;1;        for(int ii&#x3D;0;ii&lt;i;ii++)&#123;            if(str[i]&gt;str[ii])            &#123;                left[i] &#x3D; max(left[i],left[ii]+1);            &#125;        &#125;        right[j]&#x3D;1;        for(int jj&#x3D;n-1;jj&gt;j;jj--)        &#123;            if(str[j]&gt;str[jj])&#123;                right[j] &#x3D; max(right[j],right[jj]+1);            &#125;        &#125;    &#125;    for(int i&#x3D;0;i&lt;n;i++)&#123;        count &#x3D; min(count,n-(left[i]+right[i]-1));    &#125;    cout &lt;&lt; count;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 牛客Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023.3.6 牛客题库</title>
      <link href="/2023/03/06/Learn/%E7%89%9B%E5%AE%A2%E9%A2%98%E5%BA%93/2023.3.6%20%E7%89%9B%E5%AE%A2%E9%A2%98%E5%BA%93/"/>
      <url>/2023/03/06/Learn/%E7%89%9B%E5%AE%A2%E9%A2%98%E5%BA%93/2023.3.6%20%E7%89%9B%E5%AE%A2%E9%A2%98%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="2023-3-6"><a href="#2023-3-6" class="headerlink" title="2023.3.6"></a>2023.3.6</h1><h2 id="动态规划dp背包问题"><a href="#动态规划dp背包问题" class="headerlink" title="动态规划dp背包问题"></a>动态规划dp背包问题</h2><p><a href="https://www.bilibili.com/video/BV1K4411X766/?spm_id_from=333.337.search-card.all.click&vd_source=dc5a7d7190173a321a8ae3df82a10d84">【动态规划】背包问题_哔哩哔哩_bilibili</a></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230306092044679.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230306092944982.png"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void Dynamic()&#123;for(int i&#x3D;1; i&lt;5; i++)&#123;for(int j&#x3D;1; j&lt;9; j++)&#123;if(weight[i]&gt;j)&#123;dp[i][j]&#x3D;dp[i-1][j]&#125;else&#123;dp[i][j]&#x3D;max&#123;dp[i-1][j],dp[i-1][j-weight[i]]+value[i]&#125;;&#125;&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1、购物单"><a href="#1、购物单" class="headerlink" title="1、购物单"></a>1、购物单</h2><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230306094453901.png"  /><p>这题有点类似于背包问题，不同之处在于他有附件。</p><h3 id="My-Code"><a href="#My-Code" class="headerlink" title="My Code"></a>My Code</h3><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;&#x2F;&#x2F;化为0&#x2F;1背包问题，主件和它的附件们可以看为一个物品using namespace std;int main()&#123;    int N;    int m;    while(cin&gt;&gt;N&gt;&gt;m)&#123;        int dp[61][3201]&#x3D;&#123;0&#125;;&#x2F;&#x2F;用来dp的矩阵        int weight[61][3]&#x3D;&#123;0&#125;;&#x2F;&#x2F;存放v        int value[61][3]&#x3D;&#123;0&#125;;&#x2F;&#x2F;存放v*p        int v,p,q;        N&#x2F;&#x3D;10;        for(int i&#x3D;1;i&lt;&#x3D;m;i++)&#123;&#x2F;&#x2F;输入处理            cin&gt;&gt;v&gt;&gt;p&gt;&gt;q;            p*&#x3D;v;&#x2F;&#x2F;重量，我们要使这个p总和最大            v&#x2F;&#x3D;10;&#x2F;&#x2F;价格            if(!q)&#123;&#x2F;&#x2F;这个东西是主件，q&#x3D;&#x3D;0                weight[i][q]&#x3D;v;&#x2F;&#x2F;重量就是价格v                value[i][q]&#x3D;p;&#x2F;&#x2F;价值就是p&#x3D;&#x3D;p*v            &#125;else if(!weight[q][1])&#123;&#x2F;&#x2F;这个东西是第q件物品的第一个附件                weight[q][1]&#x3D;v;                value[q][1]&#x3D;p;            &#125;else&#123;&#x2F;&#x2F;这个东西是第q件物品的第二个附件                weight[q][2]&#x3D;v;                value[q][2]&#x3D;p;            &#125;        &#125;        &#x2F;* dp[i][j]表示有j块钱买第i个商品的最大满意度 *&#x2F;        for(int i&#x3D;1;i&lt;&#x3D;m;i++)&#123;&#x2F;&#x2F;开始dp            for(int j&#x3D;1;j&lt;&#x3D;N;j++)&#123;                dp[i][j]&#x3D;dp[i-1][j];&#x2F;&#x2F;默认不装任何物品                if(weight[i][0]&lt;&#x3D;j)&#x2F;&#x2F;可以装入一个主件                    dp[i][j]&#x3D;max(dp[i][j],dp[i-1][j-weight[i][0]]+value[i][0]);                if(weight[i][0]+weight[i][1]&lt;&#x3D;j)&#x2F;&#x2F;可以装入一个主件和第一个附件                    dp[i][j]&#x3D;max(dp[i][j],dp[i-1][j-weight[i][0]-weight[i][1]]+value[i][0]+value[i][1]);                if(weight[i][0]+weight[i][2]&lt;&#x3D;j)&#x2F;&#x2F;可以装入一个主件和第二个附件                    dp[i][j]&#x3D;max(dp[i][j],dp[i-1][j-weight[i][0]-weight[i][2]]+value[i][0]+value[i][2]);                if(weight[i][0]+weight[i][1]+weight[i][2]&lt;&#x3D;j)&#x2F;&#x2F;可以装入一个主件和第一、二个附件                    dp[i][j]&#x3D;max(dp[i][j],dp[i-1][j-weight[i][0]-weight[i][1]-weight[i][2]]+value[i][0]+value[i][1]+value[i][2]);            &#125;        &#125;        cout&lt;&lt;dp[m][N]&lt;&lt;endl;    &#125;   return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Learn"><a href="#Learn" class="headerlink" title="Learn"></a>Learn</h3><p>见背包问题</p><h2 id="2、坐标移动"><a href="#2、坐标移动" class="headerlink" title="2、坐标移动"></a>2、坐标移动</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230306094952889.png"></p><h3 id="My-Code-1"><a href="#My-Code-1" class="headerlink" title="My Code"></a>My Code</h3><p>做的太复杂了。情况太多一一考虑，不好。</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;bool if_use(char a)&#123;    if(a &gt;&#x3D; &#39;0&#39; &amp;&amp; a&lt;&#x3D;&#39;9&#39;)&#123;        return true;    &#125;    return false;&#125;int main() &#123;    string str;    getline(cin,str);    int pos_1 &#x3D; 0;    int sum_x &#x3D; 0;    int sum_y &#x3D; 0;    int last_count &#x3D; 0;    if(str[str.length()-3 &#x3D;&#x3D; &#39;;&#39;])&#123;        last_count &#x3D; 2;    &#125;    else&#123;        last_count &#x3D; 3;    &#125;    for(int i&#x3D;0;i&lt;str.length()-last_count;i++)&#123;        if(str[i] &#x3D;&#x3D; &#39; &#39;)&#123;            pos_1++;        &#125;        if(str[pos_1+3] &#x3D;&#x3D; &#39;;&#39; &amp;&amp; if_use(str[pos_1+1])&#x3D;&#x3D;true &amp;&amp; if_use(str[pos_1+2])&#x3D;&#x3D;true &amp;&amp; pos_1 !&#x3D; -1)&#123;            if(str[pos_1] &#x3D;&#x3D; &#39;A&#39;)&#123;                sum_x -&#x3D; (str[pos_1+1]-&#39;0&#39;)*10 + str[pos_1+2]-&#39;0&#39;;            &#125;            else if(str[pos_1] &#x3D;&#x3D; &#39;D&#39;)&#123;                sum_x +&#x3D; (str[pos_1+1]-&#39;0&#39;)*10 + str[pos_1+2]-&#39;0&#39;;            &#125;            else if(str[pos_1] &#x3D;&#x3D; &#39;W&#39;)&#123;                sum_y +&#x3D; (str[pos_1+1]-&#39;0&#39;)*10 + str[pos_1+2]-&#39;0&#39;;            &#125;            else if(str[pos_1] &#x3D;&#x3D; &#39;S&#39;)&#123;                sum_y -&#x3D; (str[pos_1+1]-&#39;0&#39;)*10 + str[pos_1+2]-&#39;0&#39;;            &#125;            pos_1 &#x3D; -1;        &#125;        if(str[pos_1+2] &#x3D;&#x3D; &#39;;&#39; &amp;&amp; if_use(str[pos_1+1])&#x3D;&#x3D;true &amp;&amp; pos_1 !&#x3D; -1)&#123;            if(str[pos_1] &#x3D;&#x3D; &#39;A&#39;)&#123;                sum_x -&#x3D; str[pos_1+1]-&#39;0&#39;;            &#125;            else if(str[pos_1] &#x3D;&#x3D; &#39;D&#39;)&#123;                sum_x +&#x3D; str[pos_1+1]-&#39;0&#39;;            &#125;            else if(str[pos_1] &#x3D;&#x3D; &#39;W&#39;)&#123;                sum_y +&#x3D; str[pos_1+1]-&#39;0&#39;;            &#125;            else if(str[pos_1] &#x3D;&#x3D; &#39;S&#39;)&#123;                sum_y -&#x3D; str[pos_1+1]-&#39;0&#39;;            &#125;                        pos_1 &#x3D; -1;        &#125;        if(str[i] &#x3D;&#x3D; &#39;;&#39;)&#123;            pos_1 &#x3D; i+1;        &#125;    &#125;     cout &lt;&lt; sum_x &lt;&lt; &#39;,&#39; &lt;&lt; sum_y &lt;&lt; &#39; &#39;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Learn-1"><a href="#Learn-1" class="headerlink" title="Learn"></a>Learn</h3><p>没有看到很好的解。都挺复杂的。</p><h2 id="3、识别有效的IP地址和掩码并进行分类统计"><a href="#3、识别有效的IP地址和掩码并进行分类统计" class="headerlink" title="3、识别有效的IP地址和掩码并进行分类统计"></a>3、识别有效的IP地址和掩码并进行分类统计</h2><h2 id="4、简单错误记录"><a href="#4、简单错误记录" class="headerlink" title="4、简单错误记录"></a>4、简单错误记录</h2><h2 id="5、密码验证合格程序"><a href="#5、密码验证合格程序" class="headerlink" title="5、密码验证合格程序"></a>5、密码验证合格程序</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230306163151014.png" alt="image-20230306163151014"></p><h3 id="My-Code-2"><a href="#My-Code-2" class="headerlink" title="My Code"></a>My Code</h3><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123;    string str;      bool PasswordOk &#x3D; true;    bool PasswordNum &#x3D; true;    bool PasswordA &#x3D; true;    bool Passworda &#x3D; true;    bool Passwordelse &#x3D; true;    while(getline(cin,str))    &#123;        PasswordOk &#x3D; true;        PasswordNum &#x3D; false;        Passworda &#x3D; false;        PasswordA &#x3D; false;        Passwordelse &#x3D; false;        for(int i&#x3D;0;i&lt;str.length();i++)&#123;            if(str[i] &lt;&#x3D; &#39;9&#39; &amp;&amp; str[i] &gt;&#x3D; &#39;0&#39;)&#123;                PasswordNum &#x3D; true;            &#125;            else if(str[i] &gt;&#x3D; &#39;a&#39; &amp;&amp; str[i] &lt;&#x3D; &#39;z&#39;)&#123;                Passworda &#x3D; true;            &#125;            else if(str[i] &gt;&#x3D; &#39;A&#39; &amp;&amp; str[i] &lt;&#x3D; &#39;Z&#39;)&#123;                PasswordA &#x3D; true;            &#125;            else&#123;                Passwordelse &#x3D; true;            &#125;            for(int j&#x3D;i+3;j&lt;str.length()-3;j++)&#123;                if(str[i]&#x3D;&#x3D;str[j] &amp;&amp; str[i+1]&#x3D;&#x3D;str[j+1] &amp;&amp; str[i+2]&#x3D;&#x3D;str[j+2])                &#123;                    PasswordOk &#x3D; false;                &#125;            &#125;        &#125;        if(str.length() &lt;&#x3D;8)&#123;           PasswordOk &#x3D; false;        &#125;        if(PasswordA + Passworda + Passwordelse + PasswordNum &gt;&#x3D;3)&#123;        &#125;        else&#123;            PasswordOk &#x3D; false;        &#125;        if(PasswordOk &#x3D;&#x3D; true)&#123;            cout &lt;&lt; &quot;OK&quot; &lt;&lt;endl;        &#125;        else&#123;            cout &lt;&lt; &quot;NG&quot; &lt;&lt;endl;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Learn-2"><a href="#Learn-2" class="headerlink" title="Learn"></a>Learn</h3><p>好像都差不多。</p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 牛客Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ahrs 航姿参考系统</title>
      <link href="/2023/03/05/Summary/IMU%E9%80%89%E5%9E%8B%E4%B8%8E%E5%A7%BF%E6%80%81%E4%BC%B0%E8%AE%A1/"/>
      <url>/2023/03/05/Summary/IMU%E9%80%89%E5%9E%8B%E4%B8%8E%E5%A7%BF%E6%80%81%E4%BC%B0%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>以下为笔者自己的思考与总结，若有错误，欢迎批评和指出！感谢感谢！</p><h1 id="ahrs-航姿参考系统"><a href="#ahrs-航姿参考系统" class="headerlink" title="ahrs 航姿参考系统"></a>ahrs 航姿参考系统</h1><h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><p>IMU，惯性测量单元。<strong>一个IMU包含了三个单轴的加速度计和三个单轴的陀螺</strong>。</p><p>AHRS（Attitude and Heading Reference System）俗称航姿参考系统，AHRS由<strong>加速度计，磁场计，陀螺仪构成</strong>，能够为飞行器提供航向(yaw)，横滚(roll)和侧翻(pitch)信息，这类系统用来为飞行器提供准确可靠的姿态与航行信息。AHRS的真正参考来自于地球的重力场和地球的磁场，其静态终精度取决于对磁场的测量精度和对重力的测量精度，而则陀螺决定了他的动态性能。</p><h2 id="2、ahrs传感器原理"><a href="#2、ahrs传感器原理" class="headerlink" title="2、ahrs传感器原理"></a>2、ahrs传感器原理</h2><h3 id="2-1-加速度计"><a href="#2-1-加速度计" class="headerlink" title="2.1 加速度计"></a>2.1 加速度计</h3><p>传感器检测技术里写道：传感器是由<strong>敏感元件</strong>和<strong>转换元件</strong>组成。</p><p>那么，加速度计的敏感元件是什么？</p><p>电压式？电阻式？电容式？等等，不管这些传到电路的问题。</p><p>牛顿告诉我们F&#x3D;ma，总之，先受力。</p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230305190907378.png" style="zoom:50%;" /><p>如图所示。能很好的解释这个问题。</p><p>在三维空间中，我们想象一个球放在立方体里。在重力下，对立方体下部尝试mg的力，从而在z方向上初始就有g。</p><p>在姿态计算过程中，我们对g进行了补偿，去掉后等效球在正中心，对六个面都不产生力。</p><p>那如果想象一个平抛运动，我们还能用相同的解法吗？</p><p>我想，不能吧。平抛运动是自由落体运动，g不用补偿。</p><p>还有个特别注意的地方，加速度计是没法测yaw的，为什么？还是想这个球，他在这个立方体里yaw随便转，产生的力也不变。</p><h3 id="2-2-角速度计"><a href="#2-2-角速度计" class="headerlink" title="2.2 角速度计"></a>2.2 角速度计</h3><p>我们采用的是MEMS陀螺仪。</p><p>其原理是科里奥利力，即旋转物体在有径向运动时所受到的切向力。</p><p>那么径向运动哪里来？答案是施加交替改变的电压，让一个质量块来回运动。</p><p>什么是科里奥利力？当一个质点相对于惯性系做直线运动时，相对于旋转体系，其轨迹是一条曲线。立足于旋转体系，我们认为有一个力驱使质点运动轨迹形成曲线，这个力就是科里奥利力。F  &#x3D;−2m( ω× v )。其中F为科里奥利力，m为质点质量，v为质点运动速度，w为旋转系得角速度。</p><p>若三个量已知，那么就可以得到w的值。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230306165159462.png"></p><p><img src="C:/Users/Zunrong%20Guo/AppData/Roaming/Typora/typora-user-images/image-20230306214540297.png" alt="image-20230306214540297"></p><h3 id="2-3-磁力计"><a href="#2-3-磁力计" class="headerlink" title="2.3 磁力计"></a>2.3 磁力计</h3><p><a href="https://potzrrr.top/2023/01/11/Learn/%E6%9D%82/%E7%A3%81%E5%8A%9B%E8%AE%A1&%E5%9C%B0%E7%A3%81%E5%9C%BA/">磁力计与地磁场 | ZRong’s Blog (potzrrr.top)</a></p><p>在上面链接中，我对地磁场有过了介绍。</p><p>但是对于磁力计原理，不是很懂。于是查了一下资料。</p><p><a href="https://www.dzsc.com/data/2010-11-29/87454.html">ST集成传感器方案实现电子罗盘功能-基础电子-维库电子市场网 (dzsc.com)</a></p><p>实际上磁致电阻来检测空间中磁感应强度的大小，自身电阻值会相应发生变化，这是通过电桥转换为电压输出。具体的还是看上面的文章。这里没有做更深入的了解，我觉得跟材料有关了。</p><p>但我们需要知道，传感器由敏感元件和转换元件组成。这里的磁致电阻就是敏感元件，电桥是转换元件。</p><h2 id="3、IMU选择"><a href="#3、IMU选择" class="headerlink" title="3、IMU选择"></a>3、IMU选择</h2><p>IMU传感器有很多，我们常见的有六轴和九轴。六轴和九轴的区别在于六轴少了三轴的磁力计。</p><p>那么，少这三轴会影响什么？</p><p>首先我们先来看看三者的关系。</p><p>加速度计测pitch和roll，没法测yaw，没有累计误差，抗高频信号能力差。</p><p>角速度可以测三轴，但有累计误差，因为角度都是积分出来的，抗低频信号能力差。</p><p>磁力计只能测yaw，没有累计误差，抗高频信号能力差。</p><p>那么组合一下，磁力计和加速度计结合，得到三轴角度，和角速度计做数据融合。结合高频和低频的特点，做好估计，这也是后文要讲的。</p><p>六轴的情况是怎样的呢？只有角速度计和加速度计，那么这时yaw轴没法进行数据融合。会导致什么？</p><p>没错，yaw轴误差靠角速度积分，在足够的时间后，一定会产生漂移！这也是为什么步兵云台会漂移的原因。</p><p>我们没法消除这个，因为在原理上就不行！能做的只有优化，少漂点…补偿点…或者靠人来修正。</p><p><strong>以下MPU6050为重，其他稍微对比。</strong></p><h3 id="3-1-Mpu6050"><a href="#3-1-Mpu6050" class="headerlink" title="3.1 Mpu6050"></a>3.1 Mpu6050</h3><p>Mpu6050最大的优点就是便宜！！！便宜！！！做事要考虑成本，诚然贵的好…</p><h4 id="3-1-1-内部结构"><a href="#3-1-1-内部结构" class="headerlink" title="3.1.1 内部结构"></a>3.1.1 内部结构</h4><p>我们来了解一下陀螺仪内部的结构。</p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230305221343891.png" style="zoom: 67%;" /><p>其中，SCL和 SDA是连接MCU的 IIC接口，MCU通过这个IIC 接口来控制MPU6050，另外还有一个 IIC 接口： AUX_CL和AUX_DA ，这个接口可用来连外部从设备比如磁力计，这样就可以组成一个九轴传感器。VLOGIC是IO口电压，该引脚最低可以到1.8V电压， 我们一般直接连VDD即可。AD0是从IIC 接口（接 MCU）的地址控制引脚，该引脚控制的是IIC 地址的最低位。如果接 GND ，则 MPU6050的IIC地址是：0X68，如果接VDD，则是0X69。需要注意的是：这里的地址0x68和0x69是不包含用于数据传输的最低位的，因此并不是八位数据，如0x68表示的是110 1000，0x69表示的则是110 1001，通常最低位用于表示IIC主机的读取数据&#x2F;写数据模式。<br>self test为自检，自检的作用是可用来测试传感器的机械和电气结构。也就是说通过自检来测试芯片是否损坏。自检启动后，电路会使传感器工作并且产生输出信号。</p><h4 id="3-1-2-DMP"><a href="#3-1-2-DMP" class="headerlink" title="3.1.2 DMP"></a>3.1.2 DMP</h4><p>DMP就是MPU6050内部的运动引擎，全称Digital Motion Processor，直接输出四元数，可以减轻外围微处理器的工作负担且避免了繁琐的滤波和数据融合。</p><p>通过DMP我们在MCU上只需将四元数转为欧拉角即可得到角度。</p><h4 id="3-1-3-参数"><a href="#3-1-3-参数" class="headerlink" title="3.1.3 参数"></a>3.1.3 参数</h4><p>陀螺仪可测范围为±250，±500，±1000，±2000°&#x2F;秒（dps）</p><p>加速度计可测范围为±2，±4，±8，±16g。</p><h3 id="3-2-JY61P"><a href="#3-2-JY61P" class="headerlink" title="3.2 JY61P"></a>3.2 JY61P</h3><p>价格50元。一个等于n个6050.</p><h4 id="3-2-1-通信方式"><a href="#3-2-1-通信方式" class="headerlink" title="3.2.1 通信方式"></a>3.2.1 通信方式</h4><p>串口TTL、IIC，姿态在内部做了卡尔曼滤波算法后输出。</p><h4 id="3-2-2-参数"><a href="#3-2-2-参数" class="headerlink" title="3.2.2 参数"></a>3.2.2 参数</h4><p>陀螺仪可测范围为±250，±500，±1000，±2000°&#x2F;秒（dps）</p><p>加速度计可测范围为±2，±4，±8，±16g。</p><p>角度精度： X、Y轴0.2°，</p><p>回传速率：0.2-200Hz</p><h3 id="3-3-ICM20602"><a href="#3-3-ICM20602" class="headerlink" title="3.3 ICM20602"></a>3.3 ICM20602</h3><p>20元，价格适中，反馈频率高，适用！</p><h4 id="3-3-1-通信方式"><a href="#3-3-1-通信方式" class="headerlink" title="3.3.1 通信方式"></a>3.3.1 通信方式</h4><p>IIC、SPI（10M比特率）</p><h4 id="3-3-2-参数"><a href="#3-3-2-参数" class="headerlink" title="3.3.2 参数"></a>3.3.2 参数</h4><p>陀螺仪可测范围为±250，±500，±1000，±2000°&#x2F;秒（dps）</p><p>加速度计可测范围为±2，±4，±8，±16g。</p><h2 id="4、传感器校准"><a href="#4、传感器校准" class="headerlink" title="4、传感器校准"></a>4、传感器校准</h2><p>IMU校准十分重要，不可忽视。</p><h3 id="4-1-加速度计校准"><a href="#4-1-加速度计校准" class="headerlink" title="4.1 加速度计校准"></a>4.1 加速度计校准</h3><p>加速度计在不校准的情况下会产生偏差，不校准前大的偏差对于我们来说是不可接受的。</p><p>在校准后，我们在z方向上的加速度近似为 -9.8。</p><p>校准方法采用六面校准。即将IMU六面轮流放置在桌面上，持续记录一段时间。</p><h4 id="4-1-1-比例因子和偏移值求解"><a href="#4-1-1-比例因子和偏移值求解" class="headerlink" title="4.1.1 比例因子和偏移值求解"></a>4.1.1 比例因子和偏移值求解</h4><p>建立模型：</p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230306223920708.png" style="zoom: 67%;" /><p>accel_corr[3]是参考向量，也就是重力加速度向量</p><p>accel_T[3][3是转换矩阵，包含旋转和尺度缩放</p><p>accel_raw[3]是实际测量的加速度向量</p><p>accel_offs[3]是加速度数据的零点偏移</p><p>步骤如下：</p><p>1.求x、y、z轴加速度偏差。以x轴为例，分x轴向下和x轴向上，这时求二者各自的平均值后取二者平均值即偏差。</p><p>acc_x_bias &#x3D; (mean(x+) + mean(x-) ) *  0.5f;</p><p>2.下面求转换矩阵。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230306224043936.png"></p><p>求解可以得到转换矩阵。</p><p>3、主对角线元素即为比例因子a。</p><p>AccRel &#x3D; a*(AccRot-AccBias);</p><p>由于其他轴相比之下太小，可忽略不计。</p><h3 id="4-2-角速度计校准"><a href="#4-2-角速度计校准" class="headerlink" title="4.2 角速度计校准"></a>4.2 角速度计校准</h3><p>角速度计主要问题是零偏，利用以下方法解决：</p><p>1.将陀螺仪静止放置在桌面上，持续记录一段时间的数据。</p><p>2.将记录的多组数据求出平均值作为陀螺仪的3轴零偏。</p><p>最后在代码中对角速度计进行补偿即可。</p><p>关于误差原因等：<a href="https://zhuanlan.zhihu.com/p/24280315">陀螺仪的数据处理 - 知乎 (zhihu.com)</a></p><h3 id="4-3-磁力计校准"><a href="#4-3-磁力计校准" class="headerlink" title="4.3 磁力计校准"></a>4.3 磁力计校准</h3><p>采用的是八字校准的方法。</p><p>八字校准：将带有磁力计的设备在空中划八字，身体跟着转圈，使得磁力计在各个方向都有值。转几圈后采集数据导入matlab，我们可以发现得到的数据可以构成一个圆。通过样本拟合算法基本能精确计算出椭球球心位置，这表示了磁力计三轴的偏移量，而实际飞控代码中也应对磁力计初始数据减去该偏移量。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230305214756214.png"></p><p>首先，我们要知道通过磁力计获得什么？！当然是yaw值。</p><p>看以下画的图，有点丑但是没关系。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230305215652474.png" alt="image-20230305215652474"></p><p>如上，我们要计算yaw值，就要把磁力计圆的圆心归到原点上，即可完成磁力计校准。</p><h4 id="4-3-1-关于球心求解"><a href="#4-3-1-关于球心求解" class="headerlink" title="4.3.1 关于球心求解"></a>4.3.1 关于球心求解</h4><p>这里引用别人的一篇文章。</p><p><a href="https://blog.csdn.net/sunshine_zoe/article/details/78852978">(78条消息) 球面数据拟合算法简介_球面算法_sunshine_zoe的博客-CSDN博客</a></p><h2 id="5、数据融合"><a href="#5、数据融合" class="headerlink" title="5、数据融合"></a>5、数据融合</h2><h3 id="5-1-Mahony"><a href="#5-1-Mahony" class="headerlink" title="5.1 Mahony"></a>5.1 Mahony</h3><p><a href="https://zhuanlan.zhihu.com/p/438724546">Mahony姿态解算算法详解 - 知乎 (zhihu.com)</a></p><h3 id="5-2-ESKF"><a href="#5-2-ESKF" class="headerlink" title="5.2 ESKF"></a>5.2 ESKF</h3><p>ESKF（Error state Kalman Filter，误差卡尔曼滤波器）。在现代的大多数IMU系统中，人们往往使用误差状态卡尔曼滤波器（Error state Kalman filter, ESKF）而非原始状态的卡尔曼滤波器。</p><p>相比于传统KF，ESKF的优点可以总结如下：</p><ol><li>在旋转的处理上，ESKF的状态变量可以采用最小化的参数表达，也就是使用三维变量来表达旋转的增量。而传统KF需要用到四元数（4维）或者更高维的表达（旋转矩阵，9维），要不就得采用带有奇异性的表达方式（欧拉角）。</li><li>ESKF总是在原点附近，离奇异点较远，并且也不会由于离工作点太远而导致线性化近似不够的问题。</li><li>ESKF的状态量为小量，其二阶变量相对来说可以忽略。同时大多数雅可比矩阵在小量情况下变得非常简单，甚至可以用单位阵代替。</li><li>误差状态的运动学也相比原状态变量要来得更小，因为我们可以把大量更新部分放到原状态变量中。</li></ol><p>在ESKF中，我们通常把原状态变量称为<strong>名义状态变量</strong>（nominal state），然后把ESKF里的状态变量称为<strong>误差状态变量</strong>（error state）。ESKF整体流程如下：当IMU测量数据到达时，我们把它积分后，放入名义状态变量中。由于这种做法没有考虑噪声，其结果自然会快速漂移，于是我们希望把误差部分作为误差变量，放在ESKF中。ESKF内部会考虑各种噪声和零偏的影响，并且给出误差状态的一个高斯分布描述。同时，ESKF本身作为一种卡尔曼滤波器，也具有预测过程和修正过程，其中修正过程需要依赖IMU以外的传感器观测。当然，在修正之后，ESKF可以给出后验的误差高斯分布，随后我们可以把这部分误差放入名义状态变量中，并把ESKF置零，这样就完成了一次循环。</p><p>卡尔曼滤波更新为：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230307174406389.png"></p><p>ESKF的更新为：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230307174208505.png"></p><p>参考文献：</p><p>[1] <a href="https://zhuanlan.zhihu.com/p/441182819">简明ESKF推导 - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> summary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ahrs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023.3.5 牛客题库</title>
      <link href="/2023/03/05/Learn/%E7%89%9B%E5%AE%A2%E9%A2%98%E5%BA%93/2023.3.5%20%E7%89%9B%E5%AE%A2%E9%A2%98%E5%BA%93/"/>
      <url>/2023/03/05/Learn/%E7%89%9B%E5%AE%A2%E9%A2%98%E5%BA%93/2023.3.5%20%E7%89%9B%E5%AE%A2%E9%A2%98%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="2023-3-5"><a href="#2023-3-5" class="headerlink" title="2023.3.5"></a>2023.3.5</h1><h2 id="1、数字颠倒"><a href="#1、数字颠倒" class="headerlink" title="1、数字颠倒"></a>1、数字颠倒</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230305091143712.png"></p><h3 id="My-Code"><a href="#My-Code" class="headerlink" title="My Code"></a>My Code</h3><p>使用&#x2F;计算个数，使用%取最后一位数。特殊考虑0的情况！</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123;    int numIn &#x3D; 0;    cin &gt;&gt; numIn;    string str;    int count &#x3D; 0;    int numCount &#x3D; numIn;    if(numIn &#x3D;&#x3D; 0)&#123;        cout &lt;&lt; &#39;0&#39;;        retrun 0;    &#125;    while(numCount !&#x3D; 0)&#123;        numCount &#x2F;&#x3D; 10;        count++;    &#125;    for(int i&#x3D;0; i&lt;count; i++)&#123;        str[i] &#x3D; numIn%10 + &#39;0&#39;;        numIn &#x2F;&#x3D; 10;    &#125;    for(int j&#x3D;0; j&lt;count; j++)&#123;        cout &lt;&lt; str[j];    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Learn"><a href="#Learn" class="headerlink" title="Learn"></a>Learn</h3><p>取完数就输出，不要单独再跑一次，浪费资源</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;using namespace std;int main()&#123;    long num;    string str;    cin &gt;&gt; num;    if(num &#x3D;&#x3D; 0)&#123;        cout &lt;&lt; num;    &#125;    while(num &gt;&#x3D; 1)&#123;        int temp &#x3D; num % 10;        cout &lt;&lt; temp;        num &#x2F;&#x3D; 10;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>to_string( );可以把整形浮点等等转为字符</p><p>使用reverse_iterator反向迭代器适配器</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123;    int data;    string str;    cin&gt;&gt;data;    str &#x3D; to_string(data);    string::reverse_iterator it;    for(it&#x3D;str.rbegin();it!&#x3D;str.rend();it++)&#123;        cout&lt;&lt;*it;    &#125;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2、字符串反转"><a href="#2、字符串反转" class="headerlink" title="2、字符串反转"></a>2、字符串反转</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230305091126125.png"></p><h3 id="My-Code-1"><a href="#My-Code-1" class="headerlink" title="My Code"></a>My Code</h3><p>学习上一题解法。使用string反向迭代器。</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123;   string str;   getline(cin,str);   string::reverse_iterator it;   for(it&#x3D;str.rbegin();it!&#x3D;str.rend();it++)&#123;        cout &lt;&lt; *it;   &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Learn-1"><a href="#Learn-1" class="headerlink" title="Learn"></a>Learn</h3><p>None</p><h2 id="3、句子逆序"><a href="#3、句子逆序" class="headerlink" title="3、句子逆序"></a>3、句子逆序</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230305091418938.png"></p><h3 id="My-Code-2"><a href="#My-Code-2" class="headerlink" title="My Code"></a>My Code</h3><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123;    string str;    getline(cin,str);    int sp_pos &#x3D;str.length();    for(int i&#x3D;str.length(); i&gt;&#x3D;0; i--)&#123;        if(str[i]&#x3D;&#x3D;&#39; &#39;)&#123;            for(int j&#x3D;i+1; j&lt;sp_pos; j++)&#123;                cout &lt;&lt; str[j];            &#125;            cout&lt;&lt;&#39; &#39;;            sp_pos &#x3D; i;        &#125;        if(i &#x3D;&#x3D; 0)&#123;            for(int j&#x3D;i; j&lt;sp_pos; j++)&#123;                cout &lt;&lt; str[j];            &#125;        &#125;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Learn-2"><a href="#Learn-2" class="headerlink" title="Learn"></a>Learn</h3><p>没看到很好的解法</p><p>思路差不多，采用substr。</p><blockquote><p>语法<br>substr(size_type _Off &#x3D; 0,size_type _Count &#x3D; npos)<br>一种构造string的方法<br>形式 ： s.substr(pos, len)<br>返回值： string，包含s中从pos开始的len个字符的拷贝（pos的默认值是0，len的默认值是s.size() - pos，即不加参数会默认拷贝整个s）<br>异常 ：若pos的值超过了string的大小，则substr函数会抛出一个out_of_range异常；若pos+n的值超过了string的大小，则substr会调整n的值，只拷贝到string的末尾</p></blockquote><pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123;    string s;    while(getline(cin,s))&#123;        int right&#x3D;s.size(),left;        for(int i&#x3D;s.size()-1;i&gt;&#x3D;0;i--)&#123;            if(s[i]&#x3D;&#x3D;&#39; &#39;)&#123;                left&#x3D;i;                cout&lt;&lt;s.substr(left+1,right-left-1)&lt;&lt;&#39; &#39;;                right&#x3D;left;            &#125;        &#125;        cout&lt;&lt;s.substr(0,right);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4、字符串排序"><a href="#4、字符串排序" class="headerlink" title="4、字符串排序"></a>4、字符串排序</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230305101731054.png"></p><h3 id="My-Code-3"><a href="#My-Code-3" class="headerlink" title="My Code"></a>My Code</h3><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;bool cmp(string a,string b)&#123;    return a&lt;b;&#125;int main() &#123;    int num;    cin &gt;&gt; num;    string str[1001];    for(int i&#x3D;0; i&lt;num; i++)&#123;        cin &gt;&gt; str[i];    &#125;    sort(str,str+num,cmp);    for(int i&#x3D;0;i&lt;num;i++)&#123;        cout&lt;&lt;str[i]&lt;&lt;endl;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Learn-3"><a href="#Learn-3" class="headerlink" title="Learn"></a>Learn</h3><p>sort排序</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230305103543810.png"></p><h2 id="5、求int型正整数在内存中存储时1的个数"><a href="#5、求int型正整数在内存中存储时1的个数" class="headerlink" title="5、求int型正整数在内存中存储时1的个数"></a>5、求int型正整数在内存中存储时1的个数</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230305104458255.png"></p><h3 id="My-Code-4"><a href="#My-Code-4" class="headerlink" title="My Code"></a>My Code</h3><p>按位与最后一位，按位右移。</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;using namespace std;int main() &#123;    int num;    cin &gt;&gt; num;    int count &#x3D; 0;    while(num)&#123;        if((num&amp;1) &#x3D;&#x3D; 1)&#123;            count++;        &#125;        num&#x3D;num&gt;&gt;1;    &#125;    cout &lt;&lt; count;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Learn-4"><a href="#Learn-4" class="headerlink" title="Learn"></a>Learn</h3><p>采用%2取最后一位，直接累加。</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;#include &lt;cstdlib&gt;using namespace std;int main()&#123;int a;int count&#x3D;0;cin&gt;&gt;a;while(a&gt;0)&#123;count+&#x3D;a%2;a &#x3D; a&#x2F;2;&#125;cout&lt;&lt;count&lt;&lt;endl;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 牛客Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式C语言自我修养</title>
      <link href="/2023/03/04/Books/%E5%B5%8C%E5%85%A5%E5%BC%8FC%E8%AF%AD%E8%A8%80%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%EF%BC%9A%E4%BB%8E%E8%8A%AF%E7%89%87%E3%80%81%E7%BC%96%E8%AF%91%E5%99%A8%E5%88%B0%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/03/04/Books/%E5%B5%8C%E5%85%A5%E5%BC%8FC%E8%AF%AD%E8%A8%80%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%EF%BC%9A%E4%BB%8E%E8%8A%AF%E7%89%87%E3%80%81%E7%BC%96%E8%AF%91%E5%99%A8%E5%88%B0%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="嵌入式C语言自我修养：从芯片、编译器到操作系统"><a href="#嵌入式C语言自我修养：从芯片、编译器到操作系统" class="headerlink" title="嵌入式C语言自我修养：从芯片、编译器到操作系统"></a>嵌入式C语言自我修养：从芯片、编译器到操作系统</h1><p>From2.26——3.4</p><p>王利涛编著</p><p>101个笔记</p><p>前言</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>C语言是一门高级语言。C语言有高级语言的各种语法和特性，我们使用C语言可以构建大型的软件工程。有人说，C语言小打小闹，上不了大台面，编写不了大型的项目，这个说法其实也是站不住脚的：很多大型的GNU开源项目，其实都是使用C语言开发的，如Lua脚本语言、SQLite、Nginx、UNIX等。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>C语言也是一门低级语言。通过指针和位运算，我们可以修改内存和寄存器，从而直接控制CPU和硬件电路的运行。正是由于这种低级特性，很多操作系统内核、驱动都选择使用C语言进行开发。尤其在嵌入式开发领域，C语言被广泛使用，C语言是嵌入式工程师必须熟练掌握，甚至需要精通的一门编程语言。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>如果你想以后从事嵌入式开发、Linux内核驱动开发等工作，那么对C语言的要求就更高了：你不仅要掌握C语言的基本语法、项目管理、软件工程，还要对硬件电路、CPU、操作系统、编译原理等底层机制有完整的了解，需要对C语言进行进一步的强化学习和编程训练。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>从事嵌入式开发工作，尤其是嵌入式Linux内核驱动开发工作，你要精通的不仅仅是C语言，最好还要掌握和C语言相关的一系列基础理论和调试技能。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>一开始连指针都不会用、不敢用，看内核驱动代码一头雾水，越看越没底、越看越没自信，到现在不再犯怵，有自信和能力看懂内核中的代码细节和系统框架，这种进步不是天上掉下来的，也不是一不小心跌入山洞，捡到武功秘籍练出来的，而是不断地学习和实践、反复迭代、不断完善自己的知识体系和技能树，才慢慢达到的。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>半导体基础、CPU工作原理、硬件电路、计算机系统结构。 ● ARM体系结构与汇编指令、汇编程序设计、ARM反汇编分析。 ● 程序的编译、链接、安装、运行和重定位分析。 ● 熟悉C语言标准、ARM、GNU编译器的特性和扩展语法。 ● C语言的模块化编程思想，学会使用模块化思想去分析复杂的系统。 ● C语言的面向对象编程（简称OOP）思想，学会使用OOP思想去分析Linux内核驱动。 ● 对指针的深刻理解，对复杂指针的声明和灵活应用。 ● 对内存堆栈管理、内存泄漏、栈溢出、段错误的深刻理解。 ● 多任务并发编程思想，CPU和操作系统基础理论。</p><p>1.1 代码编辑工具：Vim</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>使用IDE唯一的缺陷就是这些IDE安装文件往往很大，编译创建工程时生成的临时文件很多，略显笨重和臃肿，大量的封装虽然更易于上手，方便用户编程，但也掩盖了底层编译、调试的过程</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>Vim是一款纯命令行操作、功能可扩展、高度可定制的文本编辑工具。</p><p>2.1 一颗芯片是怎样诞生的</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>光刻机主要用来将你设计的电路图映射到晶圆上，通过光照将你设计的电路图形投影到光刻胶上，光刻胶中被电路遮挡的部分被保留，溶解的部分就是掺杂的窗口。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>光刻机的作用是根据电路版图制作掩膜版，开凿各种掺杂窗口，然后通过离子注入，生成PN结，进而构建千千万万个元器件</p><p>2.2 一颗CPU是怎么设计出来的</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>为了编程方便，我们给每个二进制指令起一个别名，使用一个助记符表示，这些助记符就是汇编语言，由助记符组成的指令序列就是汇编程序。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>集成电路（Integrated Circuit，IC）设计一般分为模拟IC设计、数字IC设计和数模混合IC设计。</p><p>2.3 计算机体系结构</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>冯·诺依曼架构和哈弗架构。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>采用冯·诺依曼架构的计算机，其特点是程序中的指令和数据混合存储，存储在同一块存储器上</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>冯·诺依曼架构的特点是结构简单，工程上容易实现，所以很多现代处理器都采用这种架构，如X86、ARM7、MIPS等。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>哈弗架构的特点是：指令和数据被分开独立存储，它们分别被存放到程序存储器和数据存储器。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>使用哈弗架构的处理器运行效率更高，但缺点是CPU实现会更加复杂。8051系列的单片机采用的就是哈弗架构。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>为了减少内存瓶颈带来的影响，CPU引入了Cache机制：指令Cache和数据Cache，用来缓存数据和指令，提升计算机的运行效率。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>SoC芯片内部的Cache层采用哈弗架构，集成了指令Cache和数据Cache。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>SoC芯片外部则采用冯·诺依曼架构，工程实现简单。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>现代的计算机集合了这两种架构的优点，因此我们很难界定一款芯片到底是冯·诺依曼架构还是哈弗架构，我们就姑且称之为混合架构吧。</p><p>2.4 CPU性能提升：Cache机制</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>Cache一般用在高性能处理器中，并不是所有的处理器都有Cache，如C51系列单片机、cortex-M0、cortex-M1、cortex-M2、cortex-M3、cortex-M4系列的ARM处理器都没有Cache。为什么这些处理器不使用Cache呢？主要原因有三个：一是这些处理器都是低功耗、低成本处理器，在CPU内集成Cache会增加芯片的面积和发热量，不仅功耗增加，芯片的成本也会增加不少。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>二是这些处理器本来工作频率就不高（从几十兆赫到几百兆赫不等），和RAM之间不存在带宽问题，有些处理器甚至不需要外接RAM，直接使用片内SRAM就可满足面向控制领域的软件开发需求。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>三是使用Cache无法保证实时性。当缓存未命中时，CPU从RAM中读取数据的时间是不确定的，这是嵌入式实时控制场景无法接受的。</p><p>2.5 CPU性能提升：流水线</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>一条指令的执行一般要经过取指令、翻译指令、执行指令3个基本流程。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>流水线的本质其实就是拿空间换时间</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>一个时钟周期的时间变短，CPU主频也就相应提升，影响时钟周期时间长短的一个关键的制约因素就是CPU内部每一个工序执行单元的耗费时间。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>流水线的本质是拿空间换时间，流水线越深，电路会越复杂，就需要更多的组合逻辑电路和寄存器，芯片面积也就越大，功耗也就随之上升了。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>执行的程序指令如果是顺序结构的，没有中断或跳转，流水线确实可以提高执行效率。但是当程序指令中存在跳转、分支结构时，下面预取的指令可能就要全部丢掉了，需要到跳转的地方重新取指令执行。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTYuMjUgOC44MzkxOUM2LjI0OTUxIDYuMzM5MTkgOC4yNzM4MSA1LjAyOTY2IDEwLjA1OTUgNS4wMjk2NkMxMS44NDUyIDUuMDI5NjYgMTMuNjMxIDYuNjk2MzMgMTMuNjMxIDguMTI0OUMxMy42MzEgOC40MzQ3MyAxMy42NzkzIDguOTYyMjkgMTMuNzc2MSA5LjcwNzU2QzEzLjgyNzQgMTAuMTAzIDEzLjU5MTUgMTAuNDc5MyAxMy4yMTMyIDEwLjYwNTRMMTIuNzk3NiAxMC43NDM5VjEwLjkwNjhDMTIuNzk3NiAxMi4wNjY5IDExLjk5OTUgMTMuMDc0NiAxMC44NzAyIDEzLjM0MDNMMTAuNzczOCAxMy4zNjNWMTQuNTUzNUM5LjA3NDEzIDE0LjY3MTMgNy44ODM2NSAxNC4yNzQ1IDcuMjAyMzggMTMuMzYzQzcuMjAyMzggMTIuMTEyIDYuODg0OTIgMTAuNjA0MSA2LjI1IDguODM5MTlaTTkuNTIzODEgMTIuMzczTDEwLjU4MzkgMTIuMTIzNUMxMS4xNDg2IDExLjk5MDcgMTEuNTQ3NiAxMS40ODY4IDExLjU0NzYgMTAuOTA2OFY5Ljg0M0wxMi40OTM3IDkuNTI3NjRDMTIuNDE4OCA4LjkwNzM2IDEyLjM4MSA4LjQ0NjcgMTIuMzgxIDguMTI0OUMxMi4zODEgNy4zODE5NCAxMS4xNDA5IDYuMjc5NjYgMTAuMDU5NSA2LjI3OTY2QzguNzI0OSA2LjI3OTY2IDcuNjAwOTMgNy4yMTUyNSA3LjUwNjQzIDguNjQyMzVDOC4wNTcxOSAxMC4yMTk1IDguMzcwMjYgMTEuNjIyMiA4LjQzODI1IDEyLjg1ODlDOC42OTU5NCAxMy4wNjk0IDkuMDUyMDIgMTMuMjEzNCA5LjUyMzgxIDEzLjI4MDhWMTIuMzczWk0xMS45NjI0IDE0LjI3MDZDMTEuOTkyNSAxNC42MTQ1IDEyLjI5NTcgMTQuODY4OSAxMi42Mzk1IDE0LjgzODhDMTMuOTAwNCAxNC43Mjg1IDE0LjgzMyAxMy42MTY5IDE0LjcyMjcgMTIuMzU2MUMxNC42OTI3IDEyLjAxMjIgMTQuMzg5NSAxMS43NTc5IDE0LjA0NTYgMTEuNzg3OUMxMy43MDE4IDExLjgxOCAxMy40NDc0IDEyLjEyMTIgMTMuNDc3NSAxMi40NjVDMTMuNTI3NiAxMy4wMzgxIDEzLjEwMzcgMTMuNTQzNCAxMi41MzA2IDEzLjU5MzVDMTIuMTg2NyAxMy42MjM2IDExLjkzMjMgMTMuOTI2OCAxMS45NjI0IDE0LjI3MDZaIiBmaWxsPSIjOTlBMEFBIi8+Cjwvc3ZnPgo=" alt="underline"></p><p>中断、跳转等会把预取的指令丢掉</p><p>执行的程序指令如果是顺序结构的，没有中断或跳转，流水线确实可以提高执行效率。但是当程序指令中存在跳转、分支结构时，下面预取的指令可能就要全部丢掉了，需要到跳转的地方重新取指令执行。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>流水线越深，一旦预取指令失败，浪费和损失就会越严重，因为流水线中预取的几十条指令可能都要丢弃掉，此时流水线就发生了停顿，无法按照预期继续执行，这种情况我们一般称为流水线冒险（hazard）。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>引起流水线冒险的原因有很多种，根据类型不同，我们一般分为3种。 ● 结构冒险：所需的硬件正在为前面的指令工作。 ● 数据冒险：当前指令需要前面指令的运算数据才能执行。 ● 控制冒险：需根据之前指令的执行结果决定下一步的行为。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>我们在编写有跳转分支的程序时，要记得把大概率执行的代码分支放在前面，这样可以明显提高代码的执行效率。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>第二种方法是几个执行部件同时访问内存，一次性读取所有的操作数，这种数据操作类型称为单指令多数据（Single Instruction Multiple Data，SIMD）</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>采用SuperScalar结构的处理器，完全依赖流水线硬件去动态识别可并行执行的指令，并分发到对应的执行单元执行，不仅大大增加了硬件电路的复杂性，而且也存在极限。学者和工业界一致认为，同时执行8条指令将是SuperScalar结构的极限。</p><p>2.6 多核CPU</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>在相同的工艺制程下，通过不断优化CPU架构，从Cache、流水线、乱序执行、SIMD、多发射、指令预测等方面不断更新迭代，就可以设计出比别家公司性能更高、功耗更低的处理器。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>多核处理器则可以让多个任务真正地同时执行。在单核处理器通过指令级并行性能提升空间有限的情况下，通过多核在任务级做到真正并行，可以进一步提升CPU的整体性能。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>四核以上的CPU可以采用Ring Bus结构（如图2-47右侧图）：将总线和交叉开关结合起来，连成一个环状，相邻的两个Core通信效率最高，远离的两个Core之间可以通过开关路由通信。Intel的八核处理器一般都是采用这种结构的。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>面向众核处理器领域，目前比较流行的一种片上互连技术叫作片上网络（Net On Chip，NoC）</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>ARM推出了big.LITTLE架构，也就是大小核架构：一个处理器内部集成的有高性能的Core，也有低功耗的Core</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>在多核处理器设计中，还有一种技术叫超线程技术（Hyper-Threading，HT）</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>超线程技术通过增加一定的控制逻辑电路，使用特殊指令可以将一个物理处理器当两个逻辑处理器使用，每个逻辑处理器都可以分配一个线程运行，从而最大限度地提升CPU的资源利用率</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>我们通过增加一些控制逻辑电路，保存各个线程的状态，共享ALU、Cache等共享资源，就可以在一个物理Core上实现两个逻辑Core，操作系统可以给每个逻辑Core都分配1个线程运行。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>超线程技术其实就是“欺骗”操作系统，让操作系统认为它有更多的Core，给它分配更多的任务执行，通过减少CPU的空闲时间来提高CPU的利用率。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>截至目前，市面上还没有发现使用超线程技术的ARM处理器</p><p>2.7 后摩尔时代：异构计算的崛起</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>异构计算就是在SoC芯片内部集成不同架构的Core，如DSP、GPU、NPU、TPU等不同架构的处理单元，各个核心协同运算，让整个SoC性能得到充分发挥。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>GPU在浮点运算、大数据处理、密码破解、人工智能等领域都是一把好手，比CPU更适合做大规模并行的数据运算。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>GPU也是一种SIMD结构，但和CPU不同的是，它没有复杂的控制单元和Cache，却集成了几千个，甚至上万个计算核心</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>FPGA不依赖冯·诺依曼体系结构，也不要编译器编译指令，它直接将硬件描述语言翻译为晶体管门电路的组合，实现特定的算法和功能</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>在同构处理器时代，我们一般使用主频来衡量一个处理器的性能。而到了异构处理器时代，随着人工智能、大数据、多媒体编解码对海量数据的计算需求，我们一般使用浮点运算能力来衡量一个处理器的性能。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>NPU（Neural Network Processing Unit，神经网络处理器）是面向人工智能领域，基于神经网络算法，进行硬件加速的处理器统称。</p><p>2.8 总线与地址</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>在一个计算机系统中，CPU内部的寄存器是没有地址的，可直接通过寄存器名访问。而内存和外部设备控制器中的寄存器都需要有一个地址，然后CPU才能通过地址去读写这些外部设备控制器的寄存器，控制外部设备的运行，或者根据地址去读写指定的内存单元。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>当CPU想访问其中一个存储单元时，可通过CPU管脚发出一组信号，经过译码器译码，选中与这个信号对应的存储单元，然后就可以直接读写这块内存了。CPU管脚发出的这组信号，也就是存储单元对应的编号，即地址。</p><p>2.9 指令集与微架构</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>指令集最终的实现就是微架构，就是CPU内部的各种译码和执行电路。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>指令集在CPU处理器内部的具体硬件电路的实现，我们就称为微架构</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTYuMjUgOC44MzkxOUM2LjI0OTUxIDYuMzM5MTkgOC4yNzM4MSA1LjAyOTY2IDEwLjA1OTUgNS4wMjk2NkMxMS44NDUyIDUuMDI5NjYgMTMuNjMxIDYuNjk2MzMgMTMuNjMxIDguMTI0OUMxMy42MzEgOC40MzQ3MyAxMy42NzkzIDguOTYyMjkgMTMuNzc2MSA5LjcwNzU2QzEzLjgyNzQgMTAuMTAzIDEzLjU5MTUgMTAuNDc5MyAxMy4yMTMyIDEwLjYwNTRMMTIuNzk3NiAxMC43NDM5VjEwLjkwNjhDMTIuNzk3NiAxMi4wNjY5IDExLjk5OTUgMTMuMDc0NiAxMC44NzAyIDEzLjM0MDNMMTAuNzczOCAxMy4zNjNWMTQuNTUzNUM5LjA3NDEzIDE0LjY3MTMgNy44ODM2NSAxNC4yNzQ1IDcuMjAyMzggMTMuMzYzQzcuMjAyMzggMTIuMTEyIDYuODg0OTIgMTAuNjA0MSA2LjI1IDguODM5MTlaTTkuNTIzODEgMTIuMzczTDEwLjU4MzkgMTIuMTIzNUMxMS4xNDg2IDExLjk5MDcgMTEuNTQ3NiAxMS40ODY4IDExLjU0NzYgMTAuOTA2OFY5Ljg0M0wxMi40OTM3IDkuNTI3NjRDMTIuNDE4OCA4LjkwNzM2IDEyLjM4MSA4LjQ0NjcgMTIuMzgxIDguMTI0OUMxMi4zODEgNy4zODE5NCAxMS4xNDA5IDYuMjc5NjYgMTAuMDU5NSA2LjI3OTY2QzguNzI0OSA2LjI3OTY2IDcuNjAwOTMgNy4yMTUyNSA3LjUwNjQzIDguNjQyMzVDOC4wNTcxOSAxMC4yMTk1IDguMzcwMjYgMTEuNjIyMiA4LjQzODI1IDEyLjg1ODlDOC42OTU5NCAxMy4wNjk0IDkuMDUyMDIgMTMuMjEzNCA5LjUyMzgxIDEzLjI4MDhWMTIuMzczWk0xMS45NjI0IDE0LjI3MDZDMTEuOTkyNSAxNC42MTQ1IDEyLjI5NTcgMTQuODY4OSAxMi42Mzk1IDE0LjgzODhDMTMuOTAwNCAxNC43Mjg1IDE0LjgzMyAxMy42MTY5IDE0LjcyMjcgMTIuMzU2MUMxNC42OTI3IDEyLjAxMjIgMTQuMzg5NSAxMS43NTc5IDE0LjA0NTYgMTEuNzg3OUMxMy43MDE4IDExLjgxOCAxMy40NDc0IDEyLjEyMTIgMTMuNDc3NSAxMi40NjVDMTMuNTI3NiAxMy4wMzgxIDEzLjEwMzcgMTMuNTQzNCAxMi41MzA2IDEzLjU5MzVDMTIuMTg2NyAxMy42MjM2IDExLjkzMjMgMTMuOTI2OCAxMS45NjI0IDE0LjI3MDZaIiBmaWxsPSIjOTlBMEFBIi8+Cjwvc3ZnPgo=" alt="underline"></p><p>微机原理考试填空这题…</p><p>一个指令通常由操作码和操作数组成</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>一个指令通常由操作码和操作数组成</p><p>3.1 ARM体系结构</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>计算机的指令集一般可分为4种：复杂指令集（CISC）、精简指令集（RISC）、显式并行指令集（EPIC）和超长指令字指令集（VLIW）。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>● Load&#x2F;Store架构，CPU不能直接处理内存中的数据，要先将内存中的数据Load（加载）到寄存器中才能操作，然后将处理结果Store（存储）到内存中</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>ARM有桶型移位寄存器，单周期内可以完成数据的各种移位操作。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>ARM处理器有多种工作模式，如表3-1所示。应用程序正常运行时，ARM处理器工作在用户模式（User mode），当程序运行出错或有中断发生时，ARM处理器就会切换到对应的特权工作模式。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>R0～R3通常用来传递函数参数，R4～R11用来保存程序运算的中间结果或函数的局部变量等，R12常用来作为函数调用过程中的临时寄存器。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>R13寄存器又称为堆栈指针寄存器（Stack Pointer，SP），用来维护和管理函数调用过程中的栈帧变化，R13总是指向当前正在运行的函数的栈帧，一般不能再用作其他用途</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>ARM三级流水线中，PC指针的值等于当前正在运行的指令地址+8</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>当前处理器状态寄存器（Current Processor State Register，CPSR）主要用来表征当前处理器的运行状态。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>SPSR用来保存当前工作模式下的处理器现场，即将CPSR寄存器的值保存到当前工作模式下的SPSR寄存器。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>为了快速响应中断，减少中断现场保护带来的时间开销，在FIQ工作模式下，ARM处理器有自己独享的R8～R12寄存器。</p><p>3.2 ARM汇编指令</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>ARM处理器属于冯·诺依曼架构，程序和数据都存储在同一存储器上，内存空间和I&#x2F;O空间统一编址，ARM处理器对程序指令、数据、I&#x2F;O空间中外设寄存器的访问都要通过Load&#x2F;Store指令来完成。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>LDR&#x2F;STR指令用来在寄存器和内存之间输送数据</p><p>3.3 ARM寻址方式</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>比较常见的寻址方式有寄存器寻址、立即寻址、寄存器偏移寻址、寄存器间接寻址、基址寻址、多寄存器寻址、相对寻址等。</p><p>3.4 ARM伪指令</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>常见的ARM伪指令主要有4个：ADR、ADRL、LDR、NOP</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>ARM属于RISC架构，不能对内存中的数据直接操作，ARM通常会使用LDR&#x2F;STR这对加载&#x2F;存储指令，先将内存中的数据加载到寄存器，然后才能对寄存器中的数据进行操作，最后把寄存器中的处理结果存储到内存中。LDR伪指令的主要用途是将一个32位的内存地址保存到寄存器中。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>RISC指令的特点是单周期指令，指令的长度一般都是固定的。在一个32位的系统中，一条指令通常是32位的，指令中包括操作码和操作数</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>为了与ARM指令集中的加载指令LDR区别开来，LDR伪指令中的操作数前一般会有一个等于号&#x3D;，用来表示该指令是个伪指令。</p><p>3.5 ARM汇编程序设计</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>ARM汇编程序是以段（section）为单位进行组织的</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>ARM汇编程序通过ENTRY这个伪操作来标识汇编程序的运行入口，使用伪操作END来标识汇编程序的结束。</p><p>4.1 从源程序到二进制文件</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>程序的编译过程，其实就是将我们编写的C源程序翻译成CPU能够识别和运行的二进制机器指令的过程</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>编译器在编译程序时会根据这些函数声明对我们的源程序进行语法检查：检查实参类型、返回结果类型和函数声明的类型是否匹配。</p><p>4.3 程序的编译</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>编译过程可以分为以下6步。 （1）词法分析。 （2）语法分析。 （3）语义分析。 （4）中间代码生成。 （5）汇编代码生成。 （6）目标代码生成。</p><p>5.3 栈的管理</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>在Linux环境下，栈的起始地址一般就是进程用户空间的最高地址，紧挨着内核空间，栈指针从高地址往低地址增长</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>Linux默认给每一个用户进程栈分配8MB大小的空间</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>● 尽量不要在函数内使用大数组，如果确实需要大块内存，则可以使用malloc申请动态内存。 ● 函数的嵌套层数不宜过深。 ● 递归的层数不宜太深。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>一个函数内定义的局部变量、传递的实参都是保存在栈中的。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>每个函数的栈空间都被称为栈帧（Frame Pointer，FP）。每一个栈帧都使用两个寄存器FP和SP来维护，FP指向栈帧的底部，SP指向栈帧的顶部。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>最后我们做个小结：形参只有在函数被调用时才会在函数栈帧内分配存储单元，用来接收传进来的实参值。函数运行结束后，形参单元随着栈帧的销毁而被释放</p><p>5.4 堆内存管理</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>无论使用malloc()、calloc()还是realloc()函数，申请的内存使用结束后，都要通过free()函数释放掉，将这块内存还给系统，否则就会造成内存泄漏。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>Keil编译器只是实现了一个简化版的C标准库，叫作MicroLIB库，如图5-17所示。该函数库实现了C标准规定的大部分函数功能，并针对嵌入式平台做了很多优化，使其体积更小，更适合存储资源有限的嵌入式系统</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>裸机环境下一片连续的堆内存空间，经过多次小块内存的申请和释放后，就会造成内存碎片化，在内存中留下越来越多、越来越碎片化的空闲小内存块。此时如果再去申请一片连续的大块内存就会失败。正是由于这个原因，在嵌入式裸机环境下，一般不建议使用堆内存，遇到使用大块内存的地方，可以使用一个全局数组代替。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>自己实现堆内存管理，如采用内存池，将堆内存空间划分为固定大小的内存块，自己管理与维护内存的申请和释放来避免内存碎片的产生。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>在uC&#x2F;OS的堆内存管理中，内存分区是操作系统管理堆内存的基本单元，每个内存分区使用一个结构体来表示，我们称之为内存控制块。</p><p>6.3 宏构造“利器”：语句表达式</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>typeof是GNU C新增的一个关键字，用来获取数据类型，我们不用传参进去，让typeof直接获取！</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>￼ 在这个宏定义中，我们使用了typeof关键字来自动获取宏的两个参数类型。比较难理解的是（void）（&amp;x&#x3D;&#x3D;&amp;y）；这句话，看起来很多余，仔细分析一下，你会发现这条语句很有意思。它的作用有两个：一是用来给用户提示一个警告，对于不同类型的指针比较，编译器会发出一个警告，提示两种数据的类型不同。 ￼ 二是两个数进行比较运算，运算的结果却没有用到，有些编译器可能会给出一个warning，加一个（void）后，就可以消除这个警告。</p><p>6.6 属性声明：section</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>一个可执行文件主要由代码段、数据段、BSS段构成。代码段主要存放编译生成的可执行指令代码，数据段和BSS段用来存放全局变量、未初始化的全局变量。</p><p>6.10 内联函数</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>那么为什么还要用static修饰呢？因为我们使用inline定义的内联函数，编译器不一定会内联展开，那么当一个工程中多个文件都包含这个内联函数的定义时，编译时就有可能报重定义错误。而使用static关键字修饰，则可以将这个函数的作用域限制在各自的文件内，避免重定义错误的发生。</p><p>第7章 数据存储与指针</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>如果我们不能真正地理解指针，在使用的时候就可能遇到各种问题，如内存错误、段错误、指针类型不匹配等。</p><p>7.1 数据类型与存储</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>位（bit）是最小的存储单位</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>8个bit组成一字节（Byte），字节是计算机最基本的存储单位，也是最小的寻址单元，计算机通常以字节为单位进行寻址</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>在一个32位的计算机系统中，通常4字节组成一个字（Word），字是软件开发者常用的存储单位。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>一个数据在内存中有2种存储方式：高地址存储高字节数据，低地址存储低字节数据；或者高地址存储低字节数据，而低地址则存储高字节数据</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>ARM、X86、DSP一般都采用小端模式，而IBM、Sun、PowerPC架构的处理器一般都采用大端模式。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="underline"></p><p>一般来讲，小端模式低地址存储低字节数据，比较符合人类的思维习惯；而大端模式则更适合计算机的处理习惯：不需要考虑地址和数据的对应关系，以字节为单位，把数据从左到右，按照由低到高的地址顺序直接读写即可。</p><p>下面是一些代码方面的东西，就不看这本书了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下，这本书讲了挺多东西。从计算机体系结构到ARM再到内存管理等等。</p><p>在微机原理里学了，但基本是80×86的东西。ARM架构大体上还是一致的，有相同也有不同。</p><p>初步了解了一些东西吧，没有看的很透，当阅读一本书来看的。</p><p>还是不错。</p><p>下一步在各方面上要多下一点功夫，逐个熟悉击破。</p>]]></content>
      
      
      <categories>
          
          <category> Book </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2023.3.4 牛客题库</title>
      <link href="/2023/03/04/Learn/%E7%89%9B%E5%AE%A2%E9%A2%98%E5%BA%93/2023.3.4%20%E7%89%9B%E5%AE%A2%E9%A2%98%E5%BA%93/"/>
      <url>/2023/03/04/Learn/%E7%89%9B%E5%AE%A2%E9%A2%98%E5%BA%93/2023.3.4%20%E7%89%9B%E5%AE%A2%E9%A2%98%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="2023-3-4"><a href="#2023-3-4" class="headerlink" title="2023.3.4"></a>2023.3.4</h1><h2 id="1、质数因子"><a href="#1、质数因子" class="headerlink" title="1、质数因子"></a>1、质数因子</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230304084628356.png"></p><p>这题卡了好久，一直有一个案例不通过。原因是忽略了质数的质数是它本身！考虑的不够全面。</p><h3 id="My-Code"><a href="#My-Code" class="headerlink" title="My Code"></a>My Code</h3><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std;int main() &#123;    int numIn &#x3D; 0;    cin &gt;&gt; numIn;    for(int i&#x3D;2; i&lt;&#x3D;sqrt(numIn); i++)    &#123;        while(numIn % i &#x3D;&#x3D; 0)        &#123;            cout&lt;&lt; i &lt;&lt; &#39; &#39;;            numIn &#x3D; numIn&#x2F;i;        &#125;    &#125;    if(numIn!&#x3D;1)    &#123;        cout&lt;&lt; numIn &lt;&lt; &#39; &#39;;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Learn"><a href="#Learn" class="headerlink" title="Learn"></a>Learn</h3><p>想问题要全面！！先分析再写。</p><h2 id="2、取近似值"><a href="#2、取近似值" class="headerlink" title="2、取近似值"></a>2、取近似值</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230304091227629.png"></p><h3 id="My-Code-1"><a href="#My-Code-1" class="headerlink" title="My Code"></a>My Code</h3><p>思路：浮点转整型后面的小数会去掉，那如果浮点乘以10减去转型的乘以10，那么就得到了小数点后一位的数字。</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;using namespace std;int main() &#123;    double numIn &#x3D; 0;    long int num &#x3D; 0;    cin &gt;&gt; numIn;    long int numtemp &#x3D; (numIn*10);    numtemp -&#x3D; (int)numIn*10;    if(numtemp &lt; 5)&#123;        numtemp &#x3D; 0;    &#125;    else &#123;        numtemp &#x3D; 1;    &#125;    num &#x3D; (int)numIn + numtemp;    cout &lt;&lt; num;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Learn-1"><a href="#Learn-1" class="headerlink" title="Learn"></a>Learn</h3><p>乘以10%10就可以得到了….好像是。。晕</p><h2 id="3、合并表记录"><a href="#3、合并表记录" class="headerlink" title="3、合并表记录"></a>3、合并表记录</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230304100637701.png"></p><h3 id="My-Code-2"><a href="#My-Code-2" class="headerlink" title="My Code"></a>My Code</h3><p>代码出现问题如下：直接把index作为数组地址，那么就会在有限的内存内导致越界，index[11111111]太大了。此方法行不通。</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;#define Max 1111int main() &#123;    int numKey &#x3D; 0;    int index[Max]&#x3D;&#123;0&#125;;    cin &gt;&gt; numKey;    int numTemp[3]&#x3D;&#123;0&#125;;    for(int i&#x3D;0;i&lt;numKey;i++)    &#123;        cin&gt;&gt;numTemp[0];        cin&gt;&gt;numTemp[2];        index[(numTemp[0])] +&#x3D; numTemp[2];    &#125;    for(int i&#x3D;0;i&lt;Max;i++)    &#123;        if(index[i] !&#x3D; 0)        &#123;            cout &lt;&lt; i &lt;&lt; &#39; &#39; &lt;&lt; index[i]  &lt;&lt; endl;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Learn-2"><a href="#Learn-2" class="headerlink" title="Learn"></a>Learn</h3><p>使用图，如下。今天补一下STL的知识。</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;#include&lt;map&gt;using namespace std;int main()&#123;    int n;    map&lt;int,int&gt; m;    cin&gt;&gt;n;    for(int i&#x3D;0;i&lt;n;i++)    &#123;        pair&lt;int,int&gt; tmp;        cin&gt;&gt;tmp.first;        cin&gt;&gt;tmp.second;        if((m.find(tmp.first))!&#x3D;m.end())            m[tmp.first]+&#x3D;tmp.second;        else            m[tmp.first]&#x3D;tmp.second;    &#125;    for(auto it&#x3D;m.begin();it!&#x3D;m.end();it++)        cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;it-&gt;second&lt;&lt;endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4、提取不重复的整数"><a href="#4、提取不重复的整数" class="headerlink" title="4、提取不重复的整数"></a>4、提取不重复的整数</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230304111918681.png"></p><h3 id="My-Code-3"><a href="#My-Code-3" class="headerlink" title="My Code"></a>My Code</h3><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123;    string str;    getline(cin,str);    for(int i&#x3D;0;i&lt;str.length()&#x2F;2;i++)&#123;        char temp &#x3D; str[i];        str[i] &#x3D; str[str.length()-1-i];        str[str.length()-1-i] &#x3D; temp;    &#125;    for(int i&#x3D;0;i&lt;str.length();i++)&#123;        for(int j&#x3D;i+1;j&lt;str.length();j++)&#123;            if(str[i] &#x3D;&#x3D; str[j])            &#123;                str[j]&#x3D;-1;            &#125;        &#125;    &#125;    for(int i&#x3D;0;i&lt;str.length();i++)&#123;        if(str[i]!&#x3D;-1)        &#123;        cout &lt;&lt; str[i];        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Learn-3"><a href="#Learn-3" class="headerlink" title="Learn"></a>Learn</h3><p>提取最后一位，判断是否重复，不重复则打印，再提取倒数第二位。。。</p><p>判断重复方法即地址去判断，好用。</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;int main()&#123;    int n;    while(scanf(&quot;%d&quot;,&amp;n) !&#x3D; EOF)    &#123;        int a[15]&#x3D;&#123;0&#125;;        while(n !&#x3D; 0)        &#123;            int i&#x3D;n%10;            if(a[i] !&#x3D; 1)            &#123;                printf(&quot;%d&quot;,i);                a[i]&#x3D;1;            &#125;            n&#x3D;n&#x2F;10;        &#125;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5、字符个数统计"><a href="#5、字符个数统计" class="headerlink" title="5、字符个数统计"></a>5、字符个数统计</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230304112643904.png"></p><h3 id="My-Code-4"><a href="#My-Code-4" class="headerlink" title="My Code"></a>My Code</h3><p>思路：先将重复的字符置为’ ‘，再计算不是’ ‘的数量</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123;    string str;    getline(cin,str);    int Num &#x3D; 0;    for(int i&#x3D;0;i&lt;str.length();i++)    &#123;        for(int j&#x3D;i+1;j&lt;str.length();j++)        &#123;            if(str[i] &#x3D;&#x3D; str[j] &amp;&amp; str[i] !&#x3D; &#39; &#39;)            &#123;                str[j] &#x3D; &#39; &#39;;            &#125;        &#125;        if(str[i] !&#x3D; &#39; &#39;)&#123;            Num++;        &#125;    &#125;    cout &lt;&lt; Num;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Learn-4"><a href="#Learn-4" class="headerlink" title="Learn"></a>Learn</h3><p>采用set容器，使用set的insert去消除重复项，最后输出set的大小</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;int main()&#123;    char s;    set&lt;char&gt; a;    while(cin&gt;&gt;s)    &#123;        a.insert(s);    &#125;    cout&lt;&lt;a.size();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 牛客Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023.3.3 Note</title>
      <link href="/2023/03/03/Note/2023.3.3%E8%AE%B0/"/>
      <url>/2023/03/03/Note/2023.3.3%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>今天终于考完试了。</p><p>终结一下，好也不好。</p><p>好的是复习的还是可以的，知识点有去深入理解。</p><p>不好的是考的有点偏，填空到处挖，不会啊。</p><p>Very happy.</p><p>接下来就好好补一下代码能力和嵌入式知识吧。</p><p>加油。</p>]]></content>
      
      
      <categories>
          
          <category> Diary </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2023.3.3 牛客题库</title>
      <link href="/2023/03/03/Learn/%E7%89%9B%E5%AE%A2%E9%A2%98%E5%BA%93/2023.3.3%20%E7%89%9B%E5%AE%A2%E9%A2%98%E5%BA%93/"/>
      <url>/2023/03/03/Learn/%E7%89%9B%E5%AE%A2%E9%A2%98%E5%BA%93/2023.3.3%20%E7%89%9B%E5%AE%A2%E9%A2%98%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="2023-3-3"><a href="#2023-3-3" class="headerlink" title="2023.3.3"></a>2023.3.3</h1><h2 id="1、字符串最后一个单词的长度"><a href="#1、字符串最后一个单词的长度" class="headerlink" title="1、字符串最后一个单词的长度"></a>1、字符串最后一个单词的长度</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230303001832689.png"></p><h3 id="My-Code"><a href="#My-Code" class="headerlink" title="My Code"></a>My Code</h3><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string&gt;using namespace std;int main() &#123;    string str;    int len &#x3D; 0;    getline(cin,str);    for(int i&#x3D;0; i&lt;str.length(); i++)&#123;        if(str[i] &#x3D;&#x3D; &#39; &#39;)&#123;            len &#x3D; 0;                &#125;        else&#123;            len++;            &#125;    &#125;    cout &lt;&lt; len;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Learn"><a href="#Learn" class="headerlink" title="Learn"></a>Learn</h3><ol><li><p>包含头文件#include <string> </p><p>定义字符串String str;</p><p>字符串长度str.length()</p></li><li><p>int 后面一定要赋值！！</p></li><li><p>cin 遇空格或换行，会<strong>停止识别</strong>，如果你打算输入的字符串中带1个或多个空格，则采用getline把停止识别的符号设置为‘n’（即换行符），就能正确输入输出了。</p><p>例：getline(cin,str);</p></li><li><p>他人解法：</p></li></ol><ul><li>while(cin &gt;&gt; a)，使用一个istream的对象作为条件时，效果是检查流的状态。若流有效，则检测成功，返回true。当遇到文件结束符或者无效的输入（比如用一个字符来作为一个整型数的输入时），istream的对象状态会变为无效。</li><li>size和length这两个函数会返回 string 类型对象中的字符个数，且它们的执行效果相同。</li></ul><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;using namespace std;#include &lt;string&gt;int main() &#123;    string a;    int b;    while (cin &gt;&gt; a ) &#123; &#x2F;&#x2F; 注意 while 处理多个 case        b &#x3D; a.size();    &#125;    cout &lt;&lt; b &lt;&lt; endl;    return 0;&#125;&#x2F;&#x2F; 64 位输出请用 printf(&quot;%lld&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2、计算某字符"><a href="#2、计算某字符" class="headerlink" title="2、计算某字符"></a>2、计算某字符</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230303121425726.png"></p><h3 id="My-Code-1"><a href="#My-Code-1" class="headerlink" title="My Code"></a>My Code</h3><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123;    string str;    char str_check &#x3D; &#123;0&#125;;    int amount &#x3D; 0;    getline(cin,str);    cin &gt;&gt; str_check;    for(int i &#x3D; 0;i&lt; str.length();i++)&#123;        if(str[i] &#x3D;&#x3D; str_check )&#123;            amount++;        &#125;        else if(str_check &gt;&#x3D; 0x41 &amp;&amp; str_check &lt; 0x61)&#123;            if(str[i] &#x3D;&#x3D; str_check + 0x20 )&#123;                amount++;            &#125;        &#125;        else if(str_check &gt;&#x3D; 0x61 &amp;&amp; str_check &lt; 0x81)&#123;            if(str[i] &#x3D;&#x3D; str_check - 0x20 )&#123;                amount++;            &#125;        &#125;            &#125;    cout &lt;&lt; amount &lt;&lt;endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Learn-1"><a href="#Learn-1" class="headerlink" title="Learn"></a>Learn</h3><p>tolower(c);</p><p>函数说明：若参数 c 为大写字母则将该对应的小写字母返回。</p><p>返回值：返回转换后的小写字母，若不须转换则将参数c 值返回。</p><h2 id="3、明明的随机数"><a href="#3、明明的随机数" class="headerlink" title="3、明明的随机数"></a>3、明明的随机数</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230303195134209.png"></p><h3 id="My-Code-2"><a href="#My-Code-2" class="headerlink" title="My Code"></a>My Code</h3><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;using namespace std;int main() &#123;    int num &#x3D; 0;    int randnum[1000] &#x3D; &#123;0&#125;;    int nrepnum[500] &#x3D; &#123;0&#125;;    int k &#x3D; 0;    bool is_same;    cin &gt;&gt; num;    for(int i&#x3D;0; i &lt; num; i++)    &#123;        cin &gt;&gt; randnum[i];    &#125;    for(int j&#x3D;0; j &lt; num; j++)    &#123;        for(int a&#x3D;0; a &lt; k+1; a++)        &#123;            if(nrepnum[a] &#x3D;&#x3D; randnum[j])            &#123;                is_same &#x3D; true;                break;            &#125;        &#125;        if(is_same &#x3D;&#x3D; true)        &#123;            is_same &#x3D; false;        &#125;        else&#123;            nrepnum[k] &#x3D; randnum[j];            k++;        &#125;    &#125;    for(int g&#x3D;0; g&lt;k-1; g++)    &#123;        for(int h&#x3D;0 ; h&lt;k-1-g; h++)&#123;            if(nrepnum[h] &gt; nrepnum[h+1])&#123;                int temp &#x3D; 0;                temp &#x3D; nrepnum[h];                nrepnum[h] &#x3D; nrepnum[h+1];                nrepnum[h+1] &#x3D; temp;            &#125;        &#125;    &#125;    for(int b&#x3D;0; b&lt;k; b++)    &#123;        cout &lt;&lt; nrepnum[b] &lt;&lt;endl;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Learn-2"><a href="#Learn-2" class="headerlink" title="Learn"></a>Learn</h3><p>有点牛逼…</p><p>思路：取最大数组，循环遍历所有值</p><p><strong>将该值放入数组对应该位，使该位为true，</strong>这个操作直接删去了重复值，而且排好了序！！</p><p>循环遍历数组，判断数组对应位是否为true，是则输出。</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;using namespace std;int main() &#123;    int N, n;    while (cin &gt;&gt; N) &#123;        int a[1001] &#x3D; &#123; 0 &#125;;        while (N--) &#123;            cin &gt;&gt; n;            a[n] &#x3D; 1;        &#125;        for (int i &#x3D; 0; i &lt; 1001; i++)            if (a[i])                cout &lt;&lt; i &lt;&lt; endl;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4、字符串分隔"><a href="#4、字符串分隔" class="headerlink" title="4、字符串分隔"></a>4、字符串分隔</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230303195111093.png"></p><h3 id="My-Code-3"><a href="#My-Code-3" class="headerlink" title="My Code"></a>My Code</h3><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123;    string str;    getline(cin,str);    int j&#x3D;0;    for(int i&#x3D;0; i&lt;str.length(); i++)&#123;        cout &lt;&lt; str[i];        if( (i+1) %8 &#x3D;&#x3D; 0)        &#123;            cout &lt;&lt; endl;        &#125;    &#125;     j &#x3D; 8-str.length()%8;     if(j !&#x3D; 8)     &#123;        for(int k&#x3D;0; k&lt;j; k++)&#123;                cout &lt;&lt; &#39;0&#39;;        &#125;     &#125;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Learn-3"><a href="#Learn-3" class="headerlink" title="Learn"></a>Learn</h3><p>1.获取子字符串substr()</p><ul><li><p>函数原型: <code>string substr(size_t pos = 0, size_t len = npos) const;</code></p></li><li><p>功能: 从子字符串中获取想要的子字符串</p></li><li><p>参数：</p></li><li><ul><li>pos: 想要获取的子字符串的第一个字符的位置，如果pos等于字符串长度，则该函数返回一个空字符串，如果等于字符串长度，则该函数返回一个空的字符串，如果该长度大于字符串长度，则抛出一个out_of_range。 注：第一个字符的下标从0开始。</li><li>len： 子字符串中要包含的字符数, string::npos的值表示知道字符串末尾的所有字符。</li></ul></li><li><p>返回值：带有对象子字符串的字符串对象。</p></li></ul><p>2.insert()</p><p>basic_string&amp; insert (size_type pos, const basic_string&amp; str);</p><p>在原串下标为pos的字符前插入字符串str</p><p>basic_string&amp; insert (size_type pos, const basic_string&amp; str, size_type pos1, size_type n);</p><p>str从下标为pos1开始数的n个字符插在原串下标为pos的字符前</p><p>basic_string&amp; insert (size_type pos, size_type n, char c);</p><p>在原串下标为pos的字符前插入n个字符c</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;int main() &#123;    string s;    getline(cin, s);    while (true) &#123;        int len &#x3D; s.size();        if (len &lt;&#x3D; 8) &#123;            s.insert(s.end(), 8-len, &#39;0&#39;);            cout &lt;&lt; s &lt;&lt; endl;            if (!getline(cin, s)) break;        &#125;        else &#123;            cout &lt;&lt; s.substr(0, 8) &lt;&lt; endl;            s &#x3D; s.substr(8, len-8);        &#125;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5、进制转换"><a href="#5、进制转换" class="headerlink" title="5、进制转换"></a>5、进制转换</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230303195016718.png"></p><h3 id="My-Code-4"><a href="#My-Code-4" class="headerlink" title="My Code"></a>My Code</h3><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;math.h&gt;using namespace std;int main() &#123;    string hex;    long int dec &#x3D; 0;    getline(cin,hex);    int length &#x3D; hex.length();    for(int i&#x3D;0; i&lt;length-2 ; i++)&#123;        if(hex[length-i-1] &gt;&#x3D; &#39;A&#39; &amp;&amp; hex[length-i-1] &lt;&#x3D; &#39;F&#39;)        &#123;            hex[length-i-1] &#x3D; hex[length-i-1] - 55;        &#125;        else        &#123;            hex[length-i-1] &#x3D; hex[length-i-1] - 48;        &#125;        dec +&#x3D; pow(16,i)*hex[length-i-1];    &#125;    cout &lt;&lt; dec &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Learn-4"><a href="#Learn-4" class="headerlink" title="Learn"></a>Learn</h3><p>1、ASCII码</p><p>没有记住数字0的ASCII，注意数字0为0x30H，A为0x41H，a为0x61H</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230303195002392.png"></p><p>2、指数函数pow(x,y);</p><p>3、cin&gt;&gt;hex&gt;&gt;a; &#x2F;&#x2F;a为int</p><p>怎么看到这个答案我像个…笨….</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;using namespace std;int main()&#123;    int a;    while(cin&gt;&gt;hex&gt;&gt;a)&#123;    cout&lt;&lt;a&lt;&lt;endl;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 牛客Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023.2.14 Note</title>
      <link href="/2023/02/14/Note/2023.2.14%E8%AE%B0/"/>
      <url>/2023/02/14/Note/2023.2.14%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>准备开始为期两周的期末考。</p><p>提前一周准备。</p><p>考完再更！</p>]]></content>
      
      
      <categories>
          
          <category> Diary </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>QT_Chaprter1</title>
      <link href="/2023/02/12/Learn/QT/QT_Chaprter1/"/>
      <url>/2023/02/12/Learn/QT/QT_Chaprter1/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="QT-Chaprter1"><a href="#QT-Chaprter1" class="headerlink" title="QT_Chaprter1"></a>QT_Chaprter1</h1><h2 id="1、创建第一个QT程序"><a href="#1、创建第一个QT程序" class="headerlink" title="1、创建第一个QT程序"></a>1、创建第一个QT程序</h2><p>int main(int argc, char *argv[]){}</p><p>&#x2F;&#x2F;argc命令行变量的数量 argv命令行变量的数组</p><p>return a.exec();</p><p>&#x2F;&#x2F;让应用程序对象进入消息循环，点右上角×退出</p><h2 id="2、命名规范以及快捷键"><a href="#2、命名规范以及快捷键" class="headerlink" title="2、命名规范以及快捷键"></a>2、命名规范以及快捷键</h2><p>命名规范：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230212093911498.png"></p><p>快捷键：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230212093851189.png"></p><h2 id="3、QPushButton创建"><a href="#3、QPushButton创建" class="headerlink" title="3、QPushButton创建"></a>3、QPushButton创建</h2><pre class="line-numbers language-none"><code class="language-none">#include &lt;QPushButton&gt;myWidget::myWidget(QWidget *parent)    : QWidget(parent)    , ui(new Ui::myWidget)&#123;    ui-&gt;setupUi(this);    QPushButton *btn &#x3D; new QPushButton; &#x2F;&#x2F;创建一个按钮    btn-&gt;show(); &#x2F;&#x2F;show以顶层方式弹出窗口控件    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230212094311813.png" style="zoom:50%;" /><pre class="line-numbers language-none"><code class="language-none">myWidget::myWidget(QWidget *parent)    : QWidget(parent)    , ui(new Ui::myWidget)&#123;    ui-&gt;setupUi(this);    QPushButton *btn &#x3D; new QPushButton;    btn-&gt;setParent(this); &#x2F;&#x2F;让btn对象依赖在myWidget窗口中    btn-&gt;setText(&quot;第一个按钮&quot;); &#x2F;&#x2F;显示文本&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230212094428218.png" style="zoom:50%;" /><pre class="line-numbers language-none"><code class="language-none">QPushButton *btn2 &#x3D; new QPushButton(&quot;第二个按钮&quot;, this); &#x2F;&#x2F;创建第二个按钮btn2-&gt;move(100,100); &#x2F;&#x2F;移动btn2按钮resize(600,400); &#x2F;&#x2F;重置窗口大小setFixedSize(600,400); &#x2F;&#x2F;设置固定界面大小setWindowTitle(&quot;第一个窗口&quot;); &#x2F;&#x2F;设置窗口标题<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4、对象树"><a href="#4、对象树" class="headerlink" title="4、对象树"></a>4、对象树</h2><p>构造从父到子，析构从子到父。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230212100243605.png"></p><h2 id="5、QT坐标系"><a href="#5、QT坐标系" class="headerlink" title="5、QT坐标系"></a>5、QT坐标系</h2><p>以左上角为原点(0, 0)，X向右增加，Y向下增加</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230212101645676.png"></p><h2 id="6、信号和槽"><a href="#6、信号和槽" class="headerlink" title="6、信号和槽"></a>6、信号和槽</h2><p>Connect( 信号的发送者， 发送的具体信号， 信号的接受者， 信号的处理(槽) )</p><p>信号槽的优点：松散耦合，信号发送端和接受端本身是没有关联的，通过connect连接将两端耦合在一起。</p><pre class="line-numbers language-none"><code class="language-none">connect(btn2, &amp;QPushButton::clicked, this, &amp;QWidget::close);&#x2F;&#x2F;参数1 信号的发送者， 参数2 发送的信号， 参数3 信号的接受者， 参数4 处理的槽函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="7、自定义信号和槽"><a href="#7、自定义信号和槽" class="headerlink" title="7、自定义信号和槽"></a>7、自定义信号和槽</h2><p>前情：下课后，老师会触发一个信号，饿了，学生响应信号，请客吃饭。</p><pre class="line-numbers language-none"><code class="language-none">signals:    &#x2F;&#x2F;自定义信号写到signals下    &#x2F;&#x2F;返回值为void，只需要声明，不需要实现    &#x2F;&#x2F;可以有参数，可以重载    void hungry();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;slots 槽函数&#x2F;&#x2F;返回值void，需要声明，也需要实现&#x2F;&#x2F;可以有参数，可以重载void treat();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>emit 自定义信号 &#x2F;&#x2F;触发信号</p><h2 id="8、自定义信号和槽发生重载的解决"><a href="#8、自定义信号和槽发生重载的解决" class="headerlink" title="8、自定义信号和槽发生重载的解决"></a>8、自定义信号和槽发生重载的解决</h2><p>需要利用函数指针，明确指向函数的地址</p><pre class="line-numbers language-none"><code class="language-none">void(Teacher:: *teacherSingal)(QString) &#x3D; &amp;Teacher::hungry;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>QString 转成 char *</p><p>.ToUtf8() 转为 QByteArray</p><p>.Data() 转为 Char*</p><pre class="line-numbers language-none"><code class="language-none">void hungry(QString foodName);qDebug &lt;&lt; &quot;请老师吃饭，老师要吃：&quot; &lt;&lt;foodName.toUtf8().data();&#x2F;&#x2F;去掉引号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="9、Lambda表达式"><a href="#9、Lambda表达式" class="headerlink" title="9、Lambda表达式"></a>9、Lambda表达式</h2><p>C++ 11 新特性，用于定义并创建匿名的函数对象，以简化编程工作。</p><p>[]标识一个Lambda的开始，这部分必须存在，不能省略。</p><p>&#x3D; 值传递</p><p>mutalbe 修改拷贝，不修改本体</p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>80×86微处理器</title>
      <link href="/2023/02/11/Learn/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/3%E3%80%8180%C3%9786%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8/"/>
      <url>/2023/02/11/Learn/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/3%E3%80%8180%C3%9786%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="80×86微处理器"><a href="#80×86微处理器" class="headerlink" title="80×86微处理器"></a>80×86微处理器</h1><h2 id="8086-的存储器组织"><a href="#8086-的存储器组织" class="headerlink" title="8086 的存储器组织"></a>8086 的存储器组织</h2><h3 id="寻址空间和数据存储格式"><a href="#寻址空间和数据存储格式" class="headerlink" title="寻址空间和数据存储格式"></a>寻址空间和数据存储格式</h3><p>寻址空间是指<strong>存储器地址允许的最大范围</strong></p><p>当存储器按字节编址时，若地址总线为<strong>n</strong>位，CPU寻址范围位<strong>2^n^</strong>字节。</p><p>8086地址总线20位，寻址能力为1MB.</p><h3 id="存储器的分段结构和物理地址的形成"><a href="#存储器的分段结构和物理地址的形成" class="headerlink" title="存储器的分段结构和物理地址的形成"></a>存储器的分段结构和物理地址的形成</h3><p>任何一个内存单元的地址都可以用段地址和偏移地址来表示，其格式为：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230211140537957.png"></p><p>根据逻辑地址，可以求出它对应得物理地址：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230211140907181.png"></p><p>一般可将存储器划分为程序段、数据段、堆栈段和附加段。</p><p>程序段中存储程序得指令代码；</p><p>数据段和附加段中存储数据、中间结果和最后结果；</p><p>堆栈段存储压入堆栈的数据或状态信息。</p><h2 id="8086-微处理器内部结构"><a href="#8086-微处理器内部结构" class="headerlink" title="8086 微处理器内部结构"></a>8086 微处理器内部结构</h2><h3 id="8086-CPU的内部结构"><a href="#8086-CPU的内部结构" class="headerlink" title="8086 CPU的内部结构"></a>8086 CPU的内部结构</h3><p>CPU的任务是执行存放在存储器中的指令序列，即<strong>取指令</strong>和<strong>执行指令</strong></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230211152711341.png" alt="8086 CPU 逻辑结构框图"></p><h3 id="8086-CPU的寄存器结构"><a href="#8086-CPU的寄存器结构" class="headerlink" title="8086 CPU的寄存器结构"></a>8086 CPU的寄存器结构</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230211152904332.png" alt="8086 CPU内部寄存器"></p><p>标志寄存器</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230211154028224.png"></p><h2 id="8086-总线的工作周期"><a href="#8086-总线的工作周期" class="headerlink" title="8086 总线的工作周期"></a>8086 总线的工作周期</h2><p>一个时钟脉冲时间称为一个时钟周期。</p><p>CPU通过总线对存储器或外设I&#x2F;O接口进行一次访问所需要的时间称为总线周期。</p><p><strong>CPU执行一条指令完整过程：</strong></p><p>CPU执行某一个程序之前，先要把编译后的目标程序放到主存储器的某个区域。在启动执行后，CPU就发出读指令的命令，根据代码段寄存器CS和指令指针IP生成20位物理地址并将其输出到地址总线上，在存储器中读取相应的存储单元，把它送至CPU的指令寄存器中；CPU对读出指令经过译码器分析之后，发出一系列控制信号，执行指令规定的全部操作，控制各种信息在系统各部件之间传送。每条指令的执行由取指令、译码和执行等操作组成。</p><h2 id="8086-微处理器的时序"><a href="#8086-微处理器的时序" class="headerlink" title="8086 微处理器的时序"></a>8086 微处理器的时序</h2><h3 id="系统的复位与启动"><a href="#系统的复位与启动" class="headerlink" title="系统的复位与启动"></a>系统的复位与启动</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230211160442426.png" alt="image-20230211160442426"></p><p>由表可以看出，CPU复位时，代码段寄存器CS被初始化为FFFFH，而指令指针寄存器被初始化为0000H。因此，当CPU复位完成，再重新启动时，就会从主存地址为FFFF0H的位置开始执行指令。</p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微机原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>交流交流变流电路</title>
      <link href="/2023/02/10/Learn/%E7%94%B5%E5%8A%9B%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/4%E3%80%81%E4%BA%A4%E6%B5%81%E4%BA%A4%E6%B5%81%E5%8F%98%E6%B5%81%E7%94%B5%E8%B7%AF/"/>
      <url>/2023/02/10/Learn/%E7%94%B5%E5%8A%9B%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/4%E3%80%81%E4%BA%A4%E6%B5%81%E4%BA%A4%E6%B5%81%E5%8F%98%E6%B5%81%E7%94%B5%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="交流交流变流电路"><a href="#交流交流变流电路" class="headerlink" title="交流交流变流电路"></a>交流交流变流电路</h1><h2 id="交流调压电路"><a href="#交流调压电路" class="headerlink" title="交流调压电路"></a>交流调压电路</h2><h3 id="单相交流调压电路"><a href="#单相交流调压电路" class="headerlink" title="单相交流调压电路"></a>单相交流调压电路</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230210115607498.png"></p><h3 id="三相交流调压电路"><a href="#三相交流调压电路" class="headerlink" title="三相交流调压电路"></a>三相交流调压电路</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230210140146631.png"></p><h2 id="其他交流电力控制电路"><a href="#其他交流电力控制电路" class="headerlink" title="其他交流电力控制电路"></a>其他交流电力控制电路</h2><h3 id="交流调功电路"><a href="#交流调功电路" class="headerlink" title="交流调功电路"></a>交流调功电路</h3><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230210141904728.png" style="zoom:50%;" /><p><strong>工作原理：</strong></p><p>和交流调压电路的电路形式完全相同，只是控制方式不同。</p><p>通过改变接通周波数与断开周波数的比值来调节负载所消耗的平均功率。</p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电力电子技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>直流直流变流电路</title>
      <link href="/2023/02/10/Learn/%E7%94%B5%E5%8A%9B%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/3%E3%80%81%E7%9B%B4%E6%B5%81%E7%9B%B4%E6%B5%81%E5%8F%98%E6%B5%81%E7%94%B5%E8%B7%AF/"/>
      <url>/2023/02/10/Learn/%E7%94%B5%E5%8A%9B%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/3%E3%80%81%E7%9B%B4%E6%B5%81%E7%9B%B4%E6%B5%81%E5%8F%98%E6%B5%81%E7%94%B5%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="直流直流变流电路"><a href="#直流直流变流电路" class="headerlink" title="直流直流变流电路"></a>直流直流变流电路</h1><p>也称斩波电路。</p><p>功能是将直流电变为另一固定电压或可调电压的直流电。</p><h2 id="基本斩波电路"><a href="#基本斩波电路" class="headerlink" title="基本斩波电路"></a>基本斩波电路</h2><h3 id="降压斩波电路"><a href="#降压斩波电路" class="headerlink" title="降压斩波电路"></a>降压斩波电路</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230210102425262.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230210102539872.png" alt="基本数量关系"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230210104957414.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230210105024103.png"></p><h3 id="升压斩波电路"><a href="#升压斩波电路" class="headerlink" title="升压斩波电路"></a>升压斩波电路</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230210105558105.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230210105637163.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230210105826271.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230210105937868.png"></p><h3 id="升降压斩波电路和Cuk斩波电路"><a href="#升降压斩波电路和Cuk斩波电路" class="headerlink" title="升降压斩波电路和Cuk斩波电路"></a>升降压斩波电路和Cuk斩波电路</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230210110020982.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230210110645255.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230210111148519.png" alt="Cuk斩波电路及其等效电路"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230210111221459.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230210111234174.png"></p><h3 id="Sepic斩波电路和Zeta斩波电路"><a href="#Sepic斩波电路和Zeta斩波电路" class="headerlink" title="Sepic斩波电路和Zeta斩波电路"></a>Sepic斩波电路和Zeta斩波电路</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230210111337606.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230210111348429.png"></p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电力电子技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微型计算机系统基础</title>
      <link href="/2023/02/10/Learn/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/2%E3%80%81%E5%BE%AE%E5%9E%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/02/10/Learn/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/2%E3%80%81%E5%BE%AE%E5%9E%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="微型计算机系统基础"><a href="#微型计算机系统基础" class="headerlink" title="微型计算机系统基础"></a>微型计算机系统基础</h1><h2 id="微型计算机系统结构"><a href="#微型计算机系统结构" class="headerlink" title="微型计算机系统结构"></a>微型计算机系统结构</h2><h3 id="微处理器与微型计算机"><a href="#微处理器与微型计算机" class="headerlink" title="微处理器与微型计算机"></a>微处理器与微型计算机</h3><p><strong>微处理器</strong>是将运算器和控制器集成在一起的中央处理器部件。</p><p><strong>微型计算机</strong>是指以微处理器为核心，配上内存储器、输入&#x2F;输出接口电路及系统总线所组成的计算机。</p><p><strong>微型计算机系统</strong>是指以微型计算机为中心，配以相应的外围设备、电源、辅助电路，以及控制微型计算机工作的系统软件所构成的计算机系统。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230210091824141.png"></p><h3 id="微处理器中主要的寄存器"><a href="#微处理器中主要的寄存器" class="headerlink" title="微处理器中主要的寄存器"></a>微处理器中主要的寄存器</h3><p><strong>指令寄存器</strong>用来保存当前正在执行的一条指令。</p><p><strong>程序计数器</strong>指出下一条将要执行的指令在主存储器中的地址。</p><p><strong>地址寄存器</strong>用来保存CPU当前所访问的主存单元的地址。</p><h3 id="微型计算机中的存储器与地址分配"><a href="#微型计算机中的存储器与地址分配" class="headerlink" title="微型计算机中的存储器与地址分配"></a>微型计算机中的存储器与地址分配</h3><p>对I&#x2F;O端口的编址通常由两种方法：一种是I&#x2F;O端口和内存储器统一编址；另一种是I&#x2F;O端口单独编址。</p><h2 id="输入-x2F-输出系统"><a href="#输入-x2F-输出系统" class="headerlink" title="输入&#x2F;输出系统"></a>输入&#x2F;输出系统</h2><p>直接存储器存取(DMA)方式是一种<strong>完全由硬件执行</strong>I&#x2F;O交换的方式。</p><p>中断：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230210101615261.png" alt="中断处理示意图"></p><p>中断源：内部中断源和外部中断源</p><p>中断的过程一般包括中断请求、中断响应、中断处理和中断返回。</p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微机原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统概述</title>
      <link href="/2023/02/10/Learn/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/1%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
      <url>/2023/02/10/Learn/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/1%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="计算机系统概述"><a href="#计算机系统概述" class="headerlink" title="计算机系统概述"></a>计算机系统概述</h1><h2 id="计算机中的数据表示与编码"><a href="#计算机中的数据表示与编码" class="headerlink" title="计算机中的数据表示与编码"></a>计算机中的数据表示与编码</h2><p><strong>数与数制</strong></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209163055786.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209163110832.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209163124268.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209163251973.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209163850855.png"></p><p><strong>原码：</strong></p><p>对于二进制数，正数的原码就是它本身，负数的原码符号位取1，数值部分是真值的绝对值。</p><p><strong>反码：</strong></p><p>对于二进制数，正数的反码就是它本身，负数的反码符号位取1，数值部分按位取反。</p><p><strong>补码：</strong></p><p>对于二进制数，正数的补码就是它本身，负数的补码符号位取1，数值部分按位取反末位加1。</p><p><strong>ASCII码：</strong></p><p>A 十进制：65  十六进制：41</p><p>a 十进制：97  十六进制：61</p><h2 id="逻辑电路基础"><a href="#逻辑电路基础" class="headerlink" title="逻辑电路基础"></a>逻辑电路基础</h2><p>数电学了。略。</p><p><strong>触发器</strong>是计算机<strong>记忆装置的基本单元</strong>，也是构成<strong>时序电路的基础</strong>。</p><p>由n个触发器可以组成一个n位寄存器。</p><h2 id="计算机系统概述-1"><a href="#计算机系统概述-1" class="headerlink" title="计算机系统概述"></a>计算机系统概述</h2><p><strong>计算机系统的组成</strong></p><p>计算机由运算器、存储器、控制器、输入设备和输出设备五大基本部件组成。</p><p>冯诺依曼结构的计算机是以<strong>运算器</strong>为中心的，输入&#x2F;输出设备与存储器之间的数据传送都要通过运算器。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209202254324.png" alt="图1.14 以运算器为中心的计算机结构"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209202327580.png"></p><p>将早期运算器和控制器集成在一片集成电路中，称为中央处理器。(CPU)</p><p>CPU和内存构成计算机的主机。</p><p>主机以外的其他硬件设备都称为外设。</p><p>现代计算机系统是以<strong>存储器</strong>为中心的，采用总线结构，在系统总线上配置一定容量的存储器和一定数目的I&#x2F;O接口电路，以及相对应的I&#x2F;O设备而构成的。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209203518589.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209203607434.png"></p><p><strong>存储系统</strong></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230210090915755.png"></p><p><strong>内存容量</strong></p><p>内存容量是以字节为单位计算的。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230210091143510.png"></p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微机原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆变电路</title>
      <link href="/2023/02/09/Learn/%E7%94%B5%E5%8A%9B%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2%E3%80%81%E9%80%86%E5%8F%98%E7%94%B5%E8%B7%AF/"/>
      <url>/2023/02/09/Learn/%E7%94%B5%E5%8A%9B%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/2%E3%80%81%E9%80%86%E5%8F%98%E7%94%B5%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="逆变电路"><a href="#逆变电路" class="headerlink" title="逆变电路"></a>逆变电路</h1><h2 id="换流方式"><a href="#换流方式" class="headerlink" title="换流方式"></a>换流方式</h2><h3 id="逆变电路的基本工作原理"><a href="#逆变电路的基本工作原理" class="headerlink" title="逆变电路的基本工作原理"></a>逆变电路的基本工作原理</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209121740519.png"></p><h3 id="换流方式分类"><a href="#换流方式分类" class="headerlink" title="换流方式分类"></a>换流方式分类</h3><p>换流：电流从一个支路向另一个支路转移的过程，也称为换相。</p><p>研究换流方式主要是研究如何使器件关断。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209121959959.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209122123624.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209122204002.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209122225353.png"></p><p><strong>换流方式</strong></p><ol><li>器件换流</li><li>电网换流</li><li>负载换流</li><li>强迫换流</li></ol><p><strong>换流方式总结</strong></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209122254783.png"></p><h2 id="电压型逆变电路"><a href="#电压型逆变电路" class="headerlink" title="电压型逆变电路"></a>电压型逆变电路</h2><h3 id="单相电压型逆变电路"><a href="#单相电压型逆变电路" class="headerlink" title="单相电压型逆变电路"></a>单相电压型逆变电路</h3><h4 id="半桥逆变电路"><a href="#半桥逆变电路" class="headerlink" title="半桥逆变电路"></a>半桥逆变电路</h4><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209143902543.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209144005971.png"></p><h4 id="全桥逆变电路"><a href="#全桥逆变电路" class="headerlink" title="全桥逆变电路"></a>全桥逆变电路</h4><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209144218865.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209144801708.png"></p><h4 id="带中心抽头变压器的逆变电路"><a href="#带中心抽头变压器的逆变电路" class="headerlink" title="带中心抽头变压器的逆变电路"></a>带中心抽头变压器的逆变电路</h4><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209144940822.png"></p><h3 id="三相电压型逆变电路"><a href="#三相电压型逆变电路" class="headerlink" title="三相电压型逆变电路"></a>三相电压型逆变电路</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209145815895.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209150542037.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209150604537.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209150651633.png" alt="基本数量关系"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209151911980.png"></p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209152355444.png"></p><h2 id="电流型逆变电路"><a href="#电流型逆变电路" class="headerlink" title="电流型逆变电路"></a>电流型逆变电路</h2><h3 id="单相电流型逆变电路"><a href="#单相电流型逆变电路" class="headerlink" title="单相电流型逆变电路"></a>单相电流型逆变电路</h3><h4 id="单相桥式电流型逆变电路"><a href="#单相桥式电流型逆变电路" class="headerlink" title="单相桥式电流型逆变电路"></a>单相桥式电流型逆变电路</h4><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209152535263.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209152616819.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209152653652.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209152714375.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209152729764.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209152748304.png"></p><h3 id="三相电流型逆变电路"><a href="#三相电流型逆变电路" class="headerlink" title="三相电流型逆变电路"></a>三相电流型逆变电路</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209152844759.png"></p><h2 id="多重逆变电路和多电平逆变电路"><a href="#多重逆变电路和多电平逆变电路" class="headerlink" title="多重逆变电路和多电平逆变电路"></a>多重逆变电路和多电平逆变电路</h2><h3 id="多重逆变电路"><a href="#多重逆变电路" class="headerlink" title="多重逆变电路"></a>多重逆变电路</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209153240116.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209153315196.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209153426115.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209153437525.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209153456740.png"></p><h3 id="多电平逆变电路"><a href="#多电平逆变电路" class="headerlink" title="多电平逆变电路"></a>多电平逆变电路</h3><p>略</p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电力电子技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整流电路</title>
      <link href="/2023/02/09/Learn/%E7%94%B5%E5%8A%9B%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/1%E3%80%81%E6%95%B4%E6%B5%81%E7%94%B5%E8%B7%AF/"/>
      <url>/2023/02/09/Learn/%E7%94%B5%E5%8A%9B%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/1%E3%80%81%E6%95%B4%E6%B5%81%E7%94%B5%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="整流电路"><a href="#整流电路" class="headerlink" title="整流电路"></a>整流电路</h1><h2 id="单相可控整流电路"><a href="#单相可控整流电路" class="headerlink" title="单相可控整流电路"></a>单相可控整流电路</h2><h3 id="单相半波可控整流电路"><a href="#单相半波可控整流电路" class="headerlink" title="单相半波可控整流电路"></a>单相半波可控整流电路</h3><h4 id="带电阻负载工作"><a href="#带电阻负载工作" class="headerlink" title="带电阻负载工作"></a>带电阻负载工作</h4><p>电阻负载的特点是电压与电流成正比，两者波形相同。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208131556763.png" alt="单相半波可控整流电路"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208131819686.png" alt="电路波形"></p><p>变压器T起变换电压和隔离的作用。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208133731101.png" alt="基本数量关系"></p><h4 id="带阻感负载工作"><a href="#带阻感负载工作" class="headerlink" title="带阻感负载工作"></a>带阻感负载工作</h4><p>阻感负载的特点是电感对电流变化有抗拒作用，使得流过电感的电流不能发生突变。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208134428496.png" alt="带阻感负载的单相半波可控整流电路及其波形"></p><p>电路分析：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208135120122.png"></p><p>在整流电路的负载两端并联一个二极管，称为续流二极管，用VD<del>R</del>表示。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208145000292.png" alt="单相半波带阻感负载有续流二极管的电路及波形"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208145053071.png" alt="电路分析"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208150626105.png" alt="基本数量关系"></p><p>单相半波可控整流电路的特点是简单，但输出脉冲大，变压器二次侧电流中含直流分量，造成变压器铁芯<strong>直接磁化</strong>。为使变压器铁芯不饱和，需增大铁芯截面积，增大了设备的容量。</p><h3 id="单相桥式全控整流电路"><a href="#单相桥式全控整流电路" class="headerlink" title="单相桥式全控整流电路"></a>单相桥式全控整流电路</h3><h4 id="带电阻负载工作-1"><a href="#带电阻负载工作-1" class="headerlink" title="带电阻负载工作"></a>带电阻负载工作</h4><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208151911944.png" alt="单相全控桥式带电阻负载时的电路及波形"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208151956112.png" alt="电路分析"></p><p><strong>基本数量关系：</strong></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208152356937.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208152624495.png"></p><h4 id="带阻感负载工作-1"><a href="#带阻感负载工作-1" class="headerlink" title="带阻感负载工作"></a>带阻感负载工作</h4><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208152924294.png" alt="单相桥式全控整流电路带阻感负载时的电路及波形"></p><p><strong>电路分析：</strong></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208153455205.png"></p><p><strong>数量关系：</strong></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208154044578.png"></p><h4 id="带反电动势负载工作"><a href="#带反电动势负载工作" class="headerlink" title="带反电动势负载工作"></a>带反电动势负载工作</h4><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208160515079.png" alt="单相桥式全控整流电路接反电动势——电阻负载时的电路及波形"></p><p><strong>工作情况：</strong></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208160617766.png"></p><p><strong>电流断续：</strong></p><ul><li>i<del>d</del>波形在一周期内有部分时间为0的情况，称为电流断续。</li><li>负载为直流电动机时，如果出现电流断续，则电动机的机械特性很软。</li><li>为了克服此缺点，一般在主电路中直流输出侧串联一个平波电抗器。</li><li>为保证电流连续所需的电感量L可由下式求出：</li></ul><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208161815024.png"></p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208161931826.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208161944131.png"></p><h3 id="单相全波可控整流电路"><a href="#单相全波可控整流电路" class="headerlink" title="单相全波可控整流电路"></a>单相全波可控整流电路</h3><h4 id="带电阻负载工作-2"><a href="#带电阻负载工作-2" class="headerlink" title="带电阻负载工作"></a>带电阻负载工作</h4><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208162303847.png" alt="单相全波可控整流电路及波形"></p><p><strong>电路分析</strong></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208162401109.png"></p><p><strong><u>单相全波与单相全控桥的区别：</u></strong></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208162540902.png"></p><p>从上述后两点考虑，单相全波电路有利于在低输出电压的场合应用。</p><h3 id="单相桥式半控整流电路"><a href="#单相桥式半控整流电路" class="headerlink" title="单相桥式半控整流电路"></a>单相桥式半控整流电路</h3><p>与全控电路在电阻负载时的工作情况相同。</p><h4 id="带阻感负载工作-2"><a href="#带阻感负载工作-2" class="headerlink" title="带阻感负载工作"></a>带阻感负载工作</h4><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208163145575.png" alt="单相桥式半控整流电路，有续流二极管，阻感负载时的电路及波形"></p><p><strong>电路分析：</strong></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208165245605.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208171926755.png"></p><p><strong>单相桥式半控整流电路的另一种解法：</strong></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208172041729.png" alt="单相桥式半控整流电路的另一种接法"></p><p>这样可以省去续流二极管VD<del>R</del>，续流由VD<del>3</del>和VD<del>4</del>来实现。</p><p>这种接法的两个晶闸管阴极电位不同，二者的触发电路需要隔离。</p><h2 id="三相可控整流电路"><a href="#三相可控整流电路" class="headerlink" title="三相可控整流电路"></a>三相可控整流电路</h2><h3 id="三相半波可控整流电路"><a href="#三相半波可控整流电路" class="headerlink" title="三相半波可控整流电路"></a>三相半波可控整流电路</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208195144548.png" alt="三相半波可控整流电路共阴极接法电阻负载时的电路及α=0°时的波形"></p><p><strong>电路分析：</strong></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208195731714.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208212739385.png" alt="三相半波可控整流电路，电阻负载，α=30°时的波形"></p><p>当α&#x3D;30°时，负载电流处于连续和断续的临界状态，各相仍导电120°。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208213425241.png" alt="三相半波可控整流电路，电阻负载，α=60°时的波形"></p><p>当α&gt;30°时，负载电流断续。</p><p><strong>基本数量关系：</strong></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208213629214.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208215556971.png"></p><h4 id="阻感负载"><a href="#阻感负载" class="headerlink" title="阻感负载"></a>阻感负载</h4><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208220607031.png"></p><p><strong>基本数量关系：</strong></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208220944083.png" alt="image-20230208220944083"></p><p> <img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208225103313.png"></p><h3 id="三相桥式全控整流电路"><a href="#三相桥式全控整流电路" class="headerlink" title="三相桥式全控整流电路"></a>三相桥式全控整流电路</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209093710352.png" alt="三相桥式全控整流电路原理图"></p><h4 id="带电阻负载工作-3"><a href="#带电阻负载工作-3" class="headerlink" title="带电阻负载工作"></a>带电阻负载工作</h4><p>电路分析：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209093905989.png"></p><p><strong>一些特点：</strong></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209095354972.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209095437316.png"></p><h4 id="带阻感负载工作-3"><a href="#带阻感负载工作-3" class="headerlink" title="带阻感负载工作"></a>带阻感负载工作</h4><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209095518445.png" alt="电路分析"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209095532687.png" alt="基本数量关系"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209095552645.png"></p><h2 id="变压器漏感对整流电路的影响"><a href="#变压器漏感对整流电路的影响" class="headerlink" title="变压器漏感对整流电路的影响"></a>变压器漏感对整流电路的影响</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209101227701.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209101539090.png" alt="基本数量关系"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209102415733.png" alt="换向重叠角"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209102518736.png"></p><h2 id="整流电路的谐波和功率因数"><a href="#整流电路的谐波和功率因数" class="headerlink" title="整流电路的谐波和功率因数"></a>整流电路的谐波和功率因数</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209105533862.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209105556310.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209110551864.png"></p><h2 id="整流电路的有源逆变工作状态"><a href="#整流电路的有源逆变工作状态" class="headerlink" title="整流电路的有源逆变工作状态"></a>整流电路的有源逆变工作状态</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209112146759.png"></p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电力电子技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电力电子课设</title>
      <link href="/2023/02/09/Learn/%E7%94%B5%E5%8A%9B%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/%E7%94%B5%E5%8A%9B%E7%94%B5%E5%AD%90%E8%AF%BE%E8%AE%BE/"/>
      <url>/2023/02/09/Learn/%E7%94%B5%E5%8A%9B%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/%E7%94%B5%E5%8A%9B%E7%94%B5%E5%AD%90%E8%AF%BE%E8%AE%BE/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="电力电子课设"><a href="#电力电子课设" class="headerlink" title="电力电子课设"></a>电力电子课设</h1><h2 id="一、选题背景与设计指标"><a href="#一、选题背景与设计指标" class="headerlink" title="一、选题背景与设计指标"></a><strong>一、</strong>选题背景与设计指标</h2><h3 id="1-选题背景介绍"><a href="#1-选题背景介绍" class="headerlink" title="1.选题背景介绍"></a>1.选题背景介绍</h3><p>本课程作为本学院《电力电子技术》课程的配套课程设计课，以开放式、学生实践的形式开出。课程从理论联系实际的角度出发，掌握各种电力电子电路的结构、工作原理、控制方法、设计计算方法及实验技能，并将各种变换电路组合实现电能的变换和控制，让学生体会将理论知识运用于实际的过程和团队合作的意义，同时培养学生的创新精神、激发学生的创新意识、增强学生的动手和实践能力。</p><p>通过本次课程设计，学生将学会利用仿真平台实现整流电路、Buck斩波电路和逆变电路的设计，本在各自的课程要求上通过对电路参数的调节实现整流电路输出软启动、降压斩波和单相逆变输出期望电压波形。</p><h3 id="2-电路设计指标"><a href="#2-电路设计指标" class="headerlink" title="2.电路设计指标"></a>2.电路设计指标</h3><p>根据课程设计相关课程要求，本报告所需要实现的设计指标如下表所示：</p><table><thead><tr><th><strong>设计指标</strong></th><th><strong>要求</strong></th></tr></thead><tbody><tr><td>可控整流输出电压</td><td>150V</td></tr><tr><td>可控整流软启动时间</td><td>2.6s</td></tr><tr><td>降压斩波输出电压</td><td>80V</td></tr><tr><td>降压斩波开关频率</td><td>15KHz</td></tr><tr><td>逆变输出频率</td><td>150Hz</td></tr><tr><td>逆变输出幅值</td><td>38V</td></tr><tr><td>逆变开关频率</td><td>26KHz</td></tr></tbody></table><h2 id="二、设计思路"><a href="#二、设计思路" class="headerlink" title="二、设计思路"></a>二、设计思路</h2><p>本次课程设计的相关电路按照功能可以划分为：</p><p>1）触发脉冲产生电路：通过电压比较器和晶体管积分电路实现整流电路移相触发脉冲的产生。</p><p>2）单相整流电路：通过全桥整流和滤波环节实现将220V&#x2F;50Hz的交流输入电压转化为直流电压，并实现2.6s的电路软启动。</p><p>3）直流斩波电路：利用Buck斩波电路和电容元件将整流电路的输出电压降低为要求输出值；</p><p>4）单相逆变电路：通过PWM调制的方式将斩波电路的输出直流电压转化为要求幅值和频率的正弦交流电输出；</p><h2 id="三、过程论述"><a href="#三、过程论述" class="headerlink" title="三、过程论述"></a>三、过程论述</h2><h3 id="1-仿真电路的主要组成"><a href="#1-仿真电路的主要组成" class="headerlink" title="1.仿真电路的主要组成"></a>1.仿真电路的主要组成</h3><p>由本报告“二、设计思路”分析可得，本课程设计的仿真电路主要由四个部分组成，方框图表示如下：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209114715959.png" alt="图3-1：基本仿真电路方框图">                    </p><h3 id="2-基本仿真实验"><a href="#2-基本仿真实验" class="headerlink" title="2.基本仿真实验"></a>2.基本仿真实验</h3><h4 id="1）可控整流仿真Simulink图与仿真波形"><a href="#1）可控整流仿真Simulink图与仿真波形" class="headerlink" title="1）可控整流仿真Simulink图与仿真波形"></a>1）可控整流仿真Simulink图与仿真波形</h4><h5 id="i-主电路原理及仿真电路图"><a href="#i-主电路原理及仿真电路图" class="headerlink" title="i.主电路原理及仿真电路图"></a>i.主电路原理及仿真电路图</h5><p>典型的单相桥式全控整流电路由晶闸管构成桥式开关，其原理图及其输出电压ud波形如下图所示：</p><p> <img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209114740144.png" alt="图3-2：典型的单相桥式全控整流电路及其相关波形"></p><p>由图可知，若在电路的输出侧加上大电容进行低频滤波，则可以从电容两端取得一个较为平缓的直流输出电压。因此，Simulink中对该电路的仿真原理图如下图所示：</p><p> <img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209114755917.png" alt="图3-3：Simulink中搭建的单相桥式全控整流电路"></p><p>其中，与电容并接的二极管起续流作用；</p><h5 id="ii-相触发电路原理及仿真电路图"><a href="#ii-相触发电路原理及仿真电路图" class="headerlink" title="ii.相触发电路原理及仿真电路图"></a>ii.相触发电路原理及仿真电路图</h5><p>移相触发电路将为整流电路提供合适的触发脉冲，通过改变整流电路晶闸管的导通角，使整流电路输出不同的整流电压。</p><p>典型的移相触发电路由以下几个部分组成：</p><p>1）同步环节</p><p>2）锯齿波产生环节</p><p>3）触发脉冲产生环节</p><p>经过课本的电路分析可知，从模块的角度上看，该触发电路对外暴露X、Y端子，利用这两个端子可将同类型的触发电路进行串联，实现双触发脉冲的产生。<br>考虑到本次课设所采用的触发电路是针对单相整流电路的，因此，本课设将采用另一种形式的触发电路实现，其Simulink电路仿真原理图如下图所示：</p><p> <img src="C:/Users/Zunrong%20Guo/AppData/Roaming/Typora/typora-user-images/image-20230209114812164.png" alt="图3-4：本课设所采用的移相触发电路"></p><p>下面对该电路的工作原理进行详细分析：</p><p>1）同步环节：将电源电压通过变压器同步到触发电路侧，并利用电压比较器产生两路矩形波；</p><p>2）锯齿波产生环节：</p><p>将同步环节的两路矩形波送入由晶体管构成的积分电路中，即可从电容侧得到锯齿波；</p><p>积分电路原理：晶体管与射极电阻、以及与be极相并联的二极管构成了简易恒流源电路。当电压比较器输出负电压时，电容将与二极管、电压比较器的输出端构成放电回路，电容迅速放电，电容电压uc &#x3D; 0；当电压比较器输出正电压时，二极管截止，集电极回路的电容被恒流源充电，故uc线性增长，从而在电容正极得到锯齿波。</p><p>3）脉冲产生环节</p><p>将锯齿波与一个恒定的可调直流电压送入电压比较器，即可得到触发脉冲，脉冲前沿由锯齿波斜坡与直流电压的交点位置决定。STW1、STW2为锯齿波波形，峰值为5V。Ref_U为输入电压比较器的直流电压；波形图下方为触发脉冲输出。可见触发脉冲的脉宽由锯齿波和直流电压共同决定 ；</p><h5 id="iii-软启动实现"><a href="#iii-软启动实现" class="headerlink" title="iii.软启动实现"></a>iii.软启动实现</h5><p>由上述分析可以联想到：实现电路软启动要求整流电路的触发角α能随时间改变，即触发脉冲产生电路能产生一组脉冲前沿随时间变化的触发脉冲；</p><p>故软启动问题可以简化为求取一条电压值随时间发生变化的直流电压，并将该直流电压输入到脉冲产生环节的电压比较器即可。</p><p>利用Simulink中的可变电阻及斜坡信号模型，即可完成时变直流电压的产生，相关电路仿真原理图如下：</p><p> <img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209114828903.png" alt="图3-5：软启动部分的电路仿真原理图"></p><p>​       iv.     相关参数整定</p><p>1）整流输出电压相关参数：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209114846161.png" alt="图3-6：整流输出的电路参数计算"></p><p>由前述对电路原理的分析可知：影响整流输出电压的参数实际上为饱和非线性环节的限幅下限值。由二分法试凑可迅速得出限幅下限为0.175。</p><p>通过试凑方式的参数整定，本人也感受到了Simulink进行电路仿真的优势所在。</p><p>2）软启动时间相关参数：</p><p>观察整流电路的输出波形可知，输出波形增大到达稳态的转折处大致与时变直流电压的转折点在同一个时间点上。而当触发角α &#x3D; 180°时，此时直流电压的幅值应为锯齿波电压的幅值，即5V，对应斜坡信号值为0.5；</p><p>根据软启动时间的定义可知：整流电路需在t &#x3D; 3s时输出150 * 80% V &#x3D; 120V的直流电压。故先计算使输出为120V时的限幅下限值为0.21598，之后计算0到2.6秒内的斜坡环节斜率：</p><p> <img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209114859931.png" alt="图3-7：软启动部分的电路参数计算"></p><p>将计算值代入Simulink斜坡环节，同时限幅下限更改为0.175（150V电压输出对应的下限值），微调参数k &#x3D; -0.1095，即可使t &#x3D; 2.6s时输出电压为120V，达到要求； </p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209114922477.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209114933908.png" alt="图3-8：软启动部分的电路仿真图"></p><h4 id="2）Buck斩波仿真Simulink图与波形"><a href="#2）Buck斩波仿真Simulink图与波形" class="headerlink" title="2）Buck斩波仿真Simulink图与波形"></a>2）Buck斩波仿真Simulink图与波形</h4><h5 id="i-Buck降压斩波电路原理及仿真电路图"><a href="#i-Buck降压斩波电路原理及仿真电路图" class="headerlink" title="i.Buck降压斩波电路原理及仿真电路图"></a>i.Buck降压斩波电路原理及仿真电路图</h5><p>典型的Buck降压斩波电路由全控型电力电子器件、续流二极管以及电感元件组成，全控器件采用PWM调制控制开关动作。其电路原理及输出波形图如下：</p><p> <img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209114952065.png" alt="图3-9：Buck降压斩波电路原理图及输出波形图"></p><p>该电路的输出电压均值Ud与输入电压E的关系为：</p><p>Ud &#x3D; αE</p><p>其中，α为PWM波的导通占空比，通过调节PWM占空比，即可调节输出电压的平均值；</p><p> <img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209115006150.png" alt="图3-10：Buck部分的电路仿真图"></p><h5 id="ii-相关参数整定"><a href="#ii-相关参数整定" class="headerlink" title="ii.相关参数整定"></a>ii.相关参数整定</h5><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209115032026.png"></p><p>降压斩波开关频率为15KHz，周期为Period&#x3D;1&#x2F;15KHz&#x3D;0.00006667</p><p>   输入电压为150V，输出电压为80V。由降压斩波电路的输入、输出电压关系：Ud &#x3D; αE可得，当要求输出电压为80V直流电时，理想占空比应为 α &#x3D; 53.33%。</p><p>设置PWM占空比为该值，并在此基础上利用二分法试凑进行小范围调整，可得该电路模块在 α &#x3D; 61%时，恰能输出80V直流电，其测量波形可见下方的“仿真波形展示”。</p><h5 id="iii-仿真波形展示"><a href="#iii-仿真波形展示" class="headerlink" title="iii.仿真波形展示"></a>iii.仿真波形展示</h5><p> Buck斩波电路的仿真波形图如下图所示，其中由测量结果可知，该电路模块达到输出80V直流电压的指标要求：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209115051084.png" alt="图3-11：Buck斩波电路的Simulink仿真波形"></p><h4 id="3）单相逆变仿真Simulink图与波形"><a href="#3）单相逆变仿真Simulink图与波形" class="headerlink" title="3）单相逆变仿真Simulink图与波形"></a>3）单相逆变仿真Simulink图与波形</h4><h5 id="i-双极性PWM调制原理"><a href="#i-双极性PWM调制原理" class="headerlink" title="i.双极性PWM调制原理"></a>i.双极性PWM调制原理</h5><p>接下来以单相桥式逆变电路为例，分析双极性PWM调制的原理：</p><p>1）PWM调制的原理保证：面积等效原理。即对于感性电路，在窄脉冲电压源作用之后，回路上的电流响应规律与脉冲电压的形状基本无关；</p><p>2）PWM调制：PWM调制即将信号波所蕴含的规律“加载”到一组PWM波上，信号波在某一时刻附近的幅值由PWM在这里时刻附近的占空比大小进行表征。</p><p>3）基本的PWM调制由单极性调制和双极性调制，两者对正弦信号进行调制时产生的PWM波对比如下图所示。其中左图为单极性调制（信号波在一个极性周期内，对应的PWM幅值只能有两种取值，例如0和+Ud）、右图为双极性调制（信号波在一个极性周期内，对应的PWM幅值有三种取值：0和±Ud）：</p><p> <img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209115104407.png" alt="图3-12：单极性PWM调制（左）与双极性PWM调制（右）"></p><h5 id="ii-单相桥式逆变电路的原理"><a href="#ii-单相桥式逆变电路的原理" class="headerlink" title="ii.单相桥式逆变电路的原理"></a>ii.单相桥式逆变电路的原理</h5><p>若将经过正弦波调制后的PWM波（称为SPWM）作用于由全控型器件（例如IGBT）组成的全控桥，全控桥输入直流电压，并使全控桥带阻感负载，则负载输出的电流波形将近似为正弦波，且该正弦波与被调制的正弦信号基本同步，这即为单相桥式逆变电路的原理。</p><p>Simulink中的单相桥式逆变电路仿真图如下图所示：</p><p> <img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209115118824.png" alt="图3-13：Simulink中的单相桥式逆变电路仿真图"></p><p>其中，仿真图下方的电路部分利用逻辑运算电路，实现了SPWM双极性调制。IGBT全控桥带阻感负载，并在电阻两端取电压输出。由上述分析可知，输出电流近似正弦波时，经过电阻负载上的电压也应为近似正弦波的波形；</p><h5 id="iii-相关参数整定"><a href="#iii-相关参数整定" class="headerlink" title="iii.相关参数整定"></a>iii.相关参数整定</h5><p>1）逆变开关频率：1&#x2F;26KHz&#x3D;0.00003846</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209115147988.png"></p><p>2） 逆变输出频率：Frequency&#x3D;150<em>2</em>Π</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209115158697.png"></p><p>3）逆变输出赋值：信号波幅值&#x2F;载波幅值&#x3D;输出电压&#x2F;输入电压</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209115222099.png"></p><h5 id="iv-仿真波形展示"><a href="#iv-仿真波形展示" class="headerlink" title="iv.仿真波形展示"></a>iv.仿真波形展示</h5><p>​<br> 双极性PWM调制电路及单相逆变电路的Simulink仿真波形图如下图所示，且由图示测量结果可知，电路输出电压达到指标要求：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209115234903.png" alt="图3-14：Simulink中的单相桥式逆变电路波形图"></p><h4 id="4）综合仿真Simulink图与波形"><a href="#4）综合仿真Simulink图与波形" class="headerlink" title="4）综合仿真Simulink图与波形"></a>4）综合仿真Simulink图与波形</h4><p> 综合电路仿真图和波形如下图所示：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209115249551.png" alt="图3-15：Simulink综合电路仿真图"></p><p> <img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209115302556.png"></p><p> <img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209115314954.png" alt="图3-16：Simulink综合电路波形图"></p><h3 id="3-附加扩展"><a href="#3-附加扩展" class="headerlink" title="3.   附加扩展"></a><strong>3.</strong>   <strong>附加扩展</strong></h3><p>本设计采用PI闭环形式对Buck电路进行闭环控制，让斩波输出电压与80V做差，为偏差信号，因为I是波形在时间上的积分，在软启动阶段有较大的偏差，导致PI控制器的输出在短时间内无法到达稳定，所以在0时刻加入P控制，在3s后再加入I控制减少误差。如图所示：</p><p> <img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209115330546.png" alt="图3-17：Buck电路闭环仿真图"></p><p>仿真效果较好，波形如图所示。</p><p> <img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230209115343868.png" alt="图3-18：Buck电路闭环波形图"></p><h2 id="四、结果分析"><a href="#四、结果分析" class="headerlink" title="四、结果分析"></a>四、结果分析</h2><p>由综合电路的仿真波形图测量可知，仿真电路的各项实际指标与期望指标的对比如下表所示：</p><table><thead><tr><th><strong>设计指标</strong></th><th><strong>要求</strong></th><th><strong>实际指标</strong></th></tr></thead><tbody><tr><td>可控整流输出电压</td><td>150V</td><td>150.18V</td></tr><tr><td>可控整流软启动时间</td><td>2.6s</td><td>2.64s</td></tr><tr><td>降压斩波输出电压</td><td>80V</td><td>79.85V</td></tr><tr><td>降压斩波开关频率</td><td>15KHz</td><td>15.0KHz</td></tr><tr><td>逆变输出频率</td><td>150Hz</td><td>150.0Hz</td></tr><tr><td>逆变输出幅值</td><td>38V</td><td>38.84V</td></tr><tr><td>逆变开关频率</td><td>26KHz</td><td>26KHz</td></tr></tbody></table><p>   对比可知，本课程设计所设计的仿真电路基本符合指标要求；</p><h2 id="五、课程设计总结"><a href="#五、课程设计总结" class="headerlink" title="五、课程设计总结"></a>五、课程设计总结</h2><p>在本次课程设计中，我学会将课程上所学到的各种分散的电路功能模块结合到一起，在Simulink仿真平台进行各个模块的设计与调参，并且最终实现了一个简易的AC-AC变频电路（市电到190Hz正弦交流电）。</p><p>通过本次课程设计，我对各个电路环节在实际工程中的用法有了一个初步的了解，并且通过仿真平台学习到了一些工程上的知识，例如整流电路的输出接大电容进行输出滤波、单相桥式PWM逆变电路输出接小电容滤去输出电压的高频毛刺……。</p><p>另外，本次课程设计将PWM调制和移相调制巧妙地结合起来，而我通过对这两种调制方式的电路实现中也直观感受出了PWM调制的优势所在（上一次这么深刻的感悟是在电力电子技术的第一次实验课上，用PWM调制控制一个单相全控整流桥）。</p><p>最后，在Simulink上设计电路以及调参的过程还是挺有趣的。</p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电力电子技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Front-matter</title>
      <link href="/2023/02/09/Learn/%E6%9D%82/blog%20title/"/>
      <url>/2023/02/09/Learn/%E6%9D%82/blog%20title/</url>
      
        <content type="html"><![CDATA[<h2 id="文章-Front-matter-介绍"><a href="#文章-Front-matter-介绍" class="headerlink" title="文章 Front-matter 介绍"></a>文章 Front-matter 介绍</h2><h3 id="Front-matter-选项详解"><a href="#Front-matter-选项详解" class="headerlink" title="Front-matter 选项详解"></a>Front-matter 选项详解</h3><p><code>Front-matter</code> 选项中的所有内容均为<strong>非必填</strong>的。但我仍然建议至少填写 <code>title</code> 和 <code>date</code> 的值。</p><table><thead><tr><th>配置选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td><code>Markdown</code> 的文件标题</td><td>文章标题，强烈建议填写此选项</td></tr><tr><td>date</td><td>文件创建时的日期时间</td><td>发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td>author</td><td>根 <code>_config.yml</code> 中的 <code>author</code></td><td>文章作者</td></tr><tr><td>img</td><td><code>featureImages</code> 中的某个值</td><td>文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <code>http://xxx.com/xxx.jpg</code></td></tr><tr><td>top</td><td><code>true</code></td><td>推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td></tr><tr><td>hide</td><td><code>false</code></td><td>隐藏文章，如果<code>hide</code>值为<code>true</code>，则文章不会在首页显示</td></tr><tr><td>cover</td><td><code>false</code></td><td><code>v1.0.2</code>版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td>coverImg</td><td>无</td><td><code>v1.0.2</code>版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td>password</td><td>无</td><td>文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td>toc</td><td><code>true</code></td><td>是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td></tr><tr><td>mathjax</td><td><code>false</code></td><td>是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td></tr><tr><td>summary</td><td>无</td><td>文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td>categories</td><td>无</td><td>文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td>tags</td><td>无</td><td>文章标签，一篇文章可以多个标签</td></tr><tr><td>keywords</td><td>文章标题</td><td>文章关键字，SEO 时需要</td></tr><tr><td>reprintPolicy</td><td>cc_by</td><td>文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个</td></tr></tbody></table><blockquote><p><strong>注意</strong>:</p><ol><li>如果 <code>img</code> 属性不填写的话，文章特色图会根据文章标题的 <code>hashcode</code> 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章的特色图<strong>各有特色</strong>。</li><li><code>date</code> 的值尽量保证每篇文章是唯一的，因为本主题中 <code>Gitalk</code> 和 <code>Gitment</code> 识别 <code>id</code> 是通过 <code>date</code> 的值来作为唯一标识的。</li><li>如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 <code>_config.yml</code> 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：<a href="http://tool.oschina.net/encrypt?type=2">开源中国在线工具</a>、<a href="http://encode.chahuo.com/">chahuo</a>、<a href="http://tool.chinaz.com/tools/hash.aspx">站长工具</a>。</li><li>您可以在文章md文件的 front-matter 中指定 reprintPolicy 来给单个文章配置转载规则</li></ol></blockquote><p>以下为文章的 <code>Front-matter</code> 示例。</p><h3 id="最简示例"><a href="#最简示例" class="headerlink" title="最简示例"></a>最简示例</h3><pre class="line-numbers language-none"><code class="language-none">---title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="最全示例"><a href="#最全示例" class="headerlink" title="最全示例"></a>最全示例</h3><pre class="line-numbers language-none"><code class="language-none">---title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00author: 赵奇img: &#x2F;source&#x2F;images&#x2F;xxx.jpgtop: truehide: falsecover: truecoverImg: &#x2F;images&#x2F;1.jpgpassword: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92toc: falsemathjax: falsesummary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要categories: Markdowntags:  - Typora  - Markdown---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解决图床问题：</p><meta name="referrer" content="no-referrer" />]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter8 操作臂的机构设计</title>
      <link href="/2023/02/08/Learn/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6%E5%AF%BC%E8%AE%BA/Chapter8%20%E6%93%8D%E4%BD%9C%E8%87%82%E7%9A%84%E6%9C%BA%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
      <url>/2023/02/08/Learn/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6%E5%AF%BC%E8%AE%BA/Chapter8%20%E6%93%8D%E4%BD%9C%E8%87%82%E7%9A%84%E6%9C%BA%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="Chapter8-操作臂的机构设计"><a href="#Chapter8-操作臂的机构设计" class="headerlink" title="Chapter8 操作臂的机构设计"></a>Chapter8 操作臂的机构设计</h1><p>机器人系统的组成大体可分为四部分：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208113440567.png"></p><h2 id="基于任务需求的设计"><a href="#基于任务需求的设计" class="headerlink" title="基于任务需求的设计"></a>基于任务需求的设计</h2><h3 id="自由度的数目"><a href="#自由度的数目" class="headerlink" title="自由度的数目"></a>自由度的数目</h3><p>操作臂的自由度数目应该与所要完成的任务相匹配。</p><h3 id="工作空间"><a href="#工作空间" class="headerlink" title="工作空间"></a>工作空间</h3><p>在执行工作任务时，操作臂必须能够抓取到若干工件或夹具。</p><h3 id="负载能力"><a href="#负载能力" class="headerlink" title="负载能力"></a>负载能力</h3><p>操作臂的负载能力与其结构尺寸、传动系统和驱动器有关。</p><h3 id="速度"><a href="#速度" class="headerlink" title="速度"></a>速度</h3><p>在设计操作臂时，一个明显的目标是使操作臂具有越来越高的速度。</p><h3 id="重复精度与精度"><a href="#重复精度与精度" class="headerlink" title="重复精度与精度"></a>重复精度与精度</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208113808042.png"></p><h2 id="运动学构型"><a href="#运动学构型" class="headerlink" title="运动学构型"></a>运动学构型</h2><h3 id="直角坐标型"><a href="#直角坐标型" class="headerlink" title="直角坐标型"></a>直角坐标型</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208113934738.png" alt="直角坐标型操作臂"></p><p><strong>优点与缺点：</strong></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208114155706.png"></p><h3 id="铰接型"><a href="#铰接型" class="headerlink" title="铰接型"></a>铰接型</h3><p>减少了操作臂侵入工作空间的可能性，使操作臂能够到达受限制的空间位置。它们的总体结构比直角坐标操作臂小，当应用于较小工作空间的场合时，可谓物美价廉。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208114241065.png" alt="铰接型机器人"></p><h3 id="SCARA型"><a href="#SCARA型" class="headerlink" title="SCARA型"></a>SCARA型</h3><p>这种结构的最大优点是前三个关节不必支撑任何操作臂或负载的重量。这类结构最适合于执行平面内的任务。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208114401573.png" alt="SCARA操作臂"></p><h3 id="极坐标型"><a href="#极坐标型" class="headerlink" title="极坐标型"></a>极坐标型</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208114533938.png" alt="极坐标型操作臂"></p><h3 id="圆柱坐标型"><a href="#圆柱坐标型" class="headerlink" title="圆柱坐标型"></a>圆柱坐标型</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230208114608229.png"></p><h2 id="位置检测"><a href="#位置检测" class="headerlink" title="位置检测"></a>位置检测</h2><ol><li>旋转光学编码器</li><li>旋转变压器</li><li>电位计</li><li>转速计</li></ol>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器人学导论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter7 轨迹生成</title>
      <link href="/2023/02/07/Learn/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6%E5%AF%BC%E8%AE%BA/Chapter7%20%E8%BD%A8%E8%BF%B9%E7%94%9F%E6%88%90/"/>
      <url>/2023/02/07/Learn/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6%E5%AF%BC%E8%AE%BA/Chapter7%20%E8%BD%A8%E8%BF%B9%E7%94%9F%E6%88%90/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="Chapter7-轨迹生成"><a href="#Chapter7-轨迹生成" class="headerlink" title="Chapter7 轨迹生成"></a>Chapter7 轨迹生成</h1><h2 id="关节空间的规划方法"><a href="#关节空间的规划方法" class="headerlink" title="关节空间的规划方法"></a>关节空间的规划方法</h2><h3 id="三次多项式"><a href="#三次多项式" class="headerlink" title="三次多项式"></a>三次多项式</h3><p>由初始值和最终值可得到对函数值的两个约束条件：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230207194244309.png"></p><p>在初始时刻和终止时刻关节速度为零：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230207194316528.png"></p><p>该三次多项式具有如下形式：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230207195506054.png"></p><p>解方程可得：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230207195540457.png"></p><p>但是该解仅适用于起始关节角速度与终止关节角速度均为零的情况。</p><h3 id="具有中间点的路径的三次多项式"><a href="#具有中间点的路径的三次多项式" class="headerlink" title="具有中间点的路径的三次多项式"></a>具有中间点的路径的三次多项式</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230207195856031.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230207195901363.png"></p><p>上式，可求出符合任何起始和终止位置以及任何起始和终止速度的三次多项式。</p><h3 id="高次多项式"><a href="#高次多项式" class="headerlink" title="高次多项式"></a>高次多项式</h3><p>如果要确定在路径曲线段的起始点和终止点的位置、速度和加速度，则需要用一个五次多项式进行插值，即：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230207203926123.png"></p><p>解方程可得：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230207203942341.png"></p><h3 id="带由抛物线过渡的线性函数"><a href="#带由抛物线过渡的线性函数" class="headerlink" title="带由抛物线过渡的线性函数"></a>带由抛物线过渡的线性函数</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230207220048119.png" alt="带有抛物线过渡的直线段"></p><h2 id="笛卡尔空间规划方法"><a href="#笛卡尔空间规划方法" class="headerlink" title="笛卡尔空间规划方法"></a>笛卡尔空间规划方法</h2><h3 id="笛卡尔直线运动"><a href="#笛卡尔直线运动" class="headerlink" title="笛卡尔直线运动"></a>笛卡尔直线运动</h3><h3 id="笛卡尔路径的几何问题"><a href="#笛卡尔路径的几何问题" class="headerlink" title="笛卡尔路径的几何问题"></a>笛卡尔路径的几何问题</h3><h4 id="1、无法到达中间点"><a href="#1、无法到达中间点" class="headerlink" title="1、无法到达中间点"></a>1、无法到达中间点</h4><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230207222006079.png"></p><h4 id="2、在奇异点附近关节速度增大"><a href="#2、在奇异点附近关节速度增大" class="headerlink" title="2、在奇异点附近关节速度增大"></a>2、在奇异点附近关节速度增大</h4><p>在操作臂的工作空间中存在某些位置，无法用有限的关节速度来实现末端执行器在笛卡尔空间中的期望速度。因此，有某些路径（在笛卡尔空间中描述）是操作臂所无法执行的。例如，一个操作臂沿笛卡尔直线路径接近某个奇异位形时，机器人的一个或多个关节可能激增至无穷大。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230207222043695.png"></p><h4 id="3、起始点和终止点有不同的解"><a href="#3、起始点和终止点有不同的解" class="headerlink" title="3、起始点和终止点有不同的解"></a>3、起始点和终止点有不同的解</h4><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230207222924982.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230207222915309.png" alt="图7-14"></p><h2 id="路径的实时生成"><a href="#路径的实时生成" class="headerlink" title="路径的实时生成"></a>路径的实时生成</h2><h3 id="关节空间路径的生成"><a href="#关节空间路径的生成" class="headerlink" title="关节空间路径的生成"></a>关节空间路径的生成</h3><p>在直线区段，对每个关节的轨迹计算如下：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230207223811161.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230207223842889.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230207223856636.png"></p><h3 id="笛卡尔空间路径的生成"><a href="#笛卡尔空间路径的生成" class="headerlink" title="笛卡尔空间路径的生成"></a>笛卡尔空间路径的生成</h3><p>使用符号x来表示笛卡尔位姿矢量的一个分量。</p><p>在曲线的直线区段，x中的每个自由度按下式计算：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230207223955659.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230207224010801.png"></p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器人学导论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter6 操作臂动力学</title>
      <link href="/2023/02/04/Learn/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6%E5%AF%BC%E8%AE%BA/Chapter6%20%E6%93%8D%E4%BD%9C%E8%87%82%E5%8A%A8%E5%8A%9B%E5%AD%A6/"/>
      <url>/2023/02/04/Learn/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6%E5%AF%BC%E8%AE%BA/Chapter6%20%E6%93%8D%E4%BD%9C%E8%87%82%E5%8A%A8%E5%8A%9B%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="Chapter6-操作臂动力学"><a href="#Chapter6-操作臂动力学" class="headerlink" title="Chapter6 操作臂动力学"></a>Chapter6 操作臂动力学</h1><h2 id="刚体的加速度"><a href="#刚体的加速度" class="headerlink" title="刚体的加速度"></a>刚体的加速度</h2><h3 id="线加速度"><a href="#线加速度" class="headerlink" title="线加速度"></a>线加速度</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230205164333594.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230205164348471.png"></p><h3 id="角加速度"><a href="#角加速度" class="headerlink" title="角加速度"></a>角加速度</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230205164434766.png"></p><h2 id="质量分布"><a href="#质量分布" class="headerlink" title="质量分布"></a>质量分布</h2><p>对于定轴旋转的情况，经常用到<strong>惯性矩</strong>这个概念。</p><p>在一个刚体绕任意轴做旋转运动时，我们需要一种能够表征刚体质量分布的方式。在这里，引入<strong>惯性张量</strong>。</p><p>坐标系{A}中的惯性张量可用3×3矩阵表示如下</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230205165112173.png"></p><p>各元素：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230205165125375.png" alt="、"></p><h2 id="牛顿方程和欧拉方程"><a href="#牛顿方程和欧拉方程" class="headerlink" title="牛顿方程和欧拉方程"></a>牛顿方程和欧拉方程</h2><p>如果知道了连杆质心的位置和惯性张量，那么它的质量分布特征就完全确定了。</p><p>连杆运动所需的力是关于连杆期望加速度及其质量分布的函数。</p><p>牛顿方程以及描述旋转运动的欧拉方程描述了力、惯量和加速度之间的关系。</p><h3 id="牛顿方程"><a href="#牛顿方程" class="headerlink" title="牛顿方程"></a>牛顿方程</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230205165304745.png"></p><h3 id="欧拉方程"><a href="#欧拉方程" class="headerlink" title="欧拉方程"></a>欧拉方程</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230205165319817.png"></p><h2 id="牛顿-欧拉递推动力学方程"><a href="#牛顿-欧拉递推动力学方程" class="headerlink" title="牛顿-欧拉递推动力学方程"></a>牛顿-欧拉递推动力学方程</h2><h3 id="牛顿-欧拉递推动力学算法"><a href="#牛顿-欧拉递推动力学算法" class="headerlink" title="牛顿-欧拉递推动力学算法"></a>牛顿-欧拉递推动力学算法</h3><p>对于转动关节来说，这个算法归纳如下：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230205170101776.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230205170114338.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230205170138047.png"></p><h3 id="考虑重力的动力学算法"><a href="#考虑重力的动力学算法" class="headerlink" title="考虑重力的动力学算法"></a>考虑重力的动力学算法</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230205170336208.png"></p><h2 id="操作臂动力学的拉格朗日方程"><a href="#操作臂动力学的拉格朗日方程" class="headerlink" title="操作臂动力学的拉格朗日方程"></a>操作臂动力学的拉格朗日方程</h2><p>牛顿-欧拉公式可以被认为是一种解决动力学问题的力平衡方法，而拉格朗日公式则是一种基于能量的动力学方法。</p><p>首先讨论操作臂动能的表达式。第i个连杆的动能k<del>i</del>可以表示为：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230205172901519.png"></p><p>式中第一项是基于连杆质心线速度的动能，第二项是连杆的角速度动能。</p><p>整个操作臂的动能是各个连杆功能之和，即：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230205172955433.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230207185335730.png"></p><p>拉格朗日动力学公式给出了一种从标量函数推导动力学方程的方法，我们称这个标量函数为拉格朗日函数，即一个机械系统的动能和势能的差值。这里，操作臂的拉格朗日函数表示为：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230207185715196.png"></p><p>则操作臂的运动方程为：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230207185749283.png"></p><p>这里，t是n×1的激励力矩矢量。对于操作臂来说，方程变为：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230207185822085.png"></p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器人学导论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter5 雅可比：速度与静力</title>
      <link href="/2023/02/02/Learn/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6%E5%AF%BC%E8%AE%BA/Chapter5%20%E9%9B%85%E5%8F%AF%E6%AF%94%EF%BC%9A%E9%80%9F%E5%BA%A6%E4%B8%8E%E9%9D%99%E5%8A%9B/"/>
      <url>/2023/02/02/Learn/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6%E5%AF%BC%E8%AE%BA/Chapter5%20%E9%9B%85%E5%8F%AF%E6%AF%94%EF%BC%9A%E9%80%9F%E5%BA%A6%E4%B8%8E%E9%9D%99%E5%8A%9B/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="Chapter5-雅可比：速度与静力"><a href="#Chapter5-雅可比：速度与静力" class="headerlink" title="Chapter5 雅可比：速度与静力"></a>Chapter5 雅可比：速度与静力</h1><h2 id="时变位置和姿态的符号表示"><a href="#时变位置和姿态的符号表示" class="headerlink" title="时变位置和姿态的符号表示"></a>时变位置和姿态的符号表示</h2><h3 id="位置矢量的导数"><a href="#位置矢量的导数" class="headerlink" title="位置矢量的导数"></a>位置矢量的导数</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230129111318491.png"></p><p>位置矢量的速度可以看出用位置矢量描述的空间一点的线速度。</p><p>如果相对于坐标系{B}，Q不随时间变化，那么速度就为零，尽管在其他一些坐标系中Q是变化的。因此必须说明的是一个矢量相对于哪个坐标系求导。</p><h3 id="角速度矢量"><a href="#角速度矢量" class="headerlink" title="角速度矢量"></a>角速度矢量</h3><p>^A^Ω<del>B</del>描述了坐标系{B}相对于坐标系{A}的旋转。</p><p>从物理意义上讲，方向就是{B}相对于{A}的瞬时旋转轴，大小表示旋转速率。</p><h2 id="刚体的线速度和角速度"><a href="#刚体的线速度和角速度" class="headerlink" title="刚体的线速度和角速度"></a>刚体的线速度和角速度</h2><h3 id="线速度"><a href="#线速度" class="headerlink" title="线速度"></a>线速度</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230129125351226.png"></p><p>求解坐标系{A}中的点Q的线速度是非常简单的。只要写出坐标系{A}中的两个速度分量，求其和为：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230129125441676.png"></p><h3 id="角速度"><a href="#角速度" class="headerlink" title="角速度"></a>角速度</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230129165443814.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230129165510017.png"></p><h2 id="对角速度的进一步研究"><a href="#对角速度的进一步研究" class="headerlink" title="对角速度的进一步研究"></a>对角速度的进一步研究</h2><h3 id="正交矩阵的性质"><a href="#正交矩阵的性质" class="headerlink" title="正交矩阵的性质"></a>正交矩阵的性质</h3><p>对于任何n*n正交矩阵R，有：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230129172404461.png"></p><p>对上式求导得：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230129172427335.png"></p><p>定义：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230129172517138.png"></p><p>有：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230129172533544.png"></p><p>S为反对称矩阵，因此正交阵的导数与反对称矩阵之间存在如下特性，可写为：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230129172642286.png"></p><h3 id="旋转参考系的点速度"><a href="#旋转参考系的点速度" class="headerlink" title="旋转参考系的点速度"></a>旋转参考系的点速度</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230129185335240.png"></p><h3 id="反对称矩阵和矢量叉积"><a href="#反对称矩阵和矢量叉积" class="headerlink" title="反对称矩阵和矢量叉积"></a>反对称矩阵和矢量叉积</h3><p>反对称矩阵S的各元素如下：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230129204755299.png"></p><p>容易证明：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230129205608664.png"></p><p>上述式子与式5.23联立可得：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230129211459122.png"></p><h3 id="角速度矢量的物理意义"><a href="#角速度矢量的物理意义" class="headerlink" title="角速度矢量的物理意义"></a>角速度矢量的物理意义</h3><p>角速度矢量Ω的物理意义是在任一时刻，旋转坐标系姿态的变化可以看作是绕某个轴K^的旋转。这个顺时旋转轴，可作为单位矢量，与绕这个轴的旋转速度标量(θ*)构成角速度矢量。</p><h2 id="连杆之间的速度“传递”"><a href="#连杆之间的速度“传递”" class="headerlink" title="连杆之间的速度“传递”"></a>连杆之间的速度“传递”</h2><p>连杆i+1的角速度相对于坐标系{i+1}的表达式：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230130154448332.png"></p><p>速度：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230130154523330.png"></p><p>对应关节i+1为移动关节时，相应的关系为：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230130154958247.png"></p><h2 id="雅可比"><a href="#雅可比" class="headerlink" title="雅可比"></a>雅可比</h2><p>可以将雅可比矩阵看成X中的速度向Y中速度的映射：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230202163734972.png"></p><p>在任一瞬间，X都有一个确定的值，J(X)是个线性变换。在每一个新时刻，如果X改变，线性变换也会随之而变。所以，雅可比是时变的线性变换。</p><p>雅可比矩阵的行数等于操作臂在笛卡尔空间中的自由度数量，雅可比矩阵的列数等于操作臂的关节数量。</p><p>在机器人学中，通常使用雅可比将关节速度与操作臂末端的笛卡尔速度联系起了，例如</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230204224512176.png"></p><h3 id="雅可比矩阵参考坐标系的变换"><a href="#雅可比矩阵参考坐标系的变换" class="headerlink" title="雅可比矩阵参考坐标系的变换"></a>雅可比矩阵参考坐标系的变换</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230202174342664.png"></p><h2 id="奇异性"><a href="#奇异性" class="headerlink" title="奇异性"></a>奇异性</h2><p>可逆矩阵又叫非奇异矩阵。如果线性变换矩阵是非奇异的，已知笛卡尔坐标系，就可以对矩阵求逆计算出关节的速度：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230204231223370.png"></p><p>大多数操作臂都有使得雅可比矩阵奇异的Θ值。这些位置就称为机构的奇异位形或简称奇异性。</p><p>当操作臂处于奇异位形时，它会失去一个或多个自由度。这也就是说，在笛卡尔空间的某个方向上，无论选择什么样的关节速度，都不能使机器人手臂运动。</p><h2 id="操作臂的静力"><a href="#操作臂的静力" class="headerlink" title="操作臂的静力"></a>操作臂的静力</h2><p>我们为相邻杆件所施加的力和力矩定义以下特殊的符号：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230205155041240.png"></p><p>连杆之间的静力传递表达式</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230205155009359.png"></p><p>为了平衡施加在连杆上的力和力矩，需要施加在关节上的力矩有多大？除了绕关节轴的力矩之外，力和力矩矢量的所有分量都可以由操作臂机构本身来平衡。因此，为求出保持系统静平衡的关节力矩，应计算关节轴矢量和施加在连杆上的力矩矢量的点乘：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230205160612487.png"></p><h2 id="力域中的雅可比"><a href="#力域中的雅可比" class="headerlink" title="力域中的雅可比"></a>力域中的雅可比</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230205161632020.png" alt="image-20230205161632020"></p><p>F是一个作用在末端执行器上的6×1维笛卡尔力-力矩矢量，t是6×1维关节力矩矢量。</p><p>上式说明：雅可比矩阵的转置将作用在手臂上的笛卡尔力映射成了等效关节力矩。</p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器人学导论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter 4 操作臂逆运动学</title>
      <link href="/2023/01/29/Learn/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6%E5%AF%BC%E8%AE%BA/Chapter4%20%E6%93%8D%E4%BD%9C%E8%87%82%E9%80%86%E8%BF%90%E5%8A%A8%E5%AD%A6/"/>
      <url>/2023/01/29/Learn/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6%E5%AF%BC%E8%AE%BA/Chapter4%20%E6%93%8D%E4%BD%9C%E8%87%82%E9%80%86%E8%BF%90%E5%8A%A8%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="Chapter4-操作臂逆运动学"><a href="#Chapter4-操作臂逆运动学" class="headerlink" title="Chapter4 操作臂逆运动学"></a>Chapter4 操作臂逆运动学</h1><h2 id="解的存在性"><a href="#解的存在性" class="headerlink" title="解的存在性"></a>解的存在性</h2><h3 id="操作臂的工作空间"><a href="#操作臂的工作空间" class="headerlink" title="操作臂的工作空间"></a>操作臂的工作空间</h3><p>简单地说，工作空间是操作臂末端执行器所能到达的范围。若要求解存在，则被指定的目标点必须在工作空间内。</p><p><strong>灵巧工作空间</strong>：机器人的末端执行器能够从各个方向到达的空间区域。</p><p><strong>可达工作空间</strong>：机器人至少从一个方向上可以到达的空间。</p><p>可见，灵巧工作空间是可达工作空间的子集。</p><h3 id="多解问题"><a href="#多解问题" class="headerlink" title="多解问题"></a>多解问题</h3><p>如图所示，到达同一个点可以有多种解。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230128174656415.png"></p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>我们把操作臂的全部求解方法分为两大类：<strong>封闭解</strong>和<strong>数值解</strong>。</p><p>下面主要讨论封闭解方法。在本章中，“封闭形式”意指基于解析形式的解法，或者对于不高于4次的多项式不用迭代便可完全求解。</p><p>可将封闭解的求解方法分为两类：<strong>代数法</strong>和<strong>几何法</strong>。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230128193455070.png"></p><h4 id="Pieper解法"><a href="#Pieper解法" class="headerlink" title="Pieper解法"></a>Pieper解法</h4><p>特殊解法</p><p><a href="https://zhuanlan.zhihu.com/p/106632144">机器人学——学习笔记11(Pieper’s Solution) - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器人学导论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter3 操作臂运动学</title>
      <link href="/2023/01/28/Learn/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6%E5%AF%BC%E8%AE%BA/Chapter3%20%E6%93%8D%E4%BD%9C%E8%87%82%E8%BF%90%E5%8A%A8%E5%AD%A6/"/>
      <url>/2023/01/28/Learn/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6%E5%AF%BC%E8%AE%BA/Chapter3%20%E6%93%8D%E4%BD%9C%E8%87%82%E8%BF%90%E5%8A%A8%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="Chapter3-操作臂运动学"><a href="#Chapter3-操作臂运动学" class="headerlink" title="Chapter3 操作臂运动学"></a>Chapter3 操作臂运动学</h1><h2 id="连杆的描述"><a href="#连杆的描述" class="headerlink" title="连杆的描述"></a>连杆的描述</h2><p>操作臂可以看成由一系列通过关节连接成运动链的刚体。我们将这些刚体称为连杆。当两个刚体之间的相对运动是两个平面相互之间的相对滑动时，连接相邻两个刚体的运动副称为低副。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230112172810077.png" alt="6种常见的低副关节"></p><p>为了确定末端执行器在三维空间的位置和姿态，操作臂至少需要6个关节。</p><p>三维空间中的任意两个轴之间的距离是固定的，即为两轴之间公垂线的长度。</p><p>如图，关节轴i-1和关节轴i之间公垂线的长度为a<del>i-1</del>，a<del>i-1</del>即为连杆长度。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230116220205755.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230116220623404.png"></p><h2 id="连杆连接的描述"><a href="#连杆连接的描述" class="headerlink" title="连杆连接的描述"></a>连杆连接的描述</h2><p>在研究机器人运动学时，仅需要考虑两个参数，这两个参数完全确定了所有连杆时如何连接的。</p><p>沿两个相邻连杆公共轴线方向的距离可以用一个参数描述，该参数称为连杆偏距，在关节轴i上的连杆偏距记为d<del>i</del> 。用另一个参数描述两相邻连杆绕公共轴线旋转的夹角，该参数称为关节角，记为Θ<del>i</del>。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230126114600090.png"></p><h2 id="连杆参数"><a href="#连杆参数" class="headerlink" title="连杆参数"></a>连杆参数</h2><p>因此，机器人的每个连杆都可以用4个运动学参数来描述，其中两个参数用于描述连杆本身，另两个参数用于描述连杆之间的连接关系。通常，对于转动关节，Θ<del>i</del>为关节变量，其他三个连杆参数是固定不变的；对于移动关节，d<del>i</del>为关节变量，其他三个连杆参数是固定不变的。这种用连杆参数描述机构运动关系的规则称为DH法。</p><h2 id="连杆坐标系的定义"><a href="#连杆坐标系的定义" class="headerlink" title="连杆坐标系的定义"></a>连杆坐标系的定义</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230128144122352.png"></p><h3 id="连杆参数在连杆坐标系中的表示方法"><a href="#连杆参数在连杆坐标系中的表示方法" class="headerlink" title="连杆参数在连杆坐标系中的表示方法"></a>连杆参数在连杆坐标系中的表示方法</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230128144235355.png"></p><h3 id="建立连杆坐标系的步骤"><a href="#建立连杆坐标系的步骤" class="headerlink" title="建立连杆坐标系的步骤"></a>建立连杆坐标系的步骤</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230128150718420.png"></p><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230128155509861.png"></p><h2 id="操作臂运动学"><a href="#操作臂运动学" class="headerlink" title="操作臂运动学"></a>操作臂运动学</h2><h3 id="连杆变换的推导"><a href="#连杆变换的推导" class="headerlink" title="连杆变换的推导"></a>连杆变换的推导</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230128165201317.png"></p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器人学导论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023.1.25 Note</title>
      <link href="/2023/01/25/Note/2023.1.25%E8%AE%B0/"/>
      <url>/2023/01/25/Note/2023.1.25%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="过年"><a href="#过年" class="headerlink" title="过年"></a>过年</h1><p>过年了过年了！</p><p>估摸有四五年没回家过年了。</p><p>今年终于back back。</p><h2 id="红包"><a href="#红包" class="headerlink" title="红包"></a>红包</h2><p>不知道从什么时候开始，我不喜欢收人家红包了。</p><p>可能是长大了吧，变得不好意思了。</p><h2 id="麻将"><a href="#麻将" class="headerlink" title="麻将"></a>麻将</h2><p>打了三回麻将，寄了三回。</p><p>我也不造啊，可能是我太菜了。</p><p>确实，没怎么打过。</p><p>手气也不怎么好。</p><h2 id="烟花"><a href="#烟花" class="headerlink" title="烟花"></a>烟花</h2><p>买了好多烟花，放了一个小时，累了。</p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230125144442885.png" alt="" style="zoom: 50%;" /><h2 id="吃饭"><a href="#吃饭" class="headerlink" title="吃饭"></a>吃饭</h2><p>吃了好多东西。</p><p>念念不忘的，还是一碗牛肉粿。</p><p>还有，烧烤。</p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230125145008883.png" alt="" style="zoom:50%;" /><h2 id="住宿"><a href="#住宿" class="headerlink" title="住宿"></a>住宿</h2><p>今年没回家里住。住在公寓宾馆。</p><p>挺好的，回老家不用带很多东西，也不用收拾了。</p><p>晚上太晚回家，老人也不用担心。</p><h2 id="小孩"><a href="#小孩" class="headerlink" title="小孩"></a>小孩</h2><p>不知不觉，我们都已经长大了。</p><p>两个堂姐都已经结婚，也有了小孩。</p><p>很可爱的。</p><h2 id="走亲戚"><a href="#走亲戚" class="headerlink" title="走亲戚"></a>走亲戚</h2><p>今年见了上百个亲戚，认识了好多人。</p><p>逃不了的问题。</p><p>多大了，工作没，在哪里读书……</p><p>别急。</p><h2 id="家"><a href="#家" class="headerlink" title="家"></a>家</h2><p>慢慢长大，越来越爱自己的家。</p><p>我的父母是十分善良的，和蔼的。</p><p>待人做事一直是我的榜样。</p><p>他们以身作则，教会了我很多。</p><p>我也要成为他们的骄傲。</p><p>有空多陪伴家人！家人是永远的依靠。</p>]]></content>
      
      
      <categories>
          
          <category> Diary </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Freertos基础知识</title>
      <link href="/2023/01/13/Learn/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/FreeRTOS/"/>
      <url>/2023/01/13/Learn/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/FreeRTOS/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="Freertos基础知识"><a href="#Freertos基础知识" class="headerlink" title="Freertos基础知识"></a>Freertos基础知识</h2><h3 id="什么是Freertos？"><a href="#什么是Freertos？" class="headerlink" title="什么是Freertos？"></a>什么是Freertos？</h3><p>​Free 就是免费的、RTOS 全称是 Real Time Operating System，中文名就是实时操作系统。可以看出 FreeROTS 就是一个免费的 RTOS 类系统。</p><p>​操作系统允许多个任务同时运行，这个叫做多任务，实际上，一个处理器核心在某一时刻只能运行一个任务。操作系统中任务调度器的责任就是决定在某一时刻究竟运行哪个任务，任务调度在各个任务之间的切换非常快！这就给人们造成了同一时刻有多个任务同时运行的错觉。</p><p>​FreeRTOS 由用户给每个任务分配一个任务优先级，任务调度器就可以根据此优先级来决定下一刻应该运行哪个任务。</p><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><h4 id="什么是多任务系统？"><a href="#什么是多任务系统？" class="headerlink" title="什么是多任务系统？"></a>什么是多任务系统？</h4><p>​回想一下我们以前在使用 51、STM32 单片机裸机(未使用系统)的时候一般都是在 main 函数里面用 while(1)做一个大循环来完成所有的处理，即应用程序是一个无限的循环，循环中调用相应的函数完成所需的处理。有时候我们也需要中断中完成一些处理。相对于多任务系统而言，这个就是单任务系统，也称作前后台系统，中断服务函数作为前台程序，大循环 while(1)作为后台程序。如图所示。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221003003311071.png"></p><p>​可以看到，前后台系统各个任务都是排队等着轮流执行，不管你这个程序现在有多紧急，没轮到你就只能等着！相当于所有任务的优先级都是一样的。</p><p>​FreeRTOS 是一个抢占式的实时多任务系统，那么其任务调度器也是抢占式的。如图所示。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221003003616795.png"></p><h4 id="任务状态"><a href="#任务状态" class="headerlink" title="任务状态"></a>任务状态</h4><ol><li>运行态<br>当一个任务正在运行时，那么就说这个任务处于运行态，处于运行态的任务就是当前正在使用处理器的任务。如果使用的是单核处理器的话那么不管在任何时刻永远都只有一个任务处于运行态。</li><li>就绪态<br>处于就绪态的任务是那些已经准备就绪(这些任务没有被阻塞或者挂起)，可以运行的任务， 但是处于就绪态的任务还没有运行，因为有一个同优先级或者更高优先级的任务正在运行！</li><li>阻塞态<br>如果一个任务当前正在等待某个外部事件的话就说它处于阻塞态，比如说如果某个任务调 用了函数 vTaskDelay()的话就会进入阻塞态，直到延时周期完成。任务在等待队列、信号量、事 件组、通知或互斥信号量的时候也会进入阻塞态。任务进入阻塞态会有一个超时时间，当超过 这个超时时间任务就会退出阻塞态，即使所等待的事件还没有来临！</li><li>挂起态<br>像阻塞态一样，任务进入挂起态以后也不能被调度器调用进入运行态，但是进入挂起态的 任务没有超时时间。任务进入和退出挂起态通过调用函数 vTaskSuspend()和 xTaskResume()。</li></ol><h4 id="任务优先级"><a href="#任务优先级" class="headerlink" title="任务优先级"></a>任务优先级</h4><p>​每个任务都可以分配一个从 0~(configMAX_PRIORITIES-1) 的优先级，宏 configMAX_PRIORITIES 不能超过 32！优先级数字越低表示任务的优先级越低，0 的优先级最低，configMAX_PRIORITIES-1 的优先级最高。空闲任务的优先级最低，为 0。 FreeRTOS 调度器确保处于就绪态或运行态的高优先级的任务获取处理器使用权，换句话说就是处于就绪态的最高优先级的任务才会运行。</p><p>​当宏 configUSE_TIME_SLICING 定义为 1 的时候多个任务可以共用一个优先级，数量不限。此时处于就绪态的优先级相同的任务就会使用时间片轮转调度器获取运行时间，一个时间片的长度就是滴答定时器的中断周期，由宏configTICK_RATE_HZ确定。</p><h4 id="任务堆栈"><a href="#任务堆栈" class="headerlink" title="任务堆栈"></a>任务堆栈</h4><p>​FreeRTOS 之所以能正确的恢复一个任务的运行就是因为有任务堆栈在保驾护航，任务调度器在进行任务切换的时候会将当前任务的现场(CPU 寄存器值等)保存在此任务的任务堆栈中， 等到此任务下次运行的时候就会先用堆栈中保存的值来恢复现场，恢复现场以后任务就会接着从上次中断的地方开始运行。</p><p>​基于RTOS的应用中，每个任务都拥有自己的<a href="https://so.csdn.net/so/search?q=%E5%A0%86%E6%A0%88&spm=1001.2101.3001.7020">堆栈</a>空间。堆栈设置过大，会造成内存资源浪费；设置过小，可能导致运行过程中的任务栈溢出，从而导致一些奇怪的系统行为。</p><p>​一般来说，任务堆栈可以从一个比较大的堆栈空间开始，如需进而开发出更高质量的代码：在运行时监视堆栈空间的使用情况，以查看应用程序运行一段时间后实际使用了多少堆栈空间。基于可视化分析，用户可以更清晰直观的掌握系统中内存的使用情况。</p><p><a href="https://strongerhuang.blog.csdn.net/article/details/125108922?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-125108922-blog-103144501.pc_relevant_3mothn_strategy_and_data_recovery&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-125108922-blog-103144501.pc_relevant_3mothn_strategy_and_data_recovery&utm_relevant_index=2">(46条消息) 如何设置RTOS任务的堆栈大小？_strongerHuang的博客-CSDN博客</a></p><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>​看个定义：<a href="https://zhuanlan.zhihu.com/p/81018602">算法一看就懂之「 队列 」 - 知乎 (zhihu.com)</a></p><p>​队列在这里是为了任务与任务、任务与中断之间的通信而准备的，可以在任务与任务、任务与中断之间传递消息，队列中可以存储有限的、大小固定的数据项目。任务与任务、任务与中断之间要交流的数据保存在队列中，叫做队列项目。队列所能保存的最大数据项目数量叫做队列的 长度，创建队列的时候会指定数据项目的大小和队列的长度。由于队列用来传递消息的，所以也称为消息队列。FreeRTOS 中的信号量的也是依据队列实现的。</p><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>​信号量是操作系统中重要的一部分，信号量一般用来进行资源管理和任务同步，FreeRTOS 中信号量又分为二值信号量、计数型信号量、互斥信号量和递归互斥信号量。</p><p>​详细了解请自己查资料。</p><h2 id="实战篇"><a href="#实战篇" class="headerlink" title="实战篇"></a>实战篇</h2><h3 id="在CubeMX上配置FreeRTOS"><a href="#在CubeMX上配置FreeRTOS" class="headerlink" title="在CubeMX上配置FreeRTOS"></a>在CubeMX上配置FreeRTOS</h3><p>（一）首先，像往常一样需要先设置RCC、SYS以及时钟树，这里不做详细介绍。</p><p>需要提醒一点的是：裸机的时钟源默认是SysTick，但是开启FreeRTOS后，FreeRTOS会占用SysTick，所以需要需要为其他总线提供另外的时钟源。具体步骤如下图（以TIM7例）</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221003013440220.png"></p><p>（二）开启FreeRTOS</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221003013556891.png"></p><blockquote><p>vTaskDelay：任务A每次延时都是从调用延时函数vTaskDelay()开始算起的，延时是相对于这一时刻开始的，所以叫做相对延时函数。如果执行任务A的过程中发生中断，那么任务A执行的周期就会变长，所以使用相对延时函数vTaskDelay()，不能周期性的执行任务A。 </p><p>vTaskDelayUntil：从调用函数vTaskDelayUntil()开始，每隔固定周期，任务B的主体代码就会被执行一次，即使任务B在执行过程中发生中断，也不会影响这个周期性，只是会缩短其它任务的执行时间。所以这个函数被称为绝对延时函数，它可以用于周期性的执行任务B的主体代码。</p></blockquote><p><strong>config parameters</strong>系统内核配置：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221003013959738.png"></p><h3 id="Keil中代码实现"><a href="#Keil中代码实现" class="headerlink" title="Keil中代码实现"></a>Keil中代码实现</h3><ol><li>创建任务</li></ol><p>创建任务函数：</p><pre><code>BaseType_t xTaskCreate(                        TaskFunction_t pxTaskCode,//函数指针，指向任务函数的入口                        const char * const pcName,//任务描述。主要用于调试                        const configSTACK_DEPTH_TYPE usStackDepth,//指定任务堆栈大小，能够支持的堆栈变量数量（堆栈深度），而字节数=堆栈深度*宽度（比如，在 16 位宽度的堆栈下，usStackDepth 定义为 100，则实际使用 200 字节堆栈存储空间）                        void * const pvParameters,//参数指针，当任务创建时，作为一个参数传递给任务，一般传进NULL                        UBaseType_t uxPriority,//任务优先级                        TaskHandle_t * const pxCreatedTask //回传句柄，创建任务后用这个句柄引用任务                      )</code></pre><p>应用举例：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;宏定义各任务的堆栈大小及优先级#define TASK1_STK_SIZE     128#define TASK1_TASK_PRIO    2#define TASK2_STK_SIZE     128#define TASK2_TASK_PRIO    1&#x2F;&#x2F;定义任务句柄TaskHandle_t    Task1_Handler;    TaskHandle_t    Task2_Handler;&#x2F;&#x2F;函数声明void task1_(void * arg);void task2_(void * arg);void System_Task_Init(void);&#x2F;&#x2F;任务创建void System_Task_Init(void)&#123;xTaskCreate(task1_, &quot;task1_&quot;, TASK1_STK_SIZE, NULL, TASK1_TASK_PRIO, &amp;Task1_Handler);xTaskCreate(task2_, &quot;task2_&quot;, TASK2_STK_SIZE, NULL, TASK2_TASK_PRIO, &amp;Task2_Handler);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.任务函数</p><pre class="line-numbers language-none"><code class="language-none">void task1_(void * arg)&#123;int i1 &#x3D; 0;vTaskSuspend(Task2_Handler);&#x2F;&#x2F;一的优先级高于二，先挂起二for(;;)&#123;i1++;printf(&quot;任务一已执行次数：%d\r\n&quot;, i1);vTaskDelay(1000);if(i1 &gt; 3)&#123; vTaskResume(Task2_Handler); &#125;&#x2F;&#x2F;当一执行4次之后解挂二&#125;&#125;void task2_(void * arg)&#123;int i2 &#x3D; 0;vTaskDelete(Task1_Handler);&#x2F;&#x2F;第一次运行二时删除一for(;;)&#123;i2++;printf(&quot;任务二已执行次数：%d\r\n&quot;, i2);vTaskDelay(1000);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.开启任务</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221003014555435.png"></p><blockquote><p>注意：</p><p>1.在任务调度器开启前创建任务：</p><p>初始化函数放在main函数MX_FREERTOS_Init()前面</p><p>2.在任务调度器开启后创建任务：</p><p>初始化函数放在 StartDefaultTask任务中。</p></blockquote><p>结果：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221003014528997.png"></p><h3 id="队列的使用"><a href="#队列的使用" class="headerlink" title="队列的使用"></a>队列的使用</h3><p>结构体定义</p><pre class="line-numbers language-none"><code class="language-none">typedef struct&#123;  uint8_t port_num;  uint16_t len;  void* address;&#125; USART_COB;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>·1、存储队列定义和初始化</p><pre class="line-numbers language-none"><code class="language-none">QueueHandle_t  USART_RxPort; &#x2F;&#x2F;全局变量USART_RxPort &#x3D; xQueueCreate(4,sizeof(USART_COB));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>原型：</p><p>xQueueHandle xQueueCreate( </p><p>unsigned portBASE_TYPE uxQueueLength,    &#x2F;&#x2F;队列中包含最大项目数量</p><p>unsigned portBASE_TYPE uxItemSize   &#x2F;&#x2F;队列中每个项目所需的字节数。</p><p>);</p></blockquote><p>2、定义回调函数</p><pre class="line-numbers language-none"><code class="language-none">uint32_t User_UART1_RxCpltCallback(uint8_t* Recv_Data, uint16_t ReceiveLen)&#123;  static USART_COB Usart_RxCOB;  &#x2F;&#x2F;Send To UART Receive Queue  if(USART_RxPort !&#x3D; NULL)  &#123;    Usart_RxCOB.port_num &#x3D; 1;    Usart_RxCOB.len      &#x3D; ReceiveLen;    Usart_RxCOB.address  &#x3D; Recv_Data;    xQueueSendFromISR(USART_RxPort,&amp;Usart_RxCOB,0); &#x2F;&#x2F;在中断中调用，需要中断保护版本，故此处不能用xQueueSend。  &#125;  return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>原型：</p><p>xQueueSendFromISR(</p><p>QueueHandle_t xQueue,   &#x2F;&#x2F;目标队列的句柄。</p><p>const void *pvItemToQueue,   &#x2F;&#x2F;发送数据的指针。</p><p>BaseType_t *pxHigherPriorityTaskWoken   </p><p>&#x2F;&#x2F;如果入队导致一个任务解锁，并且解锁的任务优先级高于当前被中断的任务，则将*pxHigherPriorityTaskWoken 设置成 pdTRUE。</p><p>);</p></blockquote><p>3、定义处理函数</p><pre class="line-numbers language-none"><code class="language-none">void Task_UsartRecieve(void *arg)&#123;   USART_COB Usart_RxCOB;   for(;;)  &#123;    &#x2F;* Usart Recevice Port *&#x2F;                                                                                                                                                                                                              if(xQueueReceive(USART_RxPort,&amp;Usart_RxCOB,portMAX_DELAY) &#x3D;&#x3D; pdPASS)      &#123;          &#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>原型：</p><p>xQueueReceive(</p><p>QueueHandle_t xQueue,&#x2F;&#x2F;被读队列的句柄。这个句柄即是调用 xQueueCreate() 创建该队列时的返回值。</p><p> void *pvBuffer,&#x2F;&#x2F;接收缓存指针。其指向一段内存区域，用于接收从队列中拷贝来的数据。</p><p> TickType_t xTicksToWait&#x2F;&#x2F;队列空时，阻塞超时的最大时间。如果该参数设置为 0，函数立刻返回。延时为 portMAX_DELAY 将导致任务无限阻塞。</p><p>);</p><p>返回值：队列项接收成功返回 pdTRUE，否则返回 pdFALSE。</p></blockquote><h1 id="上位机培训"><a href="#上位机培训" class="headerlink" title="上位机培训"></a>上位机培训</h1><h2 id="UpperMonitor库使用"><a href="#UpperMonitor库使用" class="headerlink" title="UpperMonitor库使用"></a>UpperMonitor库使用</h2><p>软件上位机：<a href="https://gitee.com/ennishsu/upper-monitor.git">https://gitee.com/ennishsu/upper-monitor.git</a></p><p>打开 ~.cpp 文件可以看到以下注释</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221003124726584.png"></p><p>1、</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;* Private variables ---------------------------------------------------------*&#x2F;extern moto_info_t motor_info;extern int target_speed;extern double kp;extern double ki;extern double kd;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：</p><p>uint8_t USART0_Sent_Choose_Data[9]&#x3D;{0,1,2,3,0,1,2,3,0};  此处也需要修改。需要观察n个数据就输入0-(n-1)，不足九位补齐九位。输入0-8也可。</p><p>2、</p><pre class="line-numbers language-none"><code class="language-none">void UpperMonitor_Sent_Choose(float * data)&#123;  uint8_t i;  for(i&#x3D;0;i&lt;Sent_Data_Num;i++)  &#123;    switch(USART0_Sent_Choose_Data[i])    &#123;      &#x2F;* ÒÔÏÂ²¿·ÖÓÃÓÚ¹Û²ì²ÎÊýÇúÏß *&#x2F;      case 0: data[i]&#x3D; motor_info.rotor_speed;          break;      case 1: data[i]&#x3D; target_speed;          break;      case 2: data[i]&#x3D; target_speed*1.05;         break;case 3: data[i]&#x3D; target_speed*0.95;         break;      default:break;  &#x2F;* ÒÔÉÏ²¿·ÖÓÃÓÚ¹Û²ì²ÎÊýÇúÏß *&#x2F;    &#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3、</p><pre class="line-numbers language-none"><code class="language-none">void PARAMETER_MODIFICATION(uint8_t * PARAMETER)&#123;  switch(PARAMETER[0])  &#123;    &#x2F;* ÒÔÏÂ²¿·ÖÓÃÓÚÐÞ¸Ä²ÎÊýÄÚÈÝ *&#x2F;case 0x00: kp &#x3D; PARAMETER_Change_float(PARAMETER+1);         break;case 0x01: ki &#x3D; PARAMETER_Change_float(PARAMETER+1); break;case 0x02: kd &#x3D; PARAMETER_Change_float(PARAMETER+1); break;&#x2F;* ÒÔÉÏ²¿·ÖÓÃÓÚÐÞ¸Ä²ÎÊýÄÚÈÝ *&#x2F;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4、在中断中</p><pre class="line-numbers language-none"><code class="language-none">#define BUFFERSIZE 255    &#x2F;&#x2F;可接收最大数据量extern uint8_t Rx_len,bootfirst;extern uint8_t ReceiveBuff[BUFFERSIZE]; &#x2F;&#x2F;接收缓存区void USART1_IRQHandler(void)&#123;  &#x2F;* USER CODE BEGIN USART1_IRQn 0 *&#x2F;  &#x2F;* USER CODE END USART1_IRQn 0 *&#x2F;  HAL_UART_IRQHandler(&amp;huart1);  &#x2F;* USER CODE BEGIN USART1_IRQn 1 *&#x2F;uint32_t temp;if(USART1 &#x3D;&#x3D; huart1.Instance)&#123;if(RESET !&#x3D; __HAL_UART_GET_FLAG(&amp;huart1,UART_FLAG_IDLE))&#x2F;&#x2F;如果串口1为空闲&#123;__HAL_UART_CLEAR_IDLEFLAG(&amp;huart1);&#x2F;&#x2F;清除中断标志位HAL_UART_DMAStop(&amp;huart1);&#x2F;&#x2F;停止DMA接收temp  &#x3D; __HAL_DMA_GET_COUNTER(&amp;hdma_usart1_rx);&#x2F;&#x2F;获取DMA当前还有多少未填充Rx_len &#x3D;  BUFFERSIZE - temp; &#x2F;&#x2F;计算串口接收到的数据个数RecHandle(ReceiveBuff,Rx_len);HAL_UART_Transmit_DMA(&amp;huart1,ReceiveBuff,Rx_len);&#x2F;&#x2F;发送数据Rx_len &#x3D; 0;&#x2F;&#x2F;接收数据长度清零HAL_UART_Receive_DMA(&amp;huart1,ReceiveBuff,BUFFERSIZE);&#x2F;&#x2F;开启下一次接收&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>5、在任务中调用</p><pre class="line-numbers language-none"><code class="language-none">Sent_Contorl(&amp;huart2);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="上位机界面使用"><a href="#上位机界面使用" class="headerlink" title="上位机界面使用"></a>上位机界面使用</h2><h3 id="上位机调参"><a href="#上位机调参" class="headerlink" title="上位机调参"></a>上位机调参</h3><p>1、打开临时指令指令表，修改变量名</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221010162048056.png"></p><p>2、打开上位机软件</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221003133231406.png"></p><h3 id="曲线显示"><a href="#曲线显示" class="headerlink" title="曲线显示"></a>曲线显示</h3><p>鼠标移到右上角，即可显示相关曲线</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221003133600904.png"></p><h3 id="光标调节"><a href="#光标调节" class="headerlink" title="光标调节"></a>光标调节</h3><p>右键黑屏，可以调出光标</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221003133629067.png"></p><h3 id="曲线横向放大-x2F-纵向放大"><a href="#曲线横向放大-x2F-纵向放大" class="headerlink" title="曲线横向放大&#x2F;纵向放大"></a>曲线横向放大&#x2F;纵向放大</h3><p>Shift+滚轮</p><p>Ctrl+滚轮</p><p>滚轮</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1]STM32F1 FreeRTOS开发手册  ALIENTEK</p><p>[2]FreeRTOS系列 CSDN：冬瓜~</p><p>[3]FreeRTOS学习笔记 by Tzrrr</p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter2 空间描述和变换</title>
      <link href="/2023/01/12/Learn/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6%E5%AF%BC%E8%AE%BA/Chapter2%20%E7%A9%BA%E9%97%B4%E6%8F%8F%E8%BF%B0%E5%92%8C%E5%8F%98%E6%8D%A2/"/>
      <url>/2023/01/12/Learn/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6%E5%AF%BC%E8%AE%BA/Chapter2%20%E7%A9%BA%E9%97%B4%E6%8F%8F%E8%BF%B0%E5%92%8C%E5%8F%98%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="Chapter2-空间描述和变换"><a href="#Chapter2-空间描述和变换" class="headerlink" title="Chapter2 空间描述和变换"></a>Chapter2 空间描述和变换</h1><h2 id="描述：位置、姿态与位姿"><a href="#描述：位置、姿态与位姿" class="headerlink" title="描述：位置、姿态与位姿"></a>描述：位置、姿态与位姿</h2><h3 id="位置描述"><a href="#位置描述" class="headerlink" title="位置描述"></a>位置描述</h3><p>^A^P,是指^A^P的元素数值是在坐标系{A}的轴线方向的距离。沿着坐标轴的每个距离可被认为是矢量在相应坐标轴上的投影。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230111162226899.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230111162731102.png"></p><h3 id="姿态描述"><a href="#姿态描述" class="headerlink" title="姿态描述"></a>姿态描述</h3><p>点的位置可用矢量描述，物体的姿态可用固定在物体上的坐标系来描述。</p><p>描述坐标系B的一种方法是利用坐标系A的三个主轴单位矢量来表示。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230111163604444.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230111163930715.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230111164141647.png"></p><h3 id="位姿描述"><a href="#位姿描述" class="headerlink" title="位姿描述"></a>位姿描述</h3><p>位置和姿态成对出现，我们将此组合称为位姿。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230111164544025.png"></p><h2 id="映射：从一个坐标系到另一个坐标系"><a href="#映射：从一个坐标系到另一个坐标系" class="headerlink" title="映射：从一个坐标系到另一个坐标系"></a>映射：从一个坐标系到另一个坐标系</h2><h3 id="坐标平移"><a href="#坐标平移" class="headerlink" title="坐标平移"></a>坐标平移</h3><p>平移下可用矢量^A^P<del>BORG</del>表示{B}的原点相对于{A}的位置。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230111175753238.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230111180730512.png"></p><h3 id="坐标旋转"><a href="#坐标旋转" class="headerlink" title="坐标旋转"></a>坐标旋转</h3><p>旋转矩阵各列的模均为1，并且这些单位矢量均相互正交。如前所述，可得：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230111181449677.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230111181941068.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230111184034737.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230111184354658.png"></p><p>上式进行了映射——它是矢量变换的描述——将空间某点相对于{B}的描述^B^P转换成了该点相对于{A}的描述^A^P。</p><h3 id="Example-2-1"><a href="#Example-2-1" class="headerlink" title="Example 2.1"></a>Example 2.1</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230111184858973.png"></p><h3 id="一般变换"><a href="#一般变换" class="headerlink" title="一般变换"></a>一般变换</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230111190906556.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230111191231909.png"></p><p>引入一个新概念：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230111191639010.png"></p><p>等效如下：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230111191647832.png"></p><p>容易看出该式可写成：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230111192833265.png"></p><h3 id="Example-2-2"><a href="#Example-2-2" class="headerlink" title="Example 2.2"></a>Example 2.2</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230111192931300.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230111192946168.png"></p><h2 id="算子：平移、旋转和变换"><a href="#算子：平移、旋转和变换" class="headerlink" title="算子：平移、旋转和变换"></a>算子：平移、旋转和变换</h2><h3 id="平移算子"><a href="#平移算子" class="headerlink" title="平移算子"></a>平移算子</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230111194615448.png"></p><h3 id="旋转算子"><a href="#旋转算子" class="headerlink" title="旋转算子"></a>旋转算子</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230111194710066.png"></p><h3 id="Example-2-3"><a href="#Example-2-3" class="headerlink" title="Example 2.3"></a>Example 2.3</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230111194738553.png"></p><h3 id="变换算子"><a href="#变换算子" class="headerlink" title="变换算子"></a>变换算子</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230111195524783.png"></p><p>跟上述式子相同。</p><h3 id="Example-2-4"><a href="#Example-2-4" class="headerlink" title="Example 2.4"></a>Example 2.4</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230111195637494.png"></p><h2 id="变换的计算"><a href="#变换的计算" class="headerlink" title="变换的计算"></a>变换的计算</h2><h3 id="复合变换"><a href="#复合变换" class="headerlink" title="复合变换"></a>复合变换</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230111200521027.png"></p><p>因此可得：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230111200641295.png"></p><h3 id="逆变换"><a href="#逆变换" class="headerlink" title="逆变换"></a>逆变换</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230111201148394.png"></p><p>如上，可以看到：R相对应的是矩阵的转置。T相对应的是矩阵的逆。</p><p><strong><u>特别注意位移部分</u></strong></p><h3 id="Example-2-5"><a href="#Example-2-5" class="headerlink" title="Example 2.5"></a>Example 2.5</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230112111313113.png"></p><h2 id="变换方程"><a href="#变换方程" class="headerlink" title="变换方程"></a>变换方程</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230112112822855.png"></p><p>没有什么特别的地方，跟上文差不多。变换的最后左边和右边上下标相同。</p><h2 id="其他姿态描述"><a href="#其他姿态描述" class="headerlink" title="其他姿态描述"></a>其他姿态描述</h2><h3 id="X-Y-Z固定角"><a href="#X-Y-Z固定角" class="headerlink" title="X-Y-Z固定角"></a>X-Y-Z固定角</h3><p>每次旋转都是绕着参考坐标系各轴的。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230112114043671.png" alt="条件前提"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230112114027343.png" alt="旋转矩阵"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230112114106015.png" alt="X-Y-Z旋转矩阵"></p><p>要记住这里给定的三个旋转顺序，仅当旋转是按照这个顺序进行时方程才是正确的。</p><p>旋转一般时不满足交换律的，即<img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230112114240450.png">二者是不同的。</p><p>常令人感兴趣的是逆问题，即从旋转矩阵等价推出X-Y-Z固定角。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230112114420312.png" alt="旋转矩阵求X-Y-Z固定角"></p><h3 id="Z-Y-X欧拉角"><a href="#Z-Y-X欧拉角" class="headerlink" title="Z-Y-X欧拉角"></a>Z-Y-X欧拉角</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230112115945625.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230112115955223.png" alt="前提条件"></p><p>每次都是绕运动坐标系{B}的各轴旋转而不是绕固定坐标系{A}的各轴旋转。这样三个一组的旋转被称为<strong>欧拉角</strong>。</p><p>由于三个旋转分别是绕着Z^^^、Y^^^、X^^^，所以称这种表示法为Z-Y-X欧拉角。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230112114855946.png" alt="Z-Y-X欧拉角"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230112114919928.png" alt="旋转矩阵"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230112114946855.png" alt="Z-Y-X旋转矩阵"></p><p><strong>注意：这个结果与以相反顺序绕固定轴旋转三次得到的结果完全相同！总之，这是一个不太直观的结果：三次绕固定轴旋转的最终姿态和以相反顺序绕运动坐标轴转动的最终姿态相同。</strong></p><h3 id="Z-Y-Z欧拉角"><a href="#Z-Y-Z欧拉角" class="headerlink" title="Z-Y-Z欧拉角"></a>Z-Y-Z欧拉角</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230112115919163.png" alt="前提条件"></p><p>按照推导，可得等价矩阵</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230112120053799.png" alt="旋转矩阵"></p><p>如果sinβ !&#x3D; 0，有</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230112120142270.png" alt="逆解"></p><h3 id="其他转角组合"><a href="#其他转角组合" class="headerlink" title="其他转角组合"></a>其他转角组合</h3><h4 id="等效角度-轴线表示法"><a href="#等效角度-轴线表示法" class="headerlink" title="等效角度-轴线表示法"></a>等效角度-轴线表示法</h4><p>略</p><h4 id="欧拉参数"><a href="#欧拉参数" class="headerlink" title="欧拉参数"></a>欧拉参数</h4><p>此处已做过讨论：[四元数与欧拉角与旋转矩阵](<a href="https://potzrrr.top/2023/01/11/%E5%9B%9B%E5%85%83%E6%95%B0%E4%B8%8E%E6%AC%A7%E6%8B%89%E8%A7%92%E4%B8%8E%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5/">四元数与欧拉角与旋转矩阵 | ZRong’s Blog (potzrrr.top)</a>)</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230112120330489.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230112120459255.png" alt="四维超球面"></p><p>这个关系总是保持不变。因此，姿态可以看作是四维空间中单位超球面上的一点。</p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器人学导论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kalman Filter</title>
      <link href="/2023/01/11/Learn/%E7%AE%97%E6%B3%95/Kalman%20Filter/"/>
      <url>/2023/01/11/Learn/%E7%AE%97%E6%B3%95/Kalman%20Filter/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="Kalman-Filter"><a href="#Kalman-Filter" class="headerlink" title="Kalman Filter"></a>Kalman Filter</h1><p>Learn by DR_CAN</p><h2 id="Part1-Recursive-Algorithm-递归算法"><a href="#Part1-Recursive-Algorithm-递归算法" class="headerlink" title="Part1 Recursive Algorithm 递归算法"></a>Part1 Recursive Algorithm 递归算法</h2><h3 id="1-1-一句话概括"><a href="#1-1-一句话概括" class="headerlink" title="1.1 一句话概括"></a>1.1 一句话概括</h3><p>Optimal Recursive Data Processing Algorithm 最优化递归数字处理算法</p><h3 id="1-2-不确定性"><a href="#1-2-不确定性" class="headerlink" title="1.2 不确定性"></a>1.2 不确定性</h3><ul><li>不存在完美的数学模型</li><li>系统的扰动不可控，也很难建模</li><li>测量传感器存在误差</li></ul><h3 id="1-3-Example"><a href="#1-3-Example" class="headerlink" title="1.3 Example"></a>1.3 Example</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20220913220448956.png"></p><p><strong>由上式可知，随着k的增加，测量结果不再重要。</strong></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20220913220418191.png"></p><h3 id="1-4-Step"><a href="#1-4-Step" class="headerlink" title="1.4 Step"></a>1.4 Step</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20220914170031982.png"></p><h2 id="Part2-Data-Fusion-数据融合"><a href="#Part2-Data-Fusion-数据融合" class="headerlink" title="Part2 Data Fusion 数据融合"></a>Part2 Data Fusion 数据融合</h2><h3 id="1-1-Example"><a href="#1-1-Example" class="headerlink" title="1.1 Example"></a>1.1 Example</h3><p>Use math to solve a ploblem which has two sets of data.</p><p>假设有两把秤，测重量。</p><p>其中一把秤得到30g，已知其标准差为2g；另一把秤得到32g，标准差为4g。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20220914202400147.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20220914202448915.png"></p><h3 id="1-2-Covariance-Matrix-协方差矩阵"><a href="#1-2-Covariance-Matrix-协方差矩阵" class="headerlink" title="1.2 Covariance Matrix 协方差矩阵"></a>1.2 Covariance Matrix 协方差矩阵</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20220914210137551.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20220914210229505.png"></p><h3 id="1-3-State-Space-Representation"><a href="#1-3-State-Space-Representation" class="headerlink" title="1.3 State Space Representation"></a>1.3 State Space Representation</h3><p><strong>见现代控制理论状态空间方程的表示。</strong></p><h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20220914210510464.png"></h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20220914210749768.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20220914211339976.png"></p><h2 id="Part3-Step-by-Step-Derivation-of-Kalman-Gain"><a href="#Part3-Step-by-Step-Derivation-of-Kalman-Gain" class="headerlink" title="Part3 Step by Step Derivation of Kalman Gain"></a>Part3 Step by Step Derivation of Kalman Gain</h2><p><a href="https://www.bilibili.com/video/BV1hC4y1b7K7?spm_id_from=333.999.0.0&vd_source=dc5a7d7190173a321a8ae3df82a10d84">【卡尔曼滤波器】3_卡尔曼增益超详细数学推导 ～全网最完整_哔哩哔哩_bilibili</a></p><p><u><strong>跟着学一遍</strong></u></p><h3 id="1-1-建立状态空间方程"><a href="#1-1-建立状态空间方程" class="headerlink" title="1.1 建立状态空间方程"></a>1.1 建立状态空间方程</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20220915191708100.png"></p><h3 id="1-2-寻找增益k值，使得方差最小"><a href="#1-2-寻找增益k值，使得方差最小" class="headerlink" title="1.2 寻找增益k值，使得方差最小"></a>1.2 寻找增益k值，使得方差最小</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20220916001619736.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20220916001603500.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20220916002220270.png"></p><h2 id="Part4-Priori-x2F-Posterrori-Error-Covariance-Matrix-先验-x2F-后验误差协方差矩阵"><a href="#Part4-Priori-x2F-Posterrori-Error-Covariance-Matrix-先验-x2F-后验误差协方差矩阵" class="headerlink" title="Part4 Priori&#x2F;Posterrori Error Covariance Matrix 先验&#x2F;后验误差协方差矩阵"></a>Part4 Priori&#x2F;Posterrori Error Covariance Matrix 先验&#x2F;后验误差协方差矩阵</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20220917005157630.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20220917004952941.png"></p><h2 id="Part5-An-Example"><a href="#Part5-An-Example" class="headerlink" title="Part5 An Example"></a>Part5 An Example</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20220917010043597.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20220917011807619.png"></p><h3 id="如果测量误差小"><a href="#如果测量误差小" class="headerlink" title="如果测量误差小"></a>如果测量误差小</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20220917011914629.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20220917011853695.png"></p><h3 id="如果测量误差大"><a href="#如果测量误差大" class="headerlink" title="如果测量误差大"></a>如果测量误差大</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20220917012021251.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20220917012032856.png"></p><h2 id="Part6-Extended-Kalman-Filter-扩展卡尔曼滤波器"><a href="#Part6-Extended-Kalman-Filter-扩展卡尔曼滤波器" class="headerlink" title="Part6 Extended Kalman Filter 扩展卡尔曼滤波器"></a>Part6 Extended Kalman Filter 扩展卡尔曼滤波器</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20220917012759494.png"></p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cubeide移植到vscode</title>
      <link href="/2023/01/11/Learn/%E6%9D%82/cubeide%E7%A7%BB%E6%A4%8D%E5%88%B0vscode/"/>
      <url>/2023/01/11/Learn/%E6%9D%82/cubeide%E7%A7%BB%E6%A4%8D%E5%88%B0vscode/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="1、首先用vscode打开工程文件夹"><a href="#1、首先用vscode打开工程文件夹" class="headerlink" title="1、首先用vscode打开工程文件夹"></a>1、首先用vscode打开工程文件夹</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230106104756153.png"></p><h2 id="2、按ctrl-P，输入-gt-c-x2F-c-，选择第一个，Edit-Configurations-UI"><a href="#2、按ctrl-P，输入-gt-c-x2F-c-，选择第一个，Edit-Configurations-UI" class="headerlink" title="2、按ctrl+P，输入&gt;c&#x2F;c++，选择第一个，Edit Configurations(UI)"></a>2、按ctrl+P，输入&gt;c&#x2F;c++，选择第一个，Edit Configurations(UI)</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230106105124576.png"></p><h2 id="3、打开左边json文件"><a href="#3、打开左边json文件" class="headerlink" title="3、打开左边json文件"></a>3、打开左边json文件</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230106110828297.png"></p><h2 id="4、配置代码如下"><a href="#4、配置代码如下" class="headerlink" title="4、配置代码如下"></a>4、配置代码如下</h2><pre class="line-numbers language-none"><code class="language-none">&#123;    &quot;configurations&quot;: [        &#123;            &quot;name&quot;: &quot;STM32&quot;,            &quot;includePath&quot;: [                &quot;$&#123;workspaceFolder&#125;&#x2F;**&quot;,                     &quot;$&#123;workspaceFolder&#125;&#x2F;Drivers&#x2F;STM32F7xx_HAL_Driver&#x2F;Inc&#x2F;&quot;,                &quot;$&#123;workspaceFolder&#125;&#x2F;Drivers&#x2F;STM32F7xx_HAL_Driver&#x2F;Inc&#x2F;Legacy&#x2F;&quot;,                &quot;$&#123;workspaceFolder&#125;&#x2F;Drivers&#x2F;CMSIS&#x2F;Device&#x2F;ST&#x2F;STM32F7xx&#x2F;Include&#x2F;&quot;,                &quot;$&#123;workspaceFolder&#125;&#x2F;Drivers&#x2F;CMSIS&#x2F;Include&#x2F;&quot;,                &quot;$&#123;workspaceFolder&#125;&#x2F;USER&#x2F;drivers&#x2F;&quot;,                &quot;$&#123;workspaceFolder&#125;&#x2F;Core&#x2F;Inc&#x2F;&quot;,                &quot;$&#123;workspaceFolder&#125;&#x2F;Middlewares&#x2F;Third_Party&#x2F;FreeRTOS&#x2F;Source&#x2F;include&#x2F;&quot;,                &quot;$&#123;workspaceFolder&#125;&#x2F;Middlewares&#x2F;Third_Party&#x2F;FreeRTOS&#x2F;Source&#x2F;CMSIS_RTOS_V2&#x2F;&quot;,                &quot;$&#123;workspaceFolder&#125;&#x2F;Middlewares&#x2F;Third_Party&#x2F;FreeRTOS&#x2F;Source&#x2F;portable&#x2F;GCC&#x2F;ARM_CM7&#x2F;r0p1&#x2F;&quot;,                &quot;$&#123;workspaceFolder&#125;&#x2F;USER&#x2F;drivers&quot;,                &quot;$&#123;workspaceFolder&#125;&#x2F;USER&#x2F;modules&quot;,                &quot;$&#123;workspaceFolder&#125;&#x2F;eigen3&#x2F;Eigen&quot;,                &quot;D:&#x2F;ST&#x2F;STM32CubeIDE_1.5.0&#x2F;STM32CubeIDE&#x2F;plugins&#x2F;com.st.stm32cube.ide.mcu.externaltools.gnu-tools-for-stm32.7-2018-q2-update.win32_1.5.0.202011040924&#x2F;tools&#x2F;arm-none-eabi&#x2F;include&#x2F;**&quot;,                &quot;D:&#x2F;ST&#x2F;STM32CubeIDE_1.5.0&#x2F;STM32CubeIDE&#x2F;plugins&#x2F;com.st.stm32cube.ide.mcu.externaltools.gnu-tools-for-stm32.7-2018-q2-update.win32_1.5.0.202011040924&#x2F;tools&#x2F;lib&#x2F;gcc&#x2F;arm-none-eabi&#x2F;7.3.1&#x2F;include&#x2F;**&quot;            ],            &quot;defines&quot;: [                &quot;__CC_ARM&quot;,                &quot;USE_HAL_DRIVER&quot;,                &quot;STM32F767xx&quot;,            ],            &quot;compilerPath&quot;: &quot;D:\\ST\\STM32CubeIDE_1.5.0\\STM32CubeIDE\\plugins\\com.st.stm32cube.ide.mcu.externaltools.gnu-tools-for-stm32.7-2018-q2-update.win32_1.5.0.202011040924\\tools\\arm-none-eabi\\include\\machine\\_default_types.h&quot;,            &quot;cStandard&quot;: &quot;c99&quot;,            &quot;cppStandard&quot;: &quot;c++11&quot;,            &quot;intelliSenseMode&quot;: &quot;$&#123;default&#125;&quot;        &#125;    ],    &quot;version&quot;: 4&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意修改几个地方，如下所示</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230106142814849.png"></p><h3 id="此处踩坑！坑如下"><a href="#此处踩坑！坑如下" class="headerlink" title="此处踩坑！坑如下"></a>此处踩坑！坑如下</h3><h4 id="1、uint32-t"><a href="#1、uint32-t" class="headerlink" title="1、uint32_t"></a>1、uint32_t</h4><p>解决方案：添加_CC_ARM如图</p><h4 id="2、LL库报错"><a href="#2、LL库报错" class="headerlink" title="2、LL库报错"></a>2、LL库报错</h4><p>理由是添加了USE_FULL_LL_DRIVER</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230106142951618.png"></p><p>注意，不能加！</p><h4 id="3、没有stdint-h-stddef-h文件"><a href="#3、没有stdint-h-stddef-h文件" class="headerlink" title="3、没有stdint.h   stddef.h文件"></a>3、没有stdint.h   stddef.h文件</h4><p>问题原因：这个是ide本身的文件，Workspace里没有，要手动添加</p><p>解决方案：找到电脑中文件的位置，添加路径</p><p>“D:&#x2F;ST&#x2F;STM32CubeIDE_1.5.0&#x2F;STM32CubeIDE&#x2F;plugins&#x2F;com.st.stm32cube.ide.mcu.externaltools.gnu-tools-for-stm32.7-2018-q2-update.win32_1.5.0.202011040924&#x2F;tools&#x2F;arm-none-eabi&#x2F;include&#x2F;“,<br> “D:&#x2F;ST&#x2F;STM32CubeIDE_1.5.0&#x2F;STM32CubeIDE&#x2F;plugins&#x2F;com.st.stm32cube.ide.mcu.externaltools.gnu-tools-for-stm32.7-2018-q2-update.win32_1.5.0.202011040924&#x2F;tools&#x2F;lib&#x2F;gcc&#x2F;arm-none-eabi&#x2F;7.3.1&#x2F;include&#x2F;“</p><h2 id="正常移植到此完美结束"><a href="#正常移植到此完美结束" class="headerlink" title="正常移植到此完美结束"></a>正常移植到此完美结束</h2>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多旋翼飞行器控制与设计</title>
      <link href="/2023/01/11/Learn/UAV/%E5%A4%9A%E6%97%8B%E7%BF%BC%E9%A3%9E%E8%A1%8C%E5%99%A8%E6%8E%A7%E5%88%B6%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
      <url>/2023/01/11/Learn/UAV/%E5%A4%9A%E6%97%8B%E7%BF%BC%E9%A3%9E%E8%A1%8C%E5%99%A8%E6%8E%A7%E5%88%B6%E4%B8%8E%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="动态模型和参数测量"><a href="#动态模型和参数测量" class="headerlink" title="动态模型和参数测量"></a>动态模型和参数测量</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221019163939091.png"></p><h3 id="刚体运动学模型"><a href="#刚体运动学模型" class="headerlink" title="刚体运动学模型"></a>刚体运动学模型</h3><p>运动学与质量和受力无关，只研究位置、速度、姿态和角速度等变量。</p><p>输入为速度和角速度，输出为位置和姿态。</p><h4 id="欧拉角模型"><a href="#欧拉角模型" class="headerlink" title="欧拉角模型"></a>欧拉角模型</h4><h4 id="旋转矩阵模型"><a href="#旋转矩阵模型" class="headerlink" title="旋转矩阵模型"></a>旋转矩阵模型</h4><h4 id="四元数模型"><a href="#四元数模型" class="headerlink" title="四元数模型"></a>四元数模型</h4><h3 id="刚体动力学模型"><a href="#刚体动力学模型" class="headerlink" title="刚体动力学模型"></a>刚体动力学模型</h3><p>动力学既涉及运动又涉及受力情况，与物体的质量和转动惯量有关。</p><p>输入为拉力和力矩（俯仰力矩、滚转力矩和偏航力矩），输出为速度和角速度。</p><h4 id="位置运动学模型"><a href="#位置运动学模型" class="headerlink" title="位置运动学模型"></a>位置运动学模型</h4><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221021152223230.png"></p><p>进一步，可以得到</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221021152245888.png"></p><p>f表示螺旋桨拉力总大小，g为重力加速度</p><h4 id="姿态动力学模型"><a href="#姿态动力学模型" class="headerlink" title="姿态动力学模型"></a>姿态动力学模型</h4><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221021152307960.png"></p><p>Ga表示陀螺力矩，t表示螺旋桨在机体轴上产生的力矩。</p><h3 id="多旋翼飞行控制刚体模型"><a href="#多旋翼飞行控制刚体模型" class="headerlink" title="多旋翼飞行控制刚体模型"></a>多旋翼飞行控制刚体模型</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221021152006578.png"></p><h3 id="控制效率模型"><a href="#控制效率模型" class="headerlink" title="控制效率模型"></a>控制效率模型</h3><p>输入是螺旋桨转速，输出是拉力和力矩。</p><p>控制效率模型的逆过程成为控制分配模型，即当通过控制器设计得到期望的拉力和力矩时，可以通过控制分配模型解出所需的螺旋桨转速。</p><h4 id="单个螺旋桨拉力和反扭距模型"><a href="#单个螺旋桨拉力和反扭距模型" class="headerlink" title="单个螺旋桨拉力和反扭距模型"></a>单个螺旋桨拉力和反扭距模型</h4><p>当多旋翼在无风情况下悬停时，其螺旋桨拉力表示为：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221021152934201.png"></p><p>其中，<img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221021152954025.png">。</p><p>反扭矩大小静态模型表示为：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221021153023683.png"></p><p>其中，<img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221021153102833.png">。</p><p>反扭距大小动态模型：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221021153218027.png"></p><h4 id="拉力和力矩模型"><a href="#拉力和力矩模型" class="headerlink" title="拉力和力矩模型"></a>拉力和力矩模型</h4><p>作用在四旋翼上的总拉力：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221021153323008.png"></p><p>对于**<u>十字形四旋翼</u>**，螺旋桨产生的力矩为：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221021153350931.png"></p><p>于是，联立以上两式有：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221021153419530.png"></p><p>对于**<u>X字形四旋翼</u>**，螺旋桨产生的力矩为：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221021153842065.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221021153854395.png"></p><p>对于**<u>多旋翼</u>**：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221021172735390.png"></p><h3 id="动力单元模型"><a href="#动力单元模型" class="headerlink" title="动力单元模型"></a>动力单元模型</h3><p>动力单元是以无刷直流电机、电调和螺旋桨为一组的整个动力机构。</p><p>输入是油门指令，输出是螺旋桨拉力的模型。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221022101946961.png"></p><p>完整的动力单元模型如下：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221022102209331.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221022103551683.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221022103609861.png" alt="image-20221022103609861"></p><blockquote><p>一阶低通滤波：</p><p><a href="https://zhuanlan.zhihu.com/p/42935576">一阶低通滤波（LPF）的原理及应用（以APM&#x2F;PX4飞控为例） - 知乎 (zhihu.com)</a></p></blockquote><h3 id="桨叶挥舞"><a href="#桨叶挥舞" class="headerlink" title="桨叶挥舞"></a>桨叶挥舞</h3><p>桨叶挥舞是旋转桨叶的上下运动。如图所示，逆风飞行的前行桨叶会获得更大的相对速度，而速度增加将产生更大的拉力，同时产生向上挥舞速度。向上挥舞速度会减小迎角，进而减小拉力。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221023093815547.png"></p><h2 id="传感器"><a href="#传感器" class="headerlink" title="传感器"></a>传感器</h2><h3 id="三轴加速度计"><a href="#三轴加速度计" class="headerlink" title="三轴加速度计"></a>三轴加速度计</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221012155505721.png"></p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>当加速度计保持静止时，加速度计能够感知重力加速度，而整体加速度为零</li><li>在自由落体运动中，整体加速度就是重力加速度，但加速度计内部处于失重状态，而此时三轴加速度计输出为零</li><li>在自由落体运动中，三轴加速度计的输出并不是它的真实加速度，而是它的加速度去掉重力后的整体加速度。因此，三轴加速度计可以测量物体的比力。</li></ul><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221012160117959.png"></p><p>加速度计能够精确的测量俯仰角和滚转角，且没有累计误差。</p><h4 id="MEMS三轴加速度计"><a href="#MEMS三轴加速度计" class="headerlink" title="MEMS三轴加速度计"></a>MEMS三轴加速度计</h4><p>采用压阻式、压电式和电容式工作原理，产生的比力分别正比于电阻、电压和电容的变化。</p><p>这种变化可以通过相应<strong>放大</strong>和<strong>滤波</strong>电路进行采集。</p><ul><li>缺点：受振动影响较大。</li><li>优点：可以做到很小</li></ul><h4 id="校正"><a href="#校正" class="headerlink" title="校正"></a>校正</h4><p>（1）校正</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221012162158405.png"></p><p>（2）自动校正</p><p>一般校正：需要外部标定设备，麻烦但精确</p><p>自动校正：不需要外部标定设备，简单 ，精度略微差</p><h5 id="误差模型"><a href="#误差模型" class="headerlink" title="误差模型"></a>误差模型</h5><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221012211946087.png"></p><p> <img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221012215248194.png"></p><h5 id="测量模型"><a href="#测量模型" class="headerlink" title="测量模型"></a>测量模型</h5><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221012220347761.png"></p><blockquote><p>何为高斯白噪声？</p><p>百度百科上解释为“<strong>高斯白噪声，幅度分布服从高斯分布，功率谱密度服从均匀分布</strong>”。</p><p>白噪声，如同白光一样，是所有颜色的光叠加而成，不同颜色的光本质区别是的它们的频率各不相同（如红色光波长长而频率低，相应的，紫色光波长短而频率高）。白噪声在功率谱上（若以频率为横轴，信号幅度的平方为功率）趋近为常值，即噪声频率丰富，在整个频谱上都有成分，即从低频到高频，<strong>低频指的是信号不变或缓慢变化，高频指的是信号突变</strong>。</p><p>白噪声信号是“随机”的。</p><p>那么，回到文章开头的解释：<strong>高斯白噪声，幅度分布服从高斯分布，功率谱密度服从均匀分布。</strong>它的意义就很明确了，上半句是从空域(幅值)角度描述“高斯噪声”，而下半句是从频域角度描述“白噪声”。</p></blockquote><blockquote><p>为什么产生漂移？</p><p>大部分MEMS均是以半导体材料为基础加工的，半导体对温度敏感，再加上安装、电路设计等因素的影响。</p></blockquote><h3 id="三轴陀螺仪"><a href="#三轴陀螺仪" class="headerlink" title="三轴陀螺仪"></a>三轴陀螺仪</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>MEMS三轴陀螺仪用到的一个基本的物理原理：科里奥利力</p><p> <img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221013155545058.png"></p><p>在陀螺仪中，两个质量块运动的速度方向相反，大小相同，如图所示。</p><p>从而产生的科里奥利力方向相反，压迫两块对应的电容板移动，产生电容差分变化，电容的变化正比于旋转的角速度。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221013160705853.png"></p><ul><li>电容的变化正比于旋转角速度</li><li>纯加速度并不能使陀螺仪产生读数</li></ul><h4 id="校正-1"><a href="#校正-1" class="headerlink" title="校正"></a>校正</h4><h5 id="误差模型-1"><a href="#误差模型-1" class="headerlink" title="误差模型"></a>误差模型</h5><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221013161722841.png"></p><h5 id="校正方法"><a href="#校正方法" class="headerlink" title="校正方法"></a>校正方法</h5><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221013163003155.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221013164814176.png"></p><blockquote><p>龙格库塔法</p></blockquote><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221014155923500.png"></p><h5 id="测量模型-1"><a href="#测量模型-1" class="headerlink" title="测量模型"></a>测量模型</h5><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221014155641676.png"></p><h3 id="三轴磁力计"><a href="#三轴磁力计" class="headerlink" title="三轴磁力计"></a>三轴磁力计</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20221014164233288.png"></p><h3 id="超声波测距仪"><a href="#超声波测距仪" class="headerlink" title="超声波测距仪"></a>超声波测距仪</h3><p>超声波是一种频率超出人耳听觉频率的声波，大于20kHz。具有良好的方向性和强大的穿透性。</p><h3 id="气压计"><a href="#气压计" class="headerlink" title="气压计"></a>气压计</h3><p>如果多旋翼悬停高度距离地面过大，超声波测距仪就会失效，这时应当使用气压计。</p><h2 id="可观性和卡尔曼滤波器"><a href="#可观性和卡尔曼滤波器" class="headerlink" title="可观性和卡尔曼滤波器"></a>可观性和卡尔曼滤波器</h2><p>略</p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UAV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>涵道无人机建模</title>
      <link href="/2023/01/11/Learn/UAV/%E6%B6%B5%E9%81%93%EF%BC%9A%E6%B6%B5%E9%81%93%E6%97%A0%E4%BA%BA%E6%9C%BA%E5%BB%BA%E6%A8%A1/"/>
      <url>/2023/01/11/Learn/UAV/%E6%B6%B5%E9%81%93%EF%BC%9A%E6%B6%B5%E9%81%93%E6%97%A0%E4%BA%BA%E6%9C%BA%E5%BB%BA%E6%A8%A1/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="无人机建模及运动方程"><a href="#无人机建模及运动方程" class="headerlink" title="无人机建模及运动方程"></a>无人机建模及运动方程</h2><h3 id="坐标系定义及运动方程"><a href="#坐标系定义及运动方程" class="headerlink" title="坐标系定义及运动方程"></a>坐标系定义及运动方程</h3><h4 id="坐标系定义"><a href="#坐标系定义" class="headerlink" title="坐标系定义"></a>坐标系定义</h4><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230108103216237.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230108103159942.png" alt="-"></p><p>坐标如图所示：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230108103712962.png"></p><h4 id="运动学方程"><a href="#运动学方程" class="headerlink" title="运动学方程"></a>运动学方程</h4><p>六自由度刚体的运动学方程：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230108102927616.png"></p><p>旋转矩阵的导数：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230108103007669.png"></p><h4 id="动力学方程"><a href="#动力学方程" class="headerlink" title="动力学方程"></a>动力学方程</h4><p>动量定理和角动量定理只有在惯性系(NED系)中才成立，因此在非惯性系(机体系)中表示的动力学方程需要通过旋转变换得到。</p><p>在NED系中由动量定理，有</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230108105110754.png"></p><p>其实，G&#x3D;mg为无人机所受重力，F为除重力外其他力的矢量和。</p><p>在非惯性系下表示该方程：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230108105210913.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230108105220625.png"></p><p>代入NED系动量定理，可得</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230108105227121.png"></p><p>欧拉动力学方程：</p><p>惯性张量在NED中的表示是一个变量，而在机体系中的表示是一个常量，因此旋转动力学方程一般在机体系中表示。</p><p>推导见论文P24</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230108112255632.png"></p><p>整理合并，得涵道无人机得非线性模型：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230108113242454.png"></p><h2 id="单涵道动力学分析"><a href="#单涵道动力学分析" class="headerlink" title="单涵道动力学分析"></a>单涵道动力学分析</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230108114441049.png"></p><h3 id="空气阻力"><a href="#空气阻力" class="headerlink" title="空气阻力"></a>空气阻力</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230108114623458.png"></p><blockquote><p>飞机的升力公式详解<br>Y&#x3D;1&#x2F;2ρCSv²<br>式中：<br>Y是总升力，（单位是：牛顿，即N，1千克力约等于10牛顿）</p><p>C是升力系数，是个不名数，没有单位，是通过风洞实验测出的系数，但一般可按1进行粗略计算，升力系数和机翼的翼型（就是机翼断面的形状，一般前圆后尖、上曲下平、较厚的，例如达到弦长的15%的翼型具有较大的升力系数）、迎角（就是翼弦与气流的夹角，升力系数与迎角正相关，较厚的机翼允许迎角较大，例如10～12°，较薄的机翼不允许大迎角，只能6～8°，太大就会因升力系数迅速减小而失速）、展弦比（展弦比越大，升力系数越大）、机翼表面的光滑程度（越光滑升力系数越大）有关。</p><p>展弦比：翼长的平方除以翼的面积</p><p>S是机翼的面积（单位是：平方米，即m2）。</p><p>v是飞机的速度（单位是：米&#x2F;秒，即m&#x2F;s，如果的公里&#x2F;小时就要除以3.6，换算成米&#x2F;秒；如果是顶风，就要用飞机的速度加风速，如果是顺风，就要用飞机的速度减风速，单位都用米&#x2F;秒）。注意，公式里是平方。速度大三倍，升力大九倍。</p><p>ρ是大气密度（和当地海拔高度、气温、湿度有关，海拔500米之下可按1.2计算，单位是：千克&#x2F;立方米，即Kg&#x2F;m3）。</p></blockquote><h3 id="涵道内部风扇"><a href="#涵道内部风扇" class="headerlink" title="涵道内部风扇"></a>涵道内部风扇</h3><p>假设流动为管流，建立涵道风扇轴流状态的管流模型。气体在无穷远处速度为Vc，经过风扇桨盘时加速至Vc+Vi，最终以Vc+V2形成尾迹。如图所示。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230108161630475.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230108163843366.png"></p><blockquote><p>涵道体上产生的拉力？</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230108163946929.png"></p></blockquote><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230108164543358.png"></p><blockquote><p>理想正压流体在有势体积力作用下作定常运动时，运动方程(即欧拉方程)沿流线积分而得到的表达运动流体机械能守恒的方程。因著名的瑞士科学家D.伯努利于1738年提出而得名。对于重力场中的不可压缩均质流体 ，方程为p+ρgh+(1&#x2F;2)*ρv^2&#x3D;c　式中p、ρ、v分别为流体的压强、密度和速度；h为铅垂高度；g为重力加速度ρgh和动能(1&#x2F;2)*ρv ^2，在沿流线运动过程中，总和保持不变，即总能量守恒。但各流线之间总能量（即上式中的常量值）可能不同。对于气体，可忽略重力，方程简化为p+(1&#x2F;2)*ρv ^2&#x3D;常量(p0)，各项分别称为静压 、动压和总压。</p></blockquote><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230108164621695.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230108170557006.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230108170706121.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230108170838419.png"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230108170936059.png"></p><h3 id="涵道动力学"><a href="#涵道动力学" class="headerlink" title="涵道动力学"></a>涵道动力学</h3><p> 略</p><h3 id="涵道底部控制舵"><a href="#涵道底部控制舵" class="headerlink" title="涵道底部控制舵"></a>涵道底部控制舵</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230109213745427.png"></p><p>每个操纵面上产生的升力可表示为：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230109221947035.png"></p><p>其中，k为操纵面气动升力系数，和攻角有关。Vi+Vc为涵道出口气流流速。</p><blockquote><p>攻角，指的是飞机机翼弦线与相对风的夹角。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230109222150764.png"></p></blockquote><p>由操纵面产生的作用于机体的力和力矩可分别表示为：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230109223101909.png"></p><p>其中，Mc为驱动力矩，Tx、Ty、Tz为驱动力矩在机体系坐标轴上的投影。</p><h3 id="固定气动面动力学和陀螺力矩"><a href="#固定气动面动力学和陀螺力矩" class="headerlink" title="固定气动面动力学和陀螺力矩"></a>固定气动面动力学和陀螺力矩</h3><p>单涵道无人机内部设计固定气动面以平衡悬停状态下风扇反扭距的影响。</p><p>固定气动面对涵道轴得到力矩可近似为：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230109224911130.png"></p><p>如图所示：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230109224921143.png"></p><p>在悬停点附近，涵道风扇转速几乎恒定，只有在剧烈的机动飞行中，转速变化才会比较明显了。为简单起见，假设风扇转速的变换可以忽略不计。因此，由风扇的旋转产生陀螺力矩可表示为：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230109225201109.png"></p><p>其中，Ib为风扇转动惯量，Lr为风扇角动量。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1]基于自抗扰控制的涵道无人机控制分配_蒙超恒</p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UAV </tag>
            
            <tag> 建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动手学ROS2</title>
      <link href="/2023/01/11/Learn/ROS/%E5%8A%A8%E6%89%8B%E5%AD%A6ROS2/"/>
      <url>/2023/01/11/Learn/ROS/%E5%8A%A8%E6%89%8B%E5%AD%A6ROS2/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><strong>原文作者链接：<a href="https://fishros.com/d2lros2/#/">https://fishros.com/d2lros2/#/</a></strong></p><h2 id="ROS介绍"><a href="#ROS介绍" class="headerlink" title="ROS介绍"></a>ROS介绍</h2><h3 id="ROS与ROS2对比"><a href="#ROS与ROS2对比" class="headerlink" title="ROS与ROS2对比"></a>ROS与ROS2对比</h3><h4 id="Ros的问题举例"><a href="#Ros的问题举例" class="headerlink" title="Ros的问题举例"></a>Ros的问题举例</h4><p>ROS的设计目标是简化机器人的开发，如何简化呢？ROS为此设计了一整套通信机制（话题、服务、参数、动作）。</p><p>通过这些通信机制，ROS实现了将机器人的各个组件给的连接起来，在设计这套通信机制的时候就设计了一个叫做<code>Ros Master</code>的东西，所有节点（可以理解为某一个组件，比如：激光雷达）的通信建立必须经过这个主节点。</p><p>这种组合结构图如下：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20220918171101672.png"></p><p>主节点激光雷达节点避障检测节点底盘驱动节点</p><p>一旦<code>Ros Master</code>主节点挂掉后，就会<strong>造成整个系统通信的异常</strong>,此时避障策略将会失效，如果机器人正在运行，碰到障碍物会径直装上去，机毁人亡！</p><blockquote><p>ROS的不稳定这个问题在虽然对大家做机器人研究问题不大，但如果是想基于ROS做商业化机器人（比如无人驾驶汽车），就会造成非常严重的后果，小鱼在工作中可没为这个问题发愁</p></blockquote><p>除了不稳定这个问题，ROS还有很多其他地方存在着问题：</p><ul><li>通信基于TCP实现，实时性差、系统开销大</li><li>对Python3支持不友好，需要重新编译</li><li>消息机制不兼容</li><li>没有加密机制、安全性不高</li></ul><h4 id="ROS与ROS2架构对比"><a href="#ROS与ROS2架构对比" class="headerlink" title="ROS与ROS2架构对比"></a>ROS与ROS2架构对比</h4><p>所以在ROS2中，首当其冲的将ROS的主节点干掉了，这里放一张网上流传最广的ROS&#x2F;ROS2架构图。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20220918171819801.png"></p><p><u><strong>OS层：</strong></u>从原来的只支持linux平台变成了支持windows、mac甚至是嵌入式RTOS平台，多平台！</p><p><u><strong>MiddleWare中间件层：</strong></u>那么中间层ROS2到底相对于ROS做了哪些优化呢？</p><ol><li><p>去中心化master，ROS和ROS2中间件不同之处在于，ROS2取消了master节点。</p><p>去中心化后，各个节点之间可以通过DDS的节点相互发现，各个节点都是平等的，且可以1对1、1对n、n对n进行互相通信。</p></li><li><p>不造通信的轮子，通信直接更换为DDS进行实现采用DDS通信，使得ROS2的实时性、可靠性和连续性上都有了增强。</p></li></ol><p><u><strong>应用层：</strong></u>对于应用层来说ROS2也做了很大的改进，上面那张图没有体现出来。</p><p>​ROS2进行改进有：</p><ol><li>python2到pyhton3的支持</li><li>编译系统的改进（catkin到ament）</li><li>C++标准更新到c++11</li><li>可以使用相同 API 的进程间和进程内通信</li></ol><p><strong><u>新概念举例：</u></strong></p><ul><li>可用Python编写的Launch文件</li><li>多机器人协同通信支持</li><li>支持安全加密通信</li><li>同一个进程支持多个节点、</li><li>支持Qos服务质量</li><li>支持节点生命周期管理</li><li>高效的进程间通信</li></ul><h3 id="ROS2初体验"><a href="#ROS2初体验" class="headerlink" title="ROS2初体验"></a>ROS2初体验</h3><h4 id="1-游戏1：你说我听"><a href="#1-游戏1：你说我听" class="headerlink" title="1.游戏1：你说我听"></a>1.游戏1：你说我听</h4><p>游戏内容：很简单，我们启动两个节点，一个节点负责发消息(说)，一个节点负责收消息（听）。</p><ol><li><p>启动一个终端Ctrl+Alt+T</p></li><li><p>启动倾听者</p><pre class="line-numbers language-none"><code class="language-none">ros2 run demo_nodes_py listenerCopy to clipboardErrorCopied<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>启动一个新终端Ctrl+Alt+T</p></li><li><p>启动说话者</p><pre class="line-numbers language-none"><code class="language-none">ros2 run demo_nodes_cpp talkerCopy to clipboardErrorCopied<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p>观察一下现象，talker节点每数一个输，倾听节点每一次都能听到一个，是不是很神奇。</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20220603124845382.png"></p><h4 id="2-游戏2-涂鸦乌龟"><a href="#2-游戏2-涂鸦乌龟" class="headerlink" title="2.游戏2:涂鸦乌龟"></a>2.游戏2:涂鸦乌龟</h4><p>游戏内容：启动海龟模拟器，启动海龟遥控器，控制海龟在地图上画出任意轨迹即可。</p><blockquote><p>本来是控制海龟画个五角星的，但经过手动多次尝试，发现太难了。大家有时间可以试试，有搞定的可以发个图在群里分享一下。</p></blockquote><p>2.1 启动海龟模拟器</p><p>打开终端Ctrl+Alt+T,输入下面的指令</p><pre class="line-numbers language-none"><code class="language-none">ros2 run turtlesim turtlesim_nodeCopy to clipboardErrorCopied<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>就可以看到这样的界面</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20210720123734477.png"></p><p>2.2 启动海龟遥控器</p><p>点一下原来的终端输入Ctrl+Shift+T 打开一个新的标签页输入</p><pre class="line-numbers language-none"><code class="language-none">ros2 run turtlesim turtle_teleop_keyCopy to clipboardErrorCopied<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>你可以看到这样子的界面</p><p><img src="https://fishros.com/d2lros2/humble/chapt1/get_started/4.ROS2%E5%88%9D%E4%BD%93%E9%AA%8C/imgs/image-20210720124022925.png"></p><p>这个时候你就可以使用上下左右去遥控海龟了，快试一试吧。</p><p><img src="https://fishros.com/d2lros2/humble/chapt1/get_started/4.ROS2%E5%88%9D%E4%BD%93%E9%AA%8C/imgs/image-20210720125026860.png"></p><h4 id="3-RQT可视化"><a href="#3-RQT可视化" class="headerlink" title="3. RQT可视化"></a>3. RQT可视化</h4><p>保持前面两个游戏在运行状态，打开终端，输入rqt。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rqtCopy to clipboardErrorCopied<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>打开之后的窗口如下图，空空如也，不要担心，因为我们没有选插件的原因。</p><p><img src="https://fishros.com/d2lros2/humble/chapt1/get_started/4.ROS2%E5%88%9D%E4%BD%93%E9%AA%8C/imgs/image-20220603124701935.png"></p><p>选择插件</p><p>这里我们可以选择现有的几个RQT插件来试一试，可以看到和话题、参数、服务、动作四大通信组件相关的工具都有，还有一些可视化、日志和系统计算图等相关的。</p><p><img src="https://fishros.com/d2lros2/humble/chapt1/get_started/4.ROS2%E5%88%9D%E4%BD%93%E9%AA%8C/imgs/image-20220603124722852.png"></p><p>Introspection &#x2F; Node Graph</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20220603124722852.png"></p><p>打开后就可以看到上面几个节点之间的数据关系了，是不是很方便的工具。</p><p><img src="https://fishros.com/d2lros2/humble/chapt1/get_started/4.ROS2%E5%88%9D%E4%BD%93%E9%AA%8C/imgs/image-20220603125332498.png"></p><h3 id="ROS2系统架构"><a href="#ROS2系统架构" class="headerlink" title="ROS2系统架构"></a>ROS2系统架构</h3><h4 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h4><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20220602204152352.png"></p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>磁力计与地磁场</title>
      <link href="/2023/01/11/Learn/%E6%9D%82/%E7%A3%81%E5%8A%9B%E8%AE%A1&amp;%E5%9C%B0%E7%A3%81%E5%9C%BA/"/>
      <url>/2023/01/11/Learn/%E6%9D%82/%E7%A3%81%E5%8A%9B%E8%AE%A1&amp;%E5%9C%B0%E7%A3%81%E5%9C%BA/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h3 id="1、地球磁场分布图："><a href="#1、地球磁场分布图：" class="headerlink" title="1、地球磁场分布图："></a>1、地球磁场分布图：</h3><p> 地球磁场：地球的磁场象一个条形磁体一样由磁南极指向磁北极。在磁极点处磁场和当地的水平面垂直，在赤道磁场和当地的水平面平行，所以在北半球磁场方向倾斜指向地面。用来衡量磁感应强度大小的单位是Tesla或者Gauss（1Tesla&#x3D;10000Gauss）。随着地理位置的不同，通常地磁场的强度是0.4-0.6Gauss。需要注意的是，磁北极和地理上的北极并不重合，通常他们之间有11.5度左右的夹角。</p><p>单位：</p><p>1Tesla&#x3D;10000Gauss</p><p>1高斯 &#x3D;100000 nT</p><p>1高斯 &#x3D;1000 mGauss</p><p>1mGauss&#x3D;100nT<br><img src="https://img-blog.csdnimg.cn/2020042015072466.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d1d3VrdTEyMw==,size_16,color_FFFFFF,t_70"></p><h3 id="2、-地磁要素图："><a href="#2、-地磁要素图：" class="headerlink" title="2、 地磁要素图："></a><strong>2、 地磁要素图：</strong></h3><p>设观测点在O处，并以O点为原点建立地理坐标系OXYZ，X轴指向北，Y轴指向东，Z轴垂直指向地。</p><p><a href="https://img-blog.csdnimg.cn/20200420150740771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d1d3VrdTEyMw==,size_16,color_FFFFFF,t_70"><img src="https://img-blog.csdnimg.cn/20200420150740771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d1d3VrdTEyMw==,size_16,color_FFFFFF,t_70"></a></p><p>   地磁场强度T在X轴上的投影Bn称为地磁场的北向分量；T在Y轴上的投影Be称为东向分量；T在Z轴上的投影Bz称为地磁场的垂向分量。T在水平面O-XY的投影Bh称为地磁场的水平分量。地磁水平分量Bh和垂向分量Bz所在平面称为磁子午面，磁子午面和地理子午面O-XZ平面的夹角称为磁偏角，用D表示，并规定其东偏为正，西偏为负。地磁场强度T与水平面O-XY的夹角称为磁倾角，用I表示。上述，T、Bh、Bn、Be、Bz、D、I统称为地磁场七要素，可作为定位定向的参考量。七要素只要知道三个独立的要素，就可以求其余的要素，常用的是磁倾角、磁偏角和水平分量。七要素间有如下关系：<br><a href="https://img-blog.csdnimg.cn/20200420152053240.png"><img src="https://img-blog.csdnimg.cn/20200420152053240.png"></a></p><p>3、中国地磁要素变化：<br>    中国的地磁要素大致分布情况：国境内地磁强度总量范围0.41~0.60Gauss(1 Gauss &#x3D; 10^-4T)；水平分量Bh由南至北从0.4降至0.21；垂直分量Bz由南至北从-0.1增至0.56；磁倾角I由南至北从-10°增至70°；磁偏角D由东向西从-11°增至5°，零偏线在中国中部偏西处，由北向南经过甘肃的安西以及西藏的得宋。</p><p>4、地磁场的一级近似：<br>对地磁场的一种近似，如下图所示：<br><a href="https://img-blog.csdnimg.cn/20200420153133439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d1d3VrdTEyMw==,size_16,color_FFFFFF,t_70"><img src="https://img-blog.csdnimg.cn/20200420153133439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d1d3VrdTEyMw==,size_16,color_FFFFFF,t_70"></a></p><p>不考虑地磁轴与地球自转轴的偏离问题，地磁强度分量可用以下解析式来描述：</p><p><img src="https://img-blog.csdnimg.cn/2020042015332184.png"></p><p>其中，东向地磁分量为0；在实际运算中，将磁力计在水平面X、Y轴的测量值，全部投影到北向，并将东向置零。</p><h1 id="二、计算"><a href="#二、计算" class="headerlink" title="二、计算"></a>二、计算</h1><p>[<a href="https://zinghd.gitee.io/knowledge-point-1/">知识点]基于加速度计与磁力计的姿态解算方法(加计补偿偏航) | 曾同学的思考 (gitee.io)</a></p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四元数与欧拉角与旋转矩阵</title>
      <link href="/2023/01/11/Learn/%E6%95%B0%E5%AD%A6/%E5%9B%9B%E5%85%83%E6%95%B0%E4%B8%8E%E6%AC%A7%E6%8B%89%E8%A7%92%E4%B8%8E%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5/"/>
      <url>/2023/01/11/Learn/%E6%95%B0%E5%AD%A6/%E5%9B%9B%E5%85%83%E6%95%B0%E4%B8%8E%E6%AC%A7%E6%8B%89%E8%A7%92%E4%B8%8E%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a href="https://www.cnblogs.com/21207-iHome/p/6894128.html">四元数与欧拉角（RPY角）的相互转换 - XXX已失联 - 博客园 (cnblogs.com)</a></p><p>关于四元数旋转矩阵的推导：</p><p><a href="https://blog.csdn.net/u014265928/article/details/117170481">(66条消息) 【机器人学】绕空间任意轴的旋转矩阵推导_whu木小易的博客-CSDN博客_绕任意轴旋转的旋转矩阵</a></p><p>四元数与旋转矩阵的转换：</p><p><a href="https://blog.csdn.net/u014265928/article/details/117161701">(66条消息) 【机器人学】四元数与旋转矩阵的相互转换_whu木小易的博客-CSDN博客_四元数与旋转矩阵转换</a></p><p>结论：</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230111230403340.png" alt="旋转矩阵"></p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230107160428256.png" alt="四元数解欧拉角"></p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>矩阵的伪逆</title>
      <link href="/2023/01/11/Learn/%E6%95%B0%E5%AD%A6/%E7%9F%A9%E9%98%B5%E7%9A%84%E4%BC%AA%E9%80%86/"/>
      <url>/2023/01/11/Learn/%E6%95%B0%E5%AD%A6/%E7%9F%A9%E9%98%B5%E7%9A%84%E4%BC%AA%E9%80%86/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="满秩-x2F-列满秩-x2F-行满秩"><a href="#满秩-x2F-列满秩-x2F-行满秩" class="headerlink" title="满秩&#x2F;列满秩&#x2F;行满秩"></a>满秩&#x2F;列满秩&#x2F;行满秩</h2><p>设A是n阶矩阵, 若r（A） &#x3D; n, 则称A为满秩矩阵。但满秩不局限于n阶矩阵。</p><p>若矩阵秩等于行数，称为行满秩；若矩阵秩等于列数，称为列满秩。既是行满秩又是列满秩则为n阶矩阵即n阶方阵。行满秩矩阵就是行向量线性无关，列满秩矩阵就是列向量线性无关；所以如果是方阵,行满秩矩阵与列满秩矩阵是等价的。</p><h3 id="左逆与右逆"><a href="#左逆与右逆" class="headerlink" title="左逆与右逆"></a>左逆与右逆</h3><h4 id="左逆（Left-inverse）"><a href="#左逆（Left-inverse）" class="headerlink" title="左逆（Left inverse）"></a>左逆（Left inverse）</h4><p>　　如果<strong>A</strong>是一个m×n的列满秩矩阵，意味着<strong>A</strong>的各列线性无关，<strong>A</strong>的秩和列数相等，r &#x3D; n，但<strong>A</strong>可能存在更多的行，m ≥ n，此时<strong>A</strong>的零空间只有零向量，并且<strong>Ax</strong> &#x3D; <strong>b</strong>有唯一解（m &#x3D; n时）或无解（m &gt; n时）。</p><p>　　对于列满秩矩阵来说，对称矩阵<strong>ATA</strong>是一个n×n的满秩方阵，因此<strong>ATA</strong>可逆，此时：</p><p><img src="https://img2018.cnblogs.com/blog/1203675/201912/1203675-20191219212030618-546806398.png"></p><p>　　</p><p>　　我们称<strong>A</strong>-1left为<strong>A</strong>的左逆，是一个n×m的矩阵，左逆也是讨论最小二乘问题的核心。</p><h4 id="右逆（Right-inverse）"><a href="#右逆（Right-inverse）" class="headerlink" title="右逆（Right inverse）"></a>右逆（Right inverse）</h4><p>　　如果<strong>A</strong>是一个m×n的行满秩矩阵，意味着<strong>A</strong>的各行线性无关，<strong>A</strong>的秩和行数相等，r &#x3D; m，但<strong>A</strong>可能存在更多的列，m ≤ n。<strong>A</strong>的左零空间只有零向量，<strong>A</strong>的零空间是n - r维，因此有n – r个自由变量，当n &gt; m时，<strong>Ax</strong> &#x3D; <strong>b</strong>有无数解。</p><p>　　对于行满秩矩阵来说，对称矩阵<strong>AAT</strong>是一个m×m的满秩方阵，因此<strong>AAT</strong>可逆，此时：</p><p><img src="https://img2018.cnblogs.com/blog/1203675/201912/1203675-20191219212047065-958765262.png"></p><p>　　通常来说，右乘左逆得不到单位矩阵，仅在m &#x3D; n时才有<strong>AA</strong>-1left &#x3D; <strong>I</strong>。对于列满秩的m×n矩阵来说，<strong>AA</strong>-1left &#x3D; <strong>A</strong>(<strong>A</strong>T<strong>A</strong>)-1<strong>A</strong>T &#x3D; <strong>P</strong>，<strong>P</strong>是<strong>A</strong>的列空间的投影矩阵。同理，左乘右逆也得不到单位矩阵，<strong>A</strong>-1right<strong>A</strong>是<strong>A</strong>的行空间的投影矩阵。</p><p>From Wikipedia:</p><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230107165213444.png"></p><p>列满秩对应有左逆。行满秩对应右逆。</p><h3 id="Question-为何列满秩，Atranspose-A一定可逆？"><a href="#Question-为何列满秩，Atranspose-A一定可逆？" class="headerlink" title="Question:为何列满秩，Atranspose A一定可逆？"></a>Question:为何列满秩，Atranspose A一定可逆？</h3><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230107171325994.png"></p><h2 id="伪逆性质"><a href="#伪逆性质" class="headerlink" title="伪逆性质"></a>伪逆性质</h2><p><img src="https://img2018.cnblogs.com/blog/1203675/201912/1203675-20191219212655293-2111508311.png"></p><h2 id="伪逆与SVD"><a href="#伪逆与SVD" class="headerlink" title="伪逆与SVD"></a>伪逆与SVD</h2><p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/image-20230107175536979.png"></p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
