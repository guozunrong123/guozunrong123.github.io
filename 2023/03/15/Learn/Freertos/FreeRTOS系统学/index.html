<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Freertos, ZRong&#39;s Blog">
    <meta name="description" content="参考韦东山RTOS">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>Freertos | ZRong&#39;s Blog</title>
    <link rel="icon" type="image/png" href="/16favicon.png">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="ZRong's Blog" type="application/atom+xml">
</head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/16favicon.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">ZRong&#39;s Blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/16favicon.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">ZRong&#39;s Blog</div>
        <div class="logo-desc">
            
            There is no royal road to learning.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/6.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Freertos</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
                                <span class="chip bg-color">操作系统</span>
                            </a>
                        
                            <a href="/tags/Freertos/">
                                <span class="chip bg-color">Freertos</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Learn/" class="post-category">
                                Learn
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2023-03-15
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    10.8k
                </div>
                

                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.min.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <meta name="referrer" content="no-referrer" />

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>强推韦东山rtos教程</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/439059278">韦东山freeRTOS系列教程：入门文档教程+进阶视频教程(全部免费的freeRTOS系列教程、freeRTOS学习路线) - 知乎 (zhihu.com)</a></p>
<h1 id="2-内存管理"><a href="#2-内存管理" class="headerlink" title="2.内存管理"></a>2.内存管理</h1><h2 id="2-1-为什么要自己实现内存管理"><a href="#2-1-为什么要自己实现内存管理" class="headerlink" title="2.1 为什么要自己实现内存管理"></a>2.1 为什么要自己实现内存管理</h2><p>后续的章节涉及这些内核对象：task、queue、semaphores和event group等。为了让FreeRTOS更容易使用，这些内核对象一般都是动态分配：用到时分配，不使用时释放。使用内存的动态管理功能，简化了程序设计：不再需要小心翼翼地提前规划各类对象，简化API函数的涉及，甚至可以减少内存的使用。</p>
<p>内存的动态管理是C程序的知识范畴，并不属于FreeRTOS的知识范畴，但是它跟FreeRTOS关系是如此紧密，所以我们先讲解它。</p>
<p>在C语言的库函数中，有mallc、free等函数，但是在FreeRTOS中，它们不适用：</p>
<ul>
<li>不适合用在资源紧缺的嵌入式系统中</li>
<li>这些函数的实现过于复杂、占据的代码空间太大</li>
<li>并非线程安全的(thread-safe)</li>
<li>运行有不确定性：每次调用这些函数时花费的时间可能都不相同</li>
<li>内存碎片化</li>
<li>使用不同的编译器时，需要进行复杂的配置</li>
<li>有时候难以调试</li>
</ul>
<p>注意：我们经常”堆栈”混合着说，其实它们不是同一个东西：</p>
<ul>
<li>堆，heap，就是一块空闲的内存，需要提供管理函数<ul>
<li>malloc：从堆里划出一块空间给程序使用</li>
<li>free：用完后，再把它标记为”空闲”的，可以再次使用</li>
</ul>
</li>
<li>栈，stack，函数调用时局部变量保存在栈中，当前程序的环境也是保存在栈中<ul>
<li>可以从堆中分配一块空间用作栈</li>
</ul>
</li>
</ul>
<p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/01_heap_stack.png" alt="image-20210728144756070"></p>
<h2 id="2-2-FreeRTOS的5种内存管理方法"><a href="#2-2-FreeRTOS的5种内存管理方法" class="headerlink" title="2.2 FreeRTOS的5种内存管理方法"></a>2.2 FreeRTOS的5种内存管理方法</h2><p>FreeRTOS中内存管理的接口函数为：pvPortMalloc 、vPortFree，对应于C库的malloc、free。</p>
<p>文件在<code>FreeRTOS/Source/portable/MemMang</code>下，它也是放在<code>portable</code>目录下，表示你可以提供自己的函数。</p>
<p>源码中默认提供了5个文件，对应内存管理的5种方法。</p>
<p>参考文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43212092/article/details/104845158">FreeRTOS说明书吐血整理【适合新手+入门】</a></p>
<table>
<thead>
<tr>
<th>文件</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>heap_1.c</td>
<td>分配简单，时间确定</td>
<td>只分配、不回收</td>
</tr>
<tr>
<td>heap_2.c</td>
<td>动态分配、最佳匹配</td>
<td>碎片、时间不定</td>
</tr>
<tr>
<td>heap_3.c</td>
<td>调用标准库函数</td>
<td>速度慢、时间不定</td>
</tr>
<tr>
<td>heap_4.c</td>
<td>相邻空闲内存可合并</td>
<td>可解决碎片问题、时间不定</td>
</tr>
<tr>
<td>heap_5.c</td>
<td>在heap_4基础上支持分隔的内存块</td>
<td>可解决碎片问题、时间不定</td>
</tr>
</tbody></table>
<h3 id="2-2-1-Heap-1"><a href="#2-2-1-Heap-1" class="headerlink" title="2.2.1 Heap_1"></a>2.2.1 Heap_1</h3><p>它只实现了pvPortMalloc，没有实现vPortFree。</p>
<p>如果你的程序不需要删除内核对象，那么可以使用heap_1：</p>
<ul>
<li>实现最简单</li>
<li>没有碎片问题</li>
<li>一些要求非常严格的系统里，不允许使用动态内存，就可以使用heap_1</li>
</ul>
<p>它的实现原理很简单，首先定义一个大数组：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;* Allocate the memory for the heap. *&#x2F;
#if ( configAPPLICATION_ALLOCATED_HEAP &#x3D;&#x3D; 1 )

&#x2F;* The application writer has already defined the array used for the RTOS
* heap - probably so it can be placed in a special segment or address. *&#x2F;
    extern uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];
#else
    static uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];
#endif &#x2F;* configAPPLICATION_ALLOCATED_HEAP *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>然后，对于pvPortMalloc调用时，从这个数组中分配空间。</p>
<p>FreeRTOS在创建任务时，需要2个内核对象：task control block(TCB)、stack。</p>
<p>使用heap_1时，内存分配过程如下图所示：</p>
<ul>
<li>A：创建任务之前整个数组都是空闲的</li>
<li>B：创建第1个任务之后，蓝色区域被分配出去了</li>
<li>C：创建3个任务之后的数组使用情况</li>
</ul>
<p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/02_heap_1.png" alt="image-20210728154645642"></p>
<h3 id="2-2-2-Heap-2"><a href="#2-2-2-Heap-2" class="headerlink" title="2.2.2 Heap_2"></a>2.2.2 Heap_2</h3><p>Heap_2之所以还保留，只是为了兼容以前的代码。新设计中不再推荐使用Heap_2。建议使用Heap_4来替代Heap_2，更加高效。</p>
<p>Heap_2也是在数组上分配内存，跟Heap_1不一样的地方在于：</p>
<ul>
<li>Heap_2使用<strong>最佳匹配算法</strong>(best fit)来分配内存</li>
<li>它支持vPortFree</li>
</ul>
<p>最佳匹配算法：</p>
<ul>
<li>假设heap有3块空闲内存：5字节、25字节、100字节</li>
<li>pvPortMalloc想申请20字节</li>
<li>找出最小的、能满足pvPortMalloc的内存：25字节</li>
<li>把它划分为20字节、5字节<ul>
<li>返回这20字节的地址</li>
<li>剩下的5字节仍然是空闲状态，留给后续的pvPortMalloc使用</li>
</ul>
</li>
</ul>
<p>与Heap_4相比，Heap_2不会合并相邻的空闲内存，所以Heap_2会导致严重的”碎片化”问题。</p>
<p>但是，如果申请、分配内存时大小总是相同的，这类场景下Heap_2没有碎片化的问题。所以它适合这种场景：频繁地创建、删除任务，但是任务的栈大小都是相同的(创建任务时，需要分配TCB和栈，TCB总是一样的)。</p>
<p>虽然不再推荐使用heap_2，但是它的效率还是远高于malloc、free。</p>
<p>使用heap_2时，内存分配过程如下图所示：</p>
<ul>
<li>A：创建了3个任务</li>
<li>B：删除了一个任务，空闲内存有3部分：顶层的、被删除任务的TCB空间、被删除任务的Stack空间</li>
<li>C：创建了一个新任务，因为TCB、栈大小跟前面被删除任务的TCB、栈大小一致，所以刚好分配到原来的内存</li>
</ul>
<p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/03_heap_2.png" alt="image-20210728161556536"></p>
<h3 id="2-2-3-Heap-3"><a href="#2-2-3-Heap-3" class="headerlink" title="2.2.3 Heap_3"></a>2.2.3 Heap_3</h3><p>Heap_3使用标准C库里的malloc、free函数，所以堆大小由链接器的配置决定，配置项configTOTAL_HEAP_SIZE不再起作用。</p>
<p>C库里的malloc、free函数并非线程安全的，Heap_3中先暂停FreeRTOS的调度器，再去调用这些函数，使用这种方法实现了线程安全。</p>
<h3 id="2-2-4-Heap-4"><a href="#2-2-4-Heap-4" class="headerlink" title="2.2.4 Heap_4"></a>2.2.4 Heap_4</h3><p>跟Heap_1、Heap_2一样，Heap_4也是使用大数组来分配内存。</p>
<p>Heap_4使用<strong>首次适应算法</strong>(first fit)来分配内存。它还会把相邻的空闲内存合并为一个更大的空闲内存，这有助于较少内存的碎片问题。</p>
<p>首次适应算法：</p>
<ul>
<li>假设堆中有3块空闲内存：5字节、200字节、100字节</li>
<li>pvPortMalloc想申请20字节</li>
<li>找出第1个能满足pvPortMalloc的内存：200字节</li>
<li>把它划分为20字节、180字节<ul>
<li>返回这20字节的地址</li>
<li>剩下的180字节仍然是空闲状态，留给后续的pvPortMalloc使用</li>
</ul>
</li>
</ul>
<p>Heap_4会把相邻空闲内存合并为一个大的空闲内存，可以较少内存的碎片化问题。适用于这种场景：频繁地分配、释放不同大小的内存。</p>
<p>Heap_4的使用过程举例如下：</p>
<ul>
<li>A：创建了3个任务</li>
<li>B：删除了一个任务，空闲内存有2部分：<ul>
<li>顶层的</li>
<li>被删除任务的TCB空间、被删除任务的Stack空间合并起来的</li>
</ul>
</li>
<li>C：分配了一个Queue，从第1个空闲块中分配空间</li>
<li>D：分配了一个User数据，从Queue之后的空闲块中分配</li>
<li>E：释放的Queue，User前后都有一块空闲内存</li>
<li>F：释放了User数据，User前后的内存、User本身占据的内存，合并为一个大的空闲内存</li>
</ul>
<p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/04_heap_4.png" alt="image-20210728180440125"></p>
<p>Heap_4执行的时间是不确定的，但是它的效率高于标准库的malloc、free。</p>
<h3 id="2-2-5-Heap-5"><a href="#2-2-5-Heap-5" class="headerlink" title="2.2.5 Heap_5"></a>2.2.5 Heap_5</h3><p>Heap_5分配内存、释放内存的算法跟Heap_4是一样的。</p>
<p>相比于Heap_4，Heap_5并不局限于管理一个大数组：它可以管理多块、分隔开的内存。</p>
<p>在嵌入式系统中，内存的地址可能并不连续，这种场景下可以使用Heap_5。</p>
<p>既然内存是分隔开的，那么就需要进行初始化：确定这些内存块在哪、多大：</p>
<ul>
<li>在使用pvPortMalloc之前，必须先指定内存块的信息</li>
<li>使用vPortDefineHeapRegions来指定这些信息</li>
</ul>
<p>怎么指定一块内存？使用如下结构体：</p>
<pre class="line-numbers language-none"><code class="language-none">typedef struct HeapRegion
&#123;
    uint8_t * pucStartAddress; &#x2F;&#x2F; 起始地址
    size_t xSizeInBytes;       &#x2F;&#x2F; 大小
&#125; HeapRegion_t;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>怎么指定多块内存？使用一个HeapRegion_t数组，在这个数组中，低地址在前、高地址在后。</p>
<p>比如：</p>
<pre class="line-numbers language-none"><code class="language-none">HeapRegion_t xHeapRegions[] &#x3D;
&#123;
  &#123; ( uint8_t * ) 0x80000000UL, 0x10000 &#125;, &#x2F;&#x2F; 起始地址0x80000000，大小0x10000
  &#123; ( uint8_t * ) 0x90000000UL, 0xa0000 &#125;, &#x2F;&#x2F; 起始地址0x90000000，大小0xa0000
  &#123; NULL, 0 &#125; &#x2F;&#x2F; 表示数组结束
 &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>vPortDefineHeapRegions函数原型如下：</p>
<pre class="line-numbers language-none"><code class="language-none">void vPortDefineHeapRegions( const HeapRegion_t * const pxHeapRegions );<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>把xHeapRegions数组传给vPortDefineHeapRegions函数，即可初始化Heap_5。</p>
<h2 id="2-3-Heap相关的函数"><a href="#2-3-Heap相关的函数" class="headerlink" title="2.3 Heap相关的函数"></a>2.3 Heap相关的函数</h2><h3 id="2-3-1-pvPortMalloc-x2F-vPortFree"><a href="#2-3-1-pvPortMalloc-x2F-vPortFree" class="headerlink" title="2.3.1 pvPortMalloc&#x2F;vPortFree"></a>2.3.1 pvPortMalloc&#x2F;vPortFree</h3><p>函数原型：</p>
<pre class="line-numbers language-none"><code class="language-none">void * pvPortMalloc( size_t xWantedSize );	&#x2F;&#x2F; 分配内存，如果分配内存不成功，则返回值为NULL。
void vPortFree( void * pv );	&#x2F;&#x2F; 释放内存<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>作用：分配内存、释放内存。</p>
<p>如果分配内存不成功，则返回值为NULL。</p>
<h3 id="2-3-2-xPortGetFreeHeapSize"><a href="#2-3-2-xPortGetFreeHeapSize" class="headerlink" title="2.3.2 xPortGetFreeHeapSize"></a>2.3.2 xPortGetFreeHeapSize</h3><p>函数原型：</p>
<pre class="line-numbers language-none"><code class="language-none">size_t xPortGetFreeHeapSize( void );<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>当前还有多少空闲内存，这函数可以用来优化内存的使用情况。比如当所有内核对象都分配好后，执行此函数返回2000，那么configTOTAL_HEAP_SIZE就可减小2000。</p>
<p>注意：在heap_3中无法使用。</p>
<h3 id="2-3-3-xPortGetMinimumEverFreeHeapSize"><a href="#2-3-3-xPortGetMinimumEverFreeHeapSize" class="headerlink" title="2.3.3 xPortGetMinimumEverFreeHeapSize"></a>2.3.3 xPortGetMinimumEverFreeHeapSize</h3><p>函数原型：</p>
<pre class="line-numbers language-none"><code class="language-none">size_t xPortGetMinimumEverFreeHeapSize( void );<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>返回：程序运行过程中，空闲内存容量的最小值。</p>
<p>注意：只有heap_4、heap_5支持此函数。</p>
<h3 id="2-3-4-malloc失败的钩子函数"><a href="#2-3-4-malloc失败的钩子函数" class="headerlink" title="2.3.4 malloc失败的钩子函数"></a>2.3.4 malloc失败的钩子函数</h3><p>在pvPortMalloc函数内部：</p>
<pre class="line-numbers language-none"><code class="language-none">void * pvPortMalloc( size_t xWantedSize )
&#123;
    ......
    #if ( configUSE_MALLOC_FAILED_HOOK &#x3D;&#x3D; 1 )
        &#123;
            if( pvReturn &#x3D;&#x3D; NULL )
            &#123;
                extern void vApplicationMallocFailedHook( void );
                vApplicationMallocFailedHook();
            &#125;
        &#125;
    #endif
    
    return pvReturn;        
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>所以，如果想使用这个钩子函数：</p>
<ul>
<li>在FreeRTOSConfig.h中，把configUSE_MALLOC_FAILED_HOOK定义为1</li>
<li>提供vApplicationMallocFailedHook函数</li>
<li>pvPortMalloc失败时，才会调用此函数</li>
</ul>
<h1 id="3-任务管理"><a href="#3-任务管理" class="headerlink" title="3.任务管理"></a>3.任务管理</h1><h2 id="3-1-基本概念"><a href="#3-1-基本概念" class="headerlink" title="3.1 基本概念"></a>3.1 基本概念</h2><p>对于整个单片机程序，我们称之为application，应用程序。</p>
<p>使用FreeRTOS时，我们可以在application中创建多个任务(task)，有些文档把任务也称为线程(thread)。</p>
<p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/01_mother_do_jobs.png" alt="../../_images/01_mother_do_jobs.png"></p>
<p>以日常生活为例，比如这个母亲要同时做两件事：</p>
<ul>
<li>喂饭：这是一个任务</li>
<li>回信息：这是另一个任务</li>
</ul>
<p>这可以引入很多概念：</p>
<ul>
<li>任务状态(State)：<ul>
<li>当前正在喂饭，它是running状态；另一个”回信息”的任务就是”not running”状态</li>
<li>“not running”状态还可以细分：<ul>
<li>ready：就绪，随时可以运行</li>
<li>blocked：阻塞，卡住了，母亲在等待同事回信息</li>
<li>suspended：挂起，同事废话太多，不管他了</li>
</ul>
</li>
</ul>
</li>
<li>优先级(Priority)<ul>
<li>我工作生活兼顾：喂饭、回信息优先级一样，轮流做</li>
<li>我忙里偷闲：还有空闲任务，休息一下</li>
<li>厨房着火了，什么都别说了，先灭火：优先级更高</li>
</ul>
</li>
<li>栈(Stack)<ul>
<li>喂小孩时，我要记得上一口喂了米饭，这口要喂青菜了</li>
<li>回信息时，我要记得刚才聊的是啥</li>
<li>做不同的任务，这些细节不一样</li>
<li>对于人来说，当然是记在脑子里</li>
<li>对于程序，是记在栈里</li>
<li>每个任务有自己的栈</li>
</ul>
</li>
<li>事件驱动<ul>
<li>孩子吃饭太慢：先休息一会，等他咽下去了、等他提醒我了，再喂下一口</li>
</ul>
</li>
<li>协助式调度(Co-operative Scheduling)<ul>
<li>你在给同事回信息<ul>
<li>同事说：好了，你先去给小孩喂一口饭吧，你才能离开</li>
<li>同事不放你走，即使孩子哭了你也不能走</li>
</ul>
</li>
<li>你好不容易可以给孩子喂饭了<ul>
<li>孩子说：好了，妈妈你去处理一下工作吧，你才能离开</li>
<li>孩子不放你走，即使同事连发信息你也不能走</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>这涉及很多概念，后续章节详细分析。</p>
<h2 id="3-2-任务创建与删除"><a href="#3-2-任务创建与删除" class="headerlink" title="3.2 任务创建与删除"></a>3.2 任务创建与删除</h2><h3 id="3-2-1-什么是任务"><a href="#3-2-1-什么是任务" class="headerlink" title="3.2.1 什么是任务"></a>3.2.1 什么是任务</h3><p>在FreeRTOS中，任务就是一个函数，原型如下：</p>
<pre class="line-numbers language-none"><code class="language-none">void ATaskFunction( void *pvParameters );<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>要注意的是：</p>
<ul>
<li>这个函数不能返回</li>
<li>同一个函数，可以用来创建多个任务；换句话说，多个任务可以运行同一个函数</li>
<li>函数内部，尽量使用局部变量：<ul>
<li>每个任务都有自己的栈</li>
<li>每个任务运行这个函数时<ul>
<li>任务A的局部变量放在任务A的栈里、任务B的局部变量放在任务B的栈里</li>
<li>不同任务的局部变量，有自己的副本</li>
</ul>
</li>
<li>函数使用全局变量、静态变量的话<ul>
<li>只有一个副本：多个任务使用的是同一个副本</li>
<li>要防止冲突(后续会讲)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>下面是一个示例：</p>
<pre class="line-numbers language-none"><code class="language-none">void ATaskFunction( void *pvParameters )
&#123;
	&#x2F;* 对于不同的任务，局部变量放在任务的栈里，有各自的副本 *&#x2F;
	int32_t lVariableExample &#x3D; 0;
	
    &#x2F;* 任务函数通常实现为一个无限循环 *&#x2F;
	for( ;; )
	&#123;
		&#x2F;* 任务的代码 *&#x2F;
	&#125;

    &#x2F;* 如果程序从循环中退出，一定要使用vTaskDelete删除自己
     * NULL表示删除的是自己
     *&#x2F;
	vTaskDelete( NULL );
    
    &#x2F;* 程序不会执行到这里, 如果执行到这里就出错了 *&#x2F;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="3-2-2-创建任务"><a href="#3-2-2-创建任务" class="headerlink" title="3.2.2 创建任务"></a>3.2.2 创建任务</h3><p>创建任务时使用的函数如下：</p>
<pre class="line-numbers language-none"><code class="language-none">BaseType_t xTaskCreate( TaskFunction_t pxTaskCode, &#x2F;&#x2F; 函数指针, 任务函数
                        const char * const pcName, &#x2F;&#x2F; 任务的名字
                        const configSTACK_DEPTH_TYPE usStackDepth, &#x2F;&#x2F; 栈大小,单位为word,10表示40字节
                        void * const pvParameters, &#x2F;&#x2F; 调用任务函数时传入的参数
                        UBaseType_t uxPriority,    &#x2F;&#x2F; 优先级
                        TaskHandle_t * const pxCreatedTask ); &#x2F;&#x2F; 任务句柄, 以后使用它来操作这个任务<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>参数说明：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>pvTaskCode</td>
<td>函数指针，可以简单地认为任务就是一个C函数。 它稍微特殊一点：永远不退出，或者退出时要调用”vTaskDelete(NULL)”</td>
</tr>
<tr>
<td>pcName</td>
<td>任务的名字，FreeRTOS内部不使用它，仅仅起调试作用。 长度为：configMAX_TASK_NAME_LEN</td>
</tr>
<tr>
<td>usStackDepth</td>
<td>每个任务都有自己的栈，这里指定栈大小。 单位是word，比如传入100，表示栈大小为100 word，也就是400字节。 最大值为uint16_t的最大值。 怎么确定栈的大小，并不容易，很多时候是估计。 精确的办法是看反汇编码。</td>
</tr>
<tr>
<td>pvParameters</td>
<td>调用pvTaskCode函数指针时用到：pvTaskCode(pvParameters)</td>
</tr>
<tr>
<td>uxPriority</td>
<td>优先级范围：0~(configMAX_PRIORITIES – 1) 数值越小优先级越低， 如果传入过大的值，xTaskCreate会把它调整为(configMAX_PRIORITIES – 1)</td>
</tr>
<tr>
<td>pxCreatedTask</td>
<td>用来保存xTaskCreate的输出结果：task handle。 以后如果想操作这个任务，比如修改它的优先级，就需要这个handle。 如果不想使用该handle，可以传入NULL。</td>
</tr>
<tr>
<td>返回值</td>
<td>成功：pdPASS； 失败：errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY(失败原因只有内存不足) 注意：文档里都说失败时返回值是pdFAIL，这不对。 pdFAIL是0，errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY是-1。</td>
</tr>
</tbody></table>
<h3 id="3-2-3-示例1-创建任务"><a href="#3-2-3-示例1-创建任务" class="headerlink" title="3.2.3 示例1: 创建任务"></a>3.2.3 示例1: 创建任务</h3><p>代码为：<code>FreeRTOS_01_create_task</code></p>
<p>使用2个函数分别创建2个任务。</p>
<p>任务1的代码：</p>
<pre class="line-numbers language-none"><code class="language-none">void vTask1( void *pvParameters )
&#123;
	const char *pcTaskName &#x3D; &quot;T1 run\r\n&quot;;
	volatile uint32_t ul; &#x2F;* volatile用来避免被优化掉 *&#x2F;
	
	&#x2F;* 任务函数的主体一般都是无限循环 *&#x2F;
	for( ;; )
	&#123;
		&#x2F;* 打印任务1的信息 *&#x2F;
		printf( pcTaskName );
		
		&#x2F;* 延迟一会(比较简单粗暴) *&#x2F;
		for( ul &#x3D; 0; ul &lt; mainDELAY_LOOP_COUNT; ul++ )
		&#123;
		&#125;
	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>任务2的代码：</p>
<pre class="line-numbers language-none"><code class="language-none">void vTask2( void *pvParameters )
&#123;
	const char *pcTaskName &#x3D; &quot;T2 run\r\n&quot;;
	volatile uint32_t ul; &#x2F;* volatile用来避免被优化掉 *&#x2F;
	
	&#x2F;* 任务函数的主体一般都是无限循环 *&#x2F;
	for( ;; )
	&#123;
		&#x2F;* 打印任务1的信息 *&#x2F;
		printf( pcTaskName );
		
		&#x2F;* 延迟一会(比较简单粗暴) *&#x2F;
		for( ul &#x3D; 0; ul &lt; mainDELAY_LOOP_COUNT; ul++ )
		&#123;
		&#125;
	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>main函数：</p>
<pre class="line-numbers language-none"><code class="language-none">int main( void )
&#123;
	prvSetupHardware();
	
	xTaskCreate(vTask1, &quot;Task 1&quot;, 1000, NULL, 1, NULL);
	xTaskCreate(vTask2, &quot;Task 2&quot;, 1000, NULL, 1, NULL);

	&#x2F;* 启动调度器 *&#x2F;
	vTaskStartScheduler();

	&#x2F;* 如果程序运行到了这里就表示出错了, 一般是内存不足 *&#x2F;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果如下：</p>
<p><img src="https://gitee.com/guozunrong123/pic-bed/raw/master/img/04_create_two_task.png" alt="image-20210729170906116"></p>
<p>注意：</p>
<ul>
<li>task 2先运行！</li>
<li>要分析xTaskCreate的代码才能知道原因：更高优先级的、或者后面创建的任务先运行。</li>
</ul>
<p>任务运行图：</p>
<ul>
<li>在t1：Task2进入运行态，一直运行直到t2</li>
<li>在t2：Task1进入运行态，一直运行直到t3；在t3，Task2重新进入运行态</li>
</ul>
<p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/05_task_schedul.png" alt="image-20210729172213224"></p>
<h3 id="3-2-4-示例2-使用任务参数"><a href="#3-2-4-示例2-使用任务参数" class="headerlink" title="3.2.4 示例2: 使用任务参数"></a>3.2.4 示例2: 使用任务参数</h3><p>代码为：<code>FreeRTOS_02_create_task_use_params</code></p>
<p>我们说过，多个任务可以使用同一个函数，怎么体现它们的差别？</p>
<ul>
<li>栈不同</li>
<li>创建任务时可以传入不同的参数</li>
</ul>
<p>我们创建2个任务，使用同一个函数，代码如下：</p>
<pre class="line-numbers language-none"><code class="language-none">void vTaskFunction( void *pvParameters )
&#123;
	const char *pcTaskText &#x3D; pvParameters;
	volatile uint32_t ul; &#x2F;* volatile用来避免被优化掉 *&#x2F;
	
	&#x2F;* 任务函数的主体一般都是无限循环 *&#x2F;
	for( ;; )
	&#123;
		&#x2F;* 打印任务的信息 *&#x2F;
		printf(pcTaskText);
		
		&#x2F;* 延迟一会(比较简单粗暴) *&#x2F;
		for( ul &#x3D; 0; ul &lt; mainDELAY_LOOP_COUNT; ul++ )
		&#123;
		&#125;
	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上述代码中的<code>pcTaskText</code>来自参数<code>pvParameters</code>，<code>pvParameters</code>来自哪里？创建任务时传入的。</p>
<p>代码如下：</p>
<ul>
<li>使用xTaskCreate创建2个任务时，第4个参数就是pvParameters</li>
<li>不同的任务，pvParameters不一样</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">static const char *pcTextForTask1 &#x3D; &quot;T1 run\r\n&quot;;
static const char *pcTextForTask2 &#x3D; &quot;T2 run\r\n&quot;;

int main( void )
&#123;
	prvSetupHardware();
	
	xTaskCreate(vTaskFunction, &quot;Task 1&quot;, 1000, (void *)pcTextForTask1, 1, NULL);
	xTaskCreate(vTaskFunction, &quot;Task 2&quot;, 1000, (void *)pcTextForTask2, 1, NULL);

	&#x2F;* 启动调度器 *&#x2F;
	vTaskStartScheduler();

	&#x2F;* 如果程序运行到了这里就表示出错了, 一般是内存不足 *&#x2F;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="3-2-5-任务的删除"><a href="#3-2-5-任务的删除" class="headerlink" title="3.2.5 任务的删除"></a>3.2.5 任务的删除</h3><p>删除任务时使用的函数如下：</p>
<pre class="line-numbers language-none"><code class="language-none">void vTaskDelete( TaskHandle_t xTaskToDelete );<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>参数说明：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>pvTaskCode</td>
<td>任务句柄，使用xTaskCreate创建任务时可以得到一个句柄。 也可传入NULL，这表示删除自己。</td>
</tr>
</tbody></table>
<p>怎么删除任务？举个不好的例子：</p>
<ul>
<li>自杀：<code>vTaskDelete(NULL)</code></li>
<li>被杀：别的任务执行<code>vTaskDelete(pvTaskCode)</code>，pvTaskCode是自己的句柄</li>
<li>杀人：执行<code>vTaskDelete(pvTaskCode)</code>，pvTaskCode是别的任务的句柄</li>
</ul>
<h3 id="3-2-6-示例3-删除任务"><a href="#3-2-6-示例3-删除任务" class="headerlink" title="3.2.6 示例3: 删除任务"></a>3.2.6 示例3: 删除任务</h3><p>代码为：<code>FreeRTOS_03_delete_task</code></p>
<p>本节代码会涉及优先级的知识，可以只看vTaskDelete的用法，忽略优先级的讲解。</p>
<p>我们要做这些事情：</p>
<ul>
<li>创建任务1：任务1的大循环里，创建任务2，然后休眠一段时间</li>
<li>任务2：打印一句话，然后就删除自己</li>
</ul>
<p>任务1的代码如下：</p>
<pre class="line-numbers language-none"><code class="language-none">void vTask1( void *pvParameters )
&#123;
	const TickType_t xDelay100ms &#x3D; pdMS_TO_TICKS( 100UL );		
	BaseType_t ret;
	
	&#x2F;* 任务函数的主体一般都是无限循环 *&#x2F;
	for( ;; )
	&#123;
		&#x2F;* 打印任务的信息 *&#x2F;
		printf(&quot;Task1 is running\r\n&quot;);
		
		ret &#x3D; xTaskCreate( vTask2, &quot;Task 2&quot;, 1000, NULL, 2, &amp;xTask2Handle );
		if (ret !&#x3D; pdPASS)
			printf(&quot;Create Task2 Failed\r\n&quot;);
		
		&#x2F;&#x2F; 如果不休眠的话, Idle任务无法得到执行
		&#x2F;&#x2F; Idel任务会清理任务2使用的内存
		&#x2F;&#x2F; 如果不休眠则Idle任务无法执行, 最后内存耗尽
		vTaskDelay( xDelay100ms );
	&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>任务2的代码如下：</p>
<pre class="line-numbers language-none"><code class="language-none">void vTask2( void *pvParameters )
&#123;	
	&#x2F;* 打印任务的信息 *&#x2F;
	printf(&quot;Task2 is running and about to delete itself\r\n&quot;);

	&#x2F;&#x2F; 可以直接传入参数NULL, 这里只是为了演示函数用法
	vTaskDelete(xTask2Handle);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>main函数代码如下：</p>
<pre class="line-numbers language-none"><code class="language-none">int main( void )
&#123;
	prvSetupHardware();
	
	xTaskCreate(vTask1, &quot;Task 1&quot;, 1000, NULL, 1, NULL);

	&#x2F;* 启动调度器 *&#x2F;
	vTaskStartScheduler();

	&#x2F;* 如果程序运行到了这里就表示出错了, 一般是内存不足 *&#x2F;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果如下：</p>
<p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/04_delete_task.png" alt="image-20210731110531625"></p>
<p>任务运行图：</p>
<ul>
<li>main函数中创建任务1，优先级为1。任务1运行时，它创建任务2，任务2的优先级是2。</li>
<li>任务2的优先级最高，它马上执行。</li>
<li>任务2打印一句话后，就删除了自己。</li>
<li>任务2被删除后，任务1的优先级最高，轮到任务1继续运行，它调用<code>vTaskDelay() </code>进入Block状态</li>
<li>任务1 Block期间，轮到Idle任务执行：它释放任务2的内存(TCB、栈)</li>
<li>时间到后，任务1变为最高优先级的任务继续执行。</li>
<li>如此循环。</li>
</ul>
<p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/06_task_schedul_for_delete.png" alt="image-20210731111929008"></p>
<p>在任务1的函数中，如果不调用vTaskDelay，则Idle任务用于没有机会执行，它就无法释放创建任务2是分配的内存。</p>
<p>而任务1在不断地创建任务，不断地消耗内存，最终内存耗尽再也无法创建新的任务。</p>
<p>现象如下：</p>
<p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/07_create_task_fail.png" alt="image-20210731112826679"></p>
<p>任务1的代码中，需要注意的是：xTaskCreate的返回值。</p>
<ul>
<li>很多手册里说它失败时返回值是pdFAIL，这个宏是0</li>
<li>其实失败时返回值是errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY，这个宏是-1</li>
<li>为了避免混淆，我们使用返回值跟pdPASS来比较，这个宏是1</li>
</ul>
<h2 id="3-3-任务优先级和Tick"><a href="#3-3-任务优先级和Tick" class="headerlink" title="3.3 任务优先级和Tick"></a>3.3 任务优先级和Tick</h2><h3 id="3-3-1-任务优先级"><a href="#3-3-1-任务优先级" class="headerlink" title="3.3.1 任务优先级"></a>3.3.1 任务优先级</h3><p>在上个示例中我们体验过优先级的使用：高优先级的任务先运行。</p>
<p>优先级的取值范围是：0~(configMAX_PRIORITIES – 1)，数值越大优先级越高。</p>
<p>FreeRTOS的调度器可以使用2种方法来快速找出优先级最高的、可以运行的任务。使用不同的方法时，configMAX_PRIORITIES 的取值有所不同。</p>
<ul>
<li>通用方法 使用C函数实现，对所有的架构都是同样的代码。对configMAX_PRIORITIES的取值没有限制。但是configMAX_PRIORITIES的取值还是尽量小，因为取值越大越浪费内存，也浪费时间。 configUSE_PORT_OPTIMISED_TASK_SELECTION被定义为0、或者未定义时，使用此方法。</li>
<li>架构相关的优化的方法 架构相关的汇编指令，可以从一个32位的数里快速地找出为1的最高位。使用这些指令，可以快速找出优先级最高的、可以运行的任务。 使用这种方法时，configMAX_PRIORITIES的取值不能超过32。 configUSE_PORT_OPTIMISED_TASK_SELECTION被定义为1时，使用此方法。</li>
</ul>
<p>在学习调度方法之前，你只要初略地知道：</p>
<ul>
<li>FreeRTOS会确保最高优先级的、可运行的任务，马上就能执行</li>
<li>对于相同优先级的、可运行的任务，轮流执行</li>
</ul>
<p>这无需记忆，就像我们举的例子：</p>
<ul>
<li>厨房着火了，当然优先灭火</li>
<li>喂饭、回复信息同样重要，轮流做</li>
</ul>
<h3 id="3-3-2-Tick"><a href="#3-3-2-Tick" class="headerlink" title="3.3.2 Tick"></a>3.3.2 Tick</h3><p>对于同优先级的任务，它们“轮流”执行。怎么轮流？你执行一会，我执行一会。</p>
<p>“一会”怎么定义？</p>
<p>人有心跳，心跳间隔基本恒定。</p>
<p>FreeRTOS中也有心跳，它使用定时器产生固定间隔的中断。这叫Tick、滴答，比如每10ms发生一次时钟中断。</p>
<p>如下图：</p>
<ul>
<li>假设t1、t2、t3发生时钟中断</li>
<li>两次中断之间的时间被称为时间片(time slice、tick period)</li>
<li>时间片的长度由configTICK_RATE_HZ 决定，假设configTICK_RATE_HZ为100，那么时间片长度就是10ms</li>
</ul>
<p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/08_time_tick.png" alt="image-20210731130348561"></p>
<p>相同优先级的任务怎么切换呢？请看下图：</p>
<ul>
<li>任务2从t1执行到t2</li>
<li>在t2发生tick中断，进入tick中断处理函数：<ul>
<li>选择下一个要运行的任务</li>
<li>执行完中断处理函数后，切换到新的任务：任务1</li>
</ul>
</li>
<li>任务1从t2执行到t3</li>
<li>从下图中可以看出，任务运行的时间并不是严格从t1,t2,t3哪里开始</li>
</ul>
<p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/09_tick_interrtups.png" alt="image-20210731130720669"></p>
<p>有了Tick的概念后，我们就可以使用Tick来衡量时间了，比如：</p>
<pre class="line-numbers language-none"><code class="language-none">vTaskDelay(2);  &#x2F;&#x2F; 等待2个Tick，假设configTICK_RATE_HZ&#x3D;100, Tick周期时10ms, 等待20ms

&#x2F;&#x2F; 还可以使用pdMS_TO_TICKS宏把ms转换为tick
vTaskDelay(pdMS_TO_TICKS(100));	 &#x2F;&#x2F; 等待100ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>注意，基于Tick实现的延时并不精确，比如<code>vTaskDelay(2)</code>的本意是延迟2个Tick周期，有可能经过1个Tick多一点就返回了。</p>
<p>如下图：</p>
<p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/10_taskdelay.png" alt="image-20210731133559155"></p>
<p>使用vTaskDelay函数时，建议以ms为单位，使用pdMS_TO_TICKS把时间转换为Tick。</p>
<p>这样的代码就与configTICK_RATE_HZ无关，即使配置项configTICK_RATE_HZ改变了，我们也不用去修改代码。</p>
<h3 id="3-3-3-示例4-优先级实验"><a href="#3-3-3-示例4-优先级实验" class="headerlink" title="3.3.3 示例4: 优先级实验"></a>3.3.3 示例4: 优先级实验</h3><p>代码为：<code>FreeRTOS_04_task_priority</code></p>
<p>本程序会创建3个任务：</p>
<ul>
<li>任务1、任务2：优先级相同，都是1</li>
<li>任务3：优先级最高，是2</li>
</ul>
<p>任务1、2代码如下：</p>
<pre class="line-numbers language-none"><code class="language-none">void vTask1( void *pvParameters )
&#123;
	&#x2F;* 任务函数的主体一般都是无限循环 *&#x2F;
	for( ;; )
	&#123;
		&#x2F;* 打印任务的信息 *&#x2F;
		printf(&quot;T1\r\n&quot;);				
	&#125;
&#125;

void vTask2( void *pvParameters )
&#123;	
	&#x2F;* 任务函数的主体一般都是无限循环 *&#x2F;
	for( ;; )
	&#123;
		&#x2F;* 打印任务的信息 *&#x2F;
		printf(&quot;T2\r\n&quot;);				
	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>任务3代码如下：</p>
<pre class="line-numbers language-none"><code class="language-none">void vTask3( void *pvParameters )
&#123;	
	const TickType_t xDelay3000ms &#x3D; pdMS_TO_TICKS( 3000UL );		
	
	&#x2F;* 任务函数的主体一般都是无限循环 *&#x2F;
	for( ;; )
	&#123;
		&#x2F;* 打印任务的信息 *&#x2F;
		printf(&quot;T3\r\n&quot;);				

		&#x2F;&#x2F; 如果不休眠的话, 其他任务无法得到执行
		vTaskDelay( xDelay3000ms );
	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>main函数代码如下：</p>
<pre class="line-numbers language-none"><code class="language-none">&#123;
	prvSetupHardware();
	
	xTaskCreate(vTask1, &quot;Task 1&quot;, 1000, NULL, 1, NULL);
	xTaskCreate(vTask2, &quot;Task 2&quot;, 1000, NULL, 1, NULL);
	xTaskCreate(vTask3, &quot;Task 3&quot;, 1000, NULL, 2, NULL);

	&#x2F;* 启动调度器 *&#x2F;
	vTaskStartScheduler();

	&#x2F;* 如果程序运行到了这里就表示出错了, 一般是内存不足 *&#x2F;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行情况如下图所示：</p>
<ul>
<li>任务3优先执行，直到它调用vTaskDelay主动放弃运行</li>
<li>任务1、任务2：轮流执行</li>
</ul>
<p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/11_priority_result.png" alt="image-20210731140405148"></p>
<p>调度情况如下图所示：</p>
<p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/12_priority_scheduler.png" alt="image-20210731143751639"></p>
<h3 id="3-3-4-示例5-修改优先级"><a href="#3-3-4-示例5-修改优先级" class="headerlink" title="3.3.4 示例5: 修改优先级"></a>3.3.4 示例5: 修改优先级</h3><p>本节代码为：<code>FreeRTOS_05_change_priority</code>。</p>
<p>使用uxTaskPriorityGet来获得任务的优先级：</p>
<pre class="line-numbers language-none"><code class="language-none">UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask );<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>使用参数xTask来指定任务，设置为NULL表示获取自己的优先级。</p>
<p>使用vTaskPrioritySet 来设置任务的优先级：</p>
<pre class="line-numbers language-none"><code class="language-none">void vTaskPrioritySet( TaskHandle_t xTask,
                       UBaseType_t uxNewPriority );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>使用参数xTask来指定任务，设置为NULL表示设置自己的优先级； 参数uxNewPriority表示新的优先级，取值范围是0~(configMAX_PRIORITIES – 1)。</p>
<p>main函数的代码如下，它创建了2个任务：任务1的优先级更高，它先执行：</p>
<pre class="line-numbers language-none"><code class="language-none">int main( void )
&#123;
	prvSetupHardware();
	
	&#x2F;* Task1的优先级更高, Task1先执行 *&#x2F;
	xTaskCreate( vTask1, &quot;Task 1&quot;, 1000, NULL, 2, NULL );
	xTaskCreate( vTask2, &quot;Task 2&quot;, 1000, NULL, 1, &amp;xTask2Handle );

	&#x2F;* 启动调度器 *&#x2F;
	vTaskStartScheduler();

	&#x2F;* 如果程序运行到了这里就表示出错了, 一般是内存不足 *&#x2F;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>任务1的代码如下：</p>
<pre class="line-numbers language-none"><code class="language-none">void vTask1( void *pvParameters )
&#123;
	UBaseType_t uxPriority;
	
	&#x2F;* Task1,Task2都不会进入阻塞或者暂停状态
	 * 根据优先级决定谁能运行
	 *&#x2F;
	
	&#x2F;* 得到Task1自己的优先级 *&#x2F;
	uxPriority &#x3D; uxTaskPriorityGet( NULL );
	
	for( ;; )
	&#123;
		printf( &quot;Task 1 is running\r\n&quot; );

		printf(&quot;About to raise the Task 2 priority\r\n&quot; );
		
		&#x2F;* 提升Task2的优先级高于Task1
		 * Task2会即刻执行
 		 *&#x2F;
		vTaskPrioritySet( xTask2Handle, ( uxPriority + 1 ) );
		
		&#x2F;* 如果Task1能运行到这里，表示它的优先级比Task2高
		* 那就表示Task2肯定把自己的优先级降低了
 		 *&#x2F;
	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>任务2的代码如下：</p>
<pre class="line-numbers language-none"><code class="language-none">void vTask2( void *pvParameters )
&#123;
	UBaseType_t uxPriority;

	&#x2F;* Task1,Task2都不会进入阻塞或者暂停状态
	 * 根据优先级决定谁能运行
	 *&#x2F;
	
	&#x2F;* 得到Task2自己的优先级 *&#x2F;
	uxPriority &#x3D; uxTaskPriorityGet( NULL );
	
	for( ;; )
	&#123;
		&#x2F;* 能运行到这里表示Task2的优先级高于Task1
		 * Task1提高了Task2的优先级
		 *&#x2F;
		printf( &quot;Task 2 is running\r\n&quot; );
		
		printf( &quot;About to lower the Task 2 priority\r\n&quot; );

		&#x2F;* 降低Task2自己的优先级，让它小于Task1
		 * Task1得以运行
 		 *&#x2F;
		vTaskPrioritySet( NULL, ( uxPriority - 2 ) );
	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>调度情况如下图所示：</p>
<ul>
<li>1：一开始Task1优先级最高，它先执行。它提升了Task2的优先级。</li>
<li>2：Task2的优先级最高，它执行。它把自己的优先级降低了。</li>
<li>3：Task1的优先级最高，再次执行。它提升了Task2的优先级。</li>
<li>如此循环。</li>
<li>注意：Task1的优先级一直是2，Task2的优先级是3或1，都大于0。所以Idel任务没有机会执行。</li>
</ul>
<p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/15_change_priority.png" alt="image-20210731220350206"></p>
<h2 id="3-4-任务状态"><a href="#3-4-任务状态" class="headerlink" title="3.4 任务状态"></a>3.4 任务状态</h2><p>以前我们很简单地把任务的状态分为2中：运行(Runing)、非运行(Not Running)。</p>
<p>对于非运行的状态，还可以继续细分，比如前面的<code>FreeRTOS_04_task_priority</code>中：</p>
<ul>
<li>Task3执行vTaskDelay后：处于非运行状态，要过3秒种才能再次运行</li>
<li>Task3运行期间，Task1、Task2也处于非运行状态，但是它们<strong>随时可以运行</strong></li>
<li>这两种”非运行”状态就不一样，可以细分为：<ul>
<li>阻塞状态(Blocked)</li>
<li>暂停状态(Suspended)</li>
<li>就绪状态(Ready)</li>
</ul>
</li>
</ul>
<h3 id="3-4-1-阻塞状态-Blocked"><a href="#3-4-1-阻塞状态-Blocked" class="headerlink" title="3.4.1 阻塞状态(Blocked)"></a>3.4.1 阻塞状态(Blocked)</h3><p>在日常生活的例子中，母亲在电脑前跟同事沟通时，如果同事一直没回复，那么母亲的工作就被卡住了、被堵住了、处于阻塞状态(Blocked)。重点在于：母亲在<strong>等待</strong>。</p>
<p>在<code>FreeRTOS_04_task_priority</code>实验中，如果把任务3中的vTaskDelay调用注释掉，那么任务1、任务2根本没有执行的机会，任务1、任务2被”饿死”了(starve)。</p>
<p>在实际产品中，我们不会让一个任务一直运行，而是使用”事件驱动”的方法让它运行：</p>
<ul>
<li>任务要等待某个事件，事件发生后它才能运行</li>
<li>在等待事件过程中，它不消耗CPU资源</li>
<li>在等待事件的过程中，这个任务就处于阻塞状态(Blocked)</li>
</ul>
<p>在阻塞状态的任务，它可以等待两种类型的事件：</p>
<ul>
<li>时间相关的事件<ul>
<li>可以等待一段时间：我等2分钟</li>
<li>也可以一直等待，直到某个绝对时间：我等到下午3点</li>
</ul>
</li>
<li>同步事件：这事件由别的任务，或者是中断程序产生<ul>
<li>例子1：任务A等待任务B给它发送数据</li>
<li>例子2：任务A等待用户按下按键</li>
<li>同步事件的来源有很多(这些概念在后面会细讲)：<ul>
<li>队列(queue)</li>
<li>二进制信号量(binary semaphores)</li>
<li>计数信号量(counting semaphores)</li>
<li>互斥量(mutexes)</li>
<li>递归互斥量、递归锁(recursive mutexes)</li>
<li>事件组(event groups)</li>
<li>任务通知(task notifications)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>在等待一个同步事件时，可以加上超时时间。比如等待队里数据，超时时间设为10ms：</p>
<ul>
<li>10ms之内有数据到来：成功返回</li>
<li>10ms到了，还是没有数据：超时返回</li>
</ul>
<h3 id="3-4-2-暂停状态-Suspended"><a href="#3-4-2-暂停状态-Suspended" class="headerlink" title="3.4.2 暂停状态(Suspended)"></a>3.4.2 暂停状态(Suspended)</h3><p>在日常生活的例子中，母亲正在电脑前跟同事沟通，母亲可以暂停：</p>
<ul>
<li>好烦啊，我暂停一会</li>
<li>领导说：你暂停一下</li>
</ul>
<p>FreeRTOS中的任务也可以进入暂停状态，唯一的方法是通过vTaskSuspend函数。函数原型如下：</p>
<pre class="line-numbers language-none"><code class="language-none">void vTaskSuspend( TaskHandle_t xTaskToSuspend );<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>参数xTaskToSuspend表示要暂停的任务，如果为NULL，表示暂停自己。</p>
<p>要退出暂停状态，只能由<strong>别人</strong>来操作：</p>
<ul>
<li>别的任务调用：vTaskResume</li>
<li>中断程序调用：xTaskResumeFromISR</li>
</ul>
<p>实际开发中，暂停状态用得不多。</p>
<h3 id="3-4-3-就绪状态-Ready"><a href="#3-4-3-就绪状态-Ready" class="headerlink" title="3.4.3 就绪状态(Ready)"></a>3.4.3 就绪状态(Ready)</h3><p>这个任务完全准备好了，随时可以运行：只是还轮不到它。这时，它就处于就绪态(Ready)。</p>
<h3 id="3-4-4-完整的状态转换图"><a href="#3-4-4-完整的状态转换图" class="headerlink" title="3.4.4 完整的状态转换图"></a>3.4.4 完整的状态转换图</h3><p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/13_full_task_state_machine.png" alt="image-20210731155223985"></p>
<h2 id="3-5-Delay函数"><a href="#3-5-Delay函数" class="headerlink" title="3.5 Delay函数"></a>3.5 Delay函数</h2><h3 id="3-5-1-两个Delay函数"><a href="#3-5-1-两个Delay函数" class="headerlink" title="3.5.1 两个Delay函数"></a>3.5.1 两个Delay函数</h3><p>有两个Delay函数：</p>
<ul>
<li>vTaskDelay：至少等待指定个数的Tick Interrupt才能变为就绪状态</li>
<li>vTaskDelayUntil：等待到指定的绝对时刻，才能变为就绪态。</li>
</ul>
<p>这2个函数原型如下：</p>
<pre class="line-numbers language-none"><code class="language-none">void vTaskDelay( const TickType_t xTicksToDelay ); &#x2F;* xTicksToDelay: 等待多少给Tick *&#x2F;

&#x2F;* pxPreviousWakeTime: 上一次被唤醒的时间
 * xTimeIncrement: 要阻塞到(pxPreviousWakeTime + xTimeIncrement)
 * 单位都是Tick Count
 *&#x2F;
BaseType_t xTaskDelayUntil( TickType_t * const pxPreviousWakeTime,
                            const TickType_t xTimeIncrement );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>下面画图说明：</p>
<ul>
<li>使用vTaskDelay(n)时，进入、退出vTaskDelay的时间间隔至少是n个Tick中断</li>
<li>使用xTaskDelayUntil(&amp;Pre, n)时，前后两次退出xTaskDelayUntil的时间至少是n个Tick中断<ul>
<li>退出xTaskDelayUntil时任务就进入的就绪状态，一般都能得到执行机会</li>
<li>所以可以使用xTaskDelayUntil来让任务周期性地运行</li>
</ul>
</li>
</ul>
<p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/14_delay_functions.png" alt="image-20210731205236939"></p>
<h3 id="3-5-2-示例6-Delay"><a href="#3-5-2-示例6-Delay" class="headerlink" title="3.5.2 示例6: Delay"></a>3.5.2 示例6: Delay</h3><p>本节代码为：<code>FreeRTOS_06_taskdelay</code>。</p>
<p>本程序会创建2个任务：</p>
<ul>
<li>Task1：<ul>
<li>高优先级</li>
<li>设置变量flag为1，然后调用<code>vTaskDelay(xDelay50ms);</code>或<code>vTaskDelayUntil(&amp;xLastWakeTime, xDelay50ms);</code></li>
</ul>
</li>
<li>Task2：<ul>
<li>低优先级</li>
<li>设置变量flag为0</li>
</ul>
</li>
</ul>
<p>main函数代码如下：</p>
<pre class="line-numbers language-none"><code class="language-none">int main( void )
&#123;
	prvSetupHardware();
	
	&#x2F;* Task1的优先级更高, Task1先执行 *&#x2F;
	xTaskCreate( vTask1, &quot;Task 1&quot;, 1000, NULL, 2, NULL );
	xTaskCreate( vTask2, &quot;Task 2&quot;, 1000, NULL, 1, NULL );

	&#x2F;* 启动调度器 *&#x2F;
	vTaskStartScheduler();

	&#x2F;* 如果程序运行到了这里就表示出错了, 一般是内存不足 *&#x2F;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>Task1的代码中使用条件开关来选择Delay函数，把<code>#if 1</code>改为<code>#if 0</code>就可以使用<code>vTaskDelayUntil</code>，代码如下：</p>
<pre class="line-numbers language-none"><code class="language-none">void vTask1( void *pvParameters )
&#123;
	const TickType_t xDelay50ms &#x3D; pdMS_TO_TICKS( 50UL );
	TickType_t xLastWakeTime;
	int i;
	
	&#x2F;* 获得当前的Tick Count *&#x2F;
	xLastWakeTime &#x3D; xTaskGetTickCount();
			
	for( ;; )
	&#123;
		flag &#x3D; 1;
		
		&#x2F;* 故意加入多个循环，让程序运行时间长一点 *&#x2F;
		for (i &#x3D; 0; i &lt;5; i++)
			printf( &quot;Task 1 is running\r\n&quot; );

#if 1		
		vTaskDelay(xDelay50ms);
#else		
		vTaskDelayUntil(&amp;xLastWakeTime, xDelay50ms);
#endif		
	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>Task2的代码如下：</p>
<pre class="line-numbers language-none"><code class="language-none">void vTask2( void *pvParameters )
&#123;
	for( ;; )
	&#123;
		flag &#x3D; 0;
		printf( &quot;Task 2 is running\r\n&quot; );
	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>使用Keil的逻辑分析观察flag变量的bit波形，如下：</p>
<ul>
<li>flag为1时表示Task1在运行，flag为0时表示Task2在运行，也就是Task1处于阻塞状态</li>
<li>vTaskDelay：指定的是阻塞的时间</li>
<li>vTaskDelayUntil：指定的是任务执行的间隔、周期</li>
</ul>
<p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/16_delay_time.png" alt="image-20210731233309265"></p>
<h2 id="3-6-空闲任务及其钩子函数"><a href="#3-6-空闲任务及其钩子函数" class="headerlink" title="3.6 空闲任务及其钩子函数"></a>3.6 空闲任务及其钩子函数</h2><h3 id="3-6-1-介绍"><a href="#3-6-1-介绍" class="headerlink" title="3.6.1 介绍"></a>3.6.1 介绍</h3><p>在<code>FreeRTOS_03_delete_task</code>的实验里，我们体验过空闲任务(Idle任务)的作用：释放被删除的任务的内存。</p>
<p>除了上述目的之外，为什么必须要有空闲任务？一个良好的程序，它的任务都是事件驱动的：平时大部分时间处于阻塞状态。有可能我们自己创建的所有任务都无法执行，但是调度器必须能找到一个可以运行的任务：所以，我们要提供空闲任务。在使用<code>vTaskStartScheduler() </code>函数来创建、启动调度器时，这个函数内部会创建空闲任务：</p>
<ul>
<li>空闲任务优先级为0：它不能阻碍用户任务运行</li>
<li>空闲任务要么处于就绪态，要么处于运行态，永远不会阻塞</li>
</ul>
<p>空闲任务的优先级为0，这意味着一旦某个用户的任务变为就绪态，那么空闲任务马上被切换出去，让这个用户任务运行。在这种情况下，我们说用户任务”抢占”(pre-empt)了空闲任务，这是由调度器实现的。</p>
<p>要注意的是：如果使用<code>vTaskDelete() </code>来删除任务，那么你就要确保空闲任务有机会执行，否则就无法释放被删除任务的内存。</p>
<p>我们可以添加一个空闲任务的钩子函数(Idle Task Hook Functions)，空闲任务的循环每执行一次，就会调用一次钩子函数。钩子函数的作用有这些：</p>
<ul>
<li>执行一些低优先级的、后台的、需要连续执行的函数</li>
<li>测量系统的空闲时间：空闲任务能被执行就意味着所有的高优先级任务都停止了，所以测量空闲任务占据的时间，就可以算出处理器占用率。</li>
<li>让系统进入省电模式：空闲任务能被执行就意味着没有重要的事情要做，当然可以进入省电模式了。</li>
</ul>
<p>空闲任务的钩子函数的限制：</p>
<ul>
<li>不能导致空闲任务进入阻塞状态、暂停状态</li>
<li>如果你会使用<code>vTaskDelete() </code>来删除任务，那么钩子函数要非常高效地执行。如果空闲任务移植卡在钩子函数里的话，它就无法释放内存。</li>
</ul>
<h3 id="3-6-2-使用钩子函数的前提"><a href="#3-6-2-使用钩子函数的前提" class="headerlink" title="3.6.2 使用钩子函数的前提"></a>3.6.2 使用钩子函数的前提</h3><p>在<code>FreeRTOS\Source\tasks.c</code>中，可以看到如下代码，所以前提就是：</p>
<ul>
<li>把这个宏定义为1：configUSE_IDLE_HOOK</li>
<li>实现<code>vApplicationIdleHook</code>函数</li>
</ul>
<p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/17_idle_hook.png" alt="image-20210801005130872"></p>
<h2 id="3-7-调度算法"><a href="#3-7-调度算法" class="headerlink" title="3.7 调度算法"></a>3.7 调度算法</h2><h3 id="3-7-1-重要概念"><a href="#3-7-1-重要概念" class="headerlink" title="3.7.1 重要概念"></a>3.7.1 重要概念</h3><p>这些知识在前面都提到过了，这里总结一下。</p>
<p>正在运行的任务，被称为”正在使用处理器”，它处于运行状态。在单处理系统中，任何时间里只能有一个任务处于运行状态。</p>
<p>非运行状态的任务，它处于这3中状态之一：阻塞(Blocked)、暂停(Suspended)、就绪(Ready)。就绪态的任务，可以被调度器挑选出来切换为运行状态，调度器永远都是挑选最高优先级的就绪态任务并让它进入运行状态。</p>
<p>阻塞状态的任务，它在等待”事件”，当事件发生时任务就会进入就绪状态。事件分为两类：时间相关的事件、同步事件。所谓时间相关的事件，就是设置超时时间：在指定时间内阻塞，时间到了就进入就绪状态。使用时间相关的事件，可以实现周期性的功能、可以实现超时功能。同步事件就是：某个任务在等待某些信息，别的任务或者中断服务程序会给它发送信息。怎么”发送信息”？方法很多，有：任务通知(task notification)、队列(queue)、事件组(event group)、信号量(semaphoe)、互斥量(mutex)等。这些方法用来发送同步信息，比如表示某个外设得到了数据。</p>
<h3 id="3-7-2-配置调度算法"><a href="#3-7-2-配置调度算法" class="headerlink" title="3.7.2 配置调度算法"></a>3.7.2 配置调度算法</h3><p>所谓调度算法，就是怎么确定哪个就绪态的任务可以切换为运行状态。</p>
<p>通过配置文件FreeRTOSConfig.h的两个配置项来配置调度算法：configUSE_PREEMPTION、configUSE_TIME_SLICING。</p>
<p>还有第三个配置项：configUSE_TICKLESS_IDLE，它是一个高级选项，用于关闭Tick中断来实现省电，后续单独讲解。现在我们假设configUSE_TICKLESS_IDLE被设为0，先不使用这个功能。</p>
<p>调度算法的行为主要体现在两方面：高优先级的任务先运行、同优先级的就绪态任务如何被选中。调度算法要确保同优先级的就绪态任务，能”轮流”运行，策略是”轮转调度”(Round Robin Scheduling)。轮转调度并不保证任务的运行时间是公平分配的，我们还可以细化时间的分配方法。</p>
<p>从3个角度统一理解多种调度算法：</p>
<ul>
<li>可否抢占？高优先级的任务能否优先执行(配置项: configUSE_PREEMPTION)<ul>
<li>可以：被称作”可抢占调度”(Pre-emptive)，高优先级的就绪任务马上执行，下面再细化。</li>
<li>不可以：不能抢就只能协商了，被称作”合作调度模式”(Co-operative Scheduling)<ul>
<li>当前任务执行时，更高优先级的任务就绪了也不能马上运行，只能等待当前任务主动让出CPU资源。</li>
<li>其他同优先级的任务也只能等待：更高优先级的任务都不能抢占，平级的更应该老实点</li>
</ul>
</li>
</ul>
</li>
<li>可抢占的前提下，同优先级的任务是否轮流执行(配置项：configUSE_TIME_SLICING)<ul>
<li>轮流执行：被称为”时间片轮转”(Time Slicing)，同优先级的任务轮流执行，你执行一个时间片、我再执行一个时间片</li>
<li>不轮流执行：英文为”without Time Slicing”，当前任务会一直执行，直到主动放弃、或者被高优先级任务抢占</li>
</ul>
</li>
<li>在”可抢占”+”时间片轮转”的前提下，进一步细化：空闲任务是否让步于用户任务(配置项：configIDLE_SHOULD_YIELD)<ul>
<li>空闲任务低人一等，每执行一次循环，就看看是否主动让位给用户任务</li>
<li>空闲任务跟用户任务一样，大家轮流执行，没有谁更特殊</li>
</ul>
</li>
</ul>
<p>列表如下：</p>
<table>
<thead>
<tr>
<th>配置项</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
</tr>
</thead>
<tbody><tr>
<td>configUSE_PREEMPTION</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>configUSE_TIME_SLICING</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>x</td>
</tr>
<tr>
<td>configIDLE_SHOULD_YIELD</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>x</td>
</tr>
<tr>
<td>说明</td>
<td>常用</td>
<td>很少用</td>
<td>很少用</td>
<td>很少用</td>
<td>几乎不用</td>
</tr>
</tbody></table>
<p>注：</p>
<ul>
<li>A：可抢占+时间片轮转+空闲任务让步</li>
<li>B：可抢占+时间片轮转+空闲任务不让步</li>
<li>C：可抢占+非时间片轮转+空闲任务让步</li>
<li>D：可抢占+非时间片轮转+空闲任务不让步</li>
<li>E：合作调度</li>
</ul>
<h3 id="3-7-3-示例7-调度"><a href="#3-7-3-示例7-调度" class="headerlink" title="3.7.3 示例7: 调度"></a>3.7.3 示例7: 调度</h3><p>本节代码为：<code>FreeRTOS_07_scheduler</code>。后续的实验都是基于这个程序，通过修改配置项来观察效果。</p>
<p>代码里创建了3个任务：Task1、Task2的优先级都是0，跟空闲任务一样，Task3优先级最高为2。程序里定义了4个全局变量，当某个的任务执行时，对应的变量就被设为1，可以通过Keil的逻辑分析仪查看任务切换情况：</p>
<pre class="line-numbers language-none"><code class="language-none">static volatile int flagIdleTaskrun &#x3D; 0;  &#x2F;&#x2F; 空闲任务运行时flagIdleTaskrun&#x3D;1
static volatile int flagTask1run &#x3D; 0;     &#x2F;&#x2F; 任务1运行时flagTask1run&#x3D;1
static volatile int flagTask2run &#x3D; 0;     &#x2F;&#x2F; 任务2运行时flagTask2run&#x3D;1
static volatile int flagTask3run &#x3D; 0;     &#x2F;&#x2F; 任务3运行时flagTask3run&#x3D;1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>main函数代码如下：</p>
<pre class="line-numbers language-none"><code class="language-none">int main( void )
&#123;
	prvSetupHardware();
	
	xTaskCreate(vTask1, &quot;Task 1&quot;, 1000, NULL, 0, NULL);
	xTaskCreate(vTask2, &quot;Task 2&quot;, 1000, NULL, 0, NULL);
	xTaskCreate(vTask3, &quot;Task 3&quot;, 1000, NULL, 2, NULL);

	&#x2F;* 启动调度器 *&#x2F;
	vTaskStartScheduler();

	&#x2F;* 如果程序运行到了这里就表示出错了, 一般是内存不足 *&#x2F;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>任务1、任务2代码如下，它们是”连续任务”(continuous task)：</p>
<pre class="line-numbers language-none"><code class="language-none">void vTask1( void *pvParameters )
&#123;
	&#x2F;* 任务函数的主体一般都是无限循环 *&#x2F;
	for( ;; )
	&#123;
		flagIdleTaskrun &#x3D; 0;
		flagTask1run &#x3D; 1;
		flagTask2run &#x3D; 0;
		flagTask3run &#x3D; 0;
		
		&#x2F;* 打印任务的信息 *&#x2F;
		printf(&quot;T1\r\n&quot;);				
	&#125;
&#125;

void vTask2( void *pvParameters )
&#123;	
	&#x2F;* 任务函数的主体一般都是无限循环 *&#x2F;
	for( ;; )
	&#123;
		flagIdleTaskrun &#x3D; 0;
		flagTask1run &#x3D; 0;
		flagTask2run &#x3D; 1;
		flagTask3run &#x3D; 0;
		
		&#x2F;* 打印任务的信息 *&#x2F;
		printf(&quot;T2\r\n&quot;);				
	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>任务3代码如下，它会调用<code>vTaskDelay</code>，这样别的任务才可以运行：</p>
<pre class="line-numbers language-none"><code class="language-none">void vTask3( void *pvParameters )
&#123;	
	const TickType_t xDelay5ms &#x3D; pdMS_TO_TICKS( 5UL );		
	
	&#x2F;* 任务函数的主体一般都是无限循环 *&#x2F;
	for( ;; )
	&#123;
		flagIdleTaskrun &#x3D; 0;
		flagTask1run &#x3D; 0;
		flagTask2run &#x3D; 0;
		flagTask3run &#x3D; 1;
		
		&#x2F;* 打印任务的信息 *&#x2F;
		printf(&quot;T3\r\n&quot;);				

		&#x2F;&#x2F; 如果不休眠的话, 其他任务无法得到执行
		vTaskDelay( xDelay5ms );
	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>提供了一个空闲任务的钩子函数：</p>
<pre class="line-numbers language-none"><code class="language-none">void vApplicationIdleHook(void)
&#123;
	flagIdleTaskrun &#x3D; 1;
	flagTask1run &#x3D; 0;
	flagTask2run &#x3D; 0;
	flagTask3run &#x3D; 0;	
	
	&#x2F;* 故意加入打印让flagIdleTaskrun变为1的时间维持长一点 *&#x2F;
	printf(&quot;Id\r\n&quot;);				
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="3-7-4-对比效果-抢占与否"><a href="#3-7-4-对比效果-抢占与否" class="headerlink" title="3.7.4 对比效果: 抢占与否"></a>3.7.4 对比效果: 抢占与否</h3><p>在<code>FreeRTOSConfig.h</code>中，定义这样的宏，对比逻辑分析仪的效果：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 实验1：抢占
#define configUSE_PREEMPTION		1
#define configUSE_TIME_SLICING      1
#define configIDLE_SHOULD_YIELD		1

&#x2F;&#x2F; 实验2：不抢占
#define configUSE_PREEMPTION		0
#define configUSE_TIME_SLICING      1
#define configIDLE_SHOULD_YIELD		1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>从下面的对比图可以知道：</p>
<ul>
<li>抢占时：高优先级任务就绪时，就可以马上执行</li>
<li>不抢占时：优先级失去意义了，既然不能抢占就只能协商了，图中任务1一直在运行(一点都没有协商精神)，其他任务都无法执行。即使任务3的<code>vTaskDelay</code>已经超时、即使它的优先级更高，都没办法执行。</li>
</ul>
<p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/18_pre-emptive_or_not.png" alt="image-20210802000142854"></p>
<h3 id="3-7-5-对比效果-时间片轮转与否"><a href="#3-7-5-对比效果-时间片轮转与否" class="headerlink" title="3.7.5 对比效果: 时间片轮转与否"></a>3.7.5 对比效果: 时间片轮转与否</h3><p>在<code>FreeRTOSConfig.h</code>中，定义这样的宏，对比逻辑分析仪的效果：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 实验1：时间片轮转
#define configUSE_PREEMPTION		1
#define configUSE_TIME_SLICING      1
#define configIDLE_SHOULD_YIELD		1

&#x2F;&#x2F; 实验2：时间片不轮转
#define configUSE_PREEMPTION		1
#define configUSE_TIME_SLICING      0
#define configIDLE_SHOULD_YIELD		1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>从下面的对比图可以知道：</p>
<ul>
<li>时间片轮转：在Tick中断中会引起任务切换</li>
<li>时间片不轮转：高优先级任务就绪时会引起任务切换，高优先级任务不再运行时也会引起任务切换。可以看到任务3就绪后可以马上执行，它运行完毕后导致任务切换。其他时间没有任务切换，可以看到任务1、任务2都运行了很长时间。</li>
</ul>
<p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/19_time_slicing_or_not.png" alt="image-20210802000056846"></p>
<h3 id="3-7-6-对比效果-空闲任务让步"><a href="#3-7-6-对比效果-空闲任务让步" class="headerlink" title="3.7.6 对比效果: 空闲任务让步"></a>3.7.6 对比效果: 空闲任务让步</h3><p>在<code>FreeRTOSConfig.h</code>中，定义这样的宏，对比逻辑分析仪的效果：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 实验1：空闲任务让步
#define configUSE_PREEMPTION		1
#define configUSE_TIME_SLICING      1
#define configIDLE_SHOULD_YIELD		1

&#x2F;&#x2F; 实验2：空闲任务不让步
#define configUSE_PREEMPTION		1
#define configUSE_TIME_SLICING      1
#define configIDLE_SHOULD_YIELD		0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>从下面的对比图可以知道：</p>
<ul>
<li>让步时：在空闲任务的每个循环中，会主动让出处理器，从图中可以看到flagIdelTaskrun的波形很小</li>
<li>不让步时：空闲任务跟任务1、任务2同等待遇，它们的波形宽度是差不多的</li>
</ul>
<p><img src="http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/20_yield_or_not.png" alt="image-20210802000255899"></p>

                
            </div>
            <hr/>

            



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
                                    <span class="chip bg-color">操作系统</span>
                                </a>
                            
                                <a href="/tags/Freertos/">
                                    <span class="chip bg-color">Freertos</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    
    <div class="livere-card card" data-aos="fade-up">
    <!-- 来必力City版安装代码 -->
    <div id="lv-container" class="card-content" data-id="city" data-uid="MTAyMC81NzkxMS8zNDM3NA==">
        <script type="text/javascript">
            (function (d, s) {
                let j, e = d.getElementsByTagName(s)[0];
                if (typeof LivereTower === 'function') {
                    return;
                }

                j = d.createElement(s);
                j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
                j.async = true;

                e.parentNode.insertBefore(j, e);
            })(document, 'script');
        </script>
        <noscript>为正常使用来必力评论功能请激活JavaScript。</noscript>
    </div>
    <!-- City版安装代码已完成 -->
</div>
    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="far fa-dot-circle"></i>&nbsp;本篇
            </div>
            <div class="card">
                <a href="/2023/03/15/Learn/Freertos/FreeRTOS%E7%B3%BB%E7%BB%9F%E5%AD%A6/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/6.jpg" class="responsive-img" alt="Freertos">
                        
                        <span class="card-title">Freertos</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            参考韦东山RTOS
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-03-15
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Learn/" class="post-category">
                                    Learn
                                </a>
                            
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
                        <span class="chip bg-color">操作系统</span>
                    </a>
                    
                    <a href="/tags/Freertos/">
                        <span class="chip bg-color">Freertos</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/03/13/Learn/QT/QT_Chaprter2/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/13.jpg" class="responsive-img" alt="QT_Chaprter2">
                        
                        <span class="card-title">QT_Chaprter2</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-03-13
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Learn/" class="post-category">
                                    Learn
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/QT/">
                        <span class="chip bg-color">QT</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>


  <!-- 是否加载使用自带的 prismjs. -->
  <script type="text/javascript" src="/libs/prism/prism.min.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2023</span>
            
            <a href="/about" target="_blank">Gzr</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            
            <br>
            
                &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                        class="white-color">57k</span>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/guozunrong123" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1650224714@qq.com" class="tooltipped" target="_blank" data-tooltip="邮箱联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope"></i>
    </a>




    <a href="https://m.weibo.cn/profile/2529234370" class="tooltipped" target="_blank" data-tooltip="微博联系我" data-position="top" data-delay="50">
        <i class="fab fa-weibo"></i>
    </a>



    <a href="tencent://message/?uin=1650224714&amp;Site=&amp;Menu=yes" class="tooltipped" target="_blank" data-tooltip="QQ联系我:1650224714" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>


</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
    
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    
    <script type="text/javascript" color="0,0,255"
        pointColor="0,0,255" opacity='0.7'
        zIndex="-1" count="99"
        src="/libs/background/canvas-nest.js"></script>
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
